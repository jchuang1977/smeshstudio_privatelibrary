   1               		.file	"stk500boot.c"
   2               	__SREG__ = 0x3f
   3               	__SP_H__ = 0x3e
   4               	__SP_L__ = 0x3d
   5               	__CCP__ = 0x34
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.global __do_copy_data
   9               		.global __do_clear_bss
  10               		.text
  11               	.Ltext0:
  12               		.cfi_sections	.debug_frame
  14               	sendchar:
  15               	.LFB9:
  16               		.file 1 "stk500boot.c"
   1:stk500boot.c  **** /*****************************************************************************
   2:stk500boot.c  **** Title:     STK500v2 compatible bootloader
   3:stk500boot.c  ****            Modified for Wiring board ATMega128-16MHz
   4:stk500boot.c  **** Author:    Peter Fleury <pfleury@gmx.ch>   http://jump.to/fleury
   5:stk500boot.c  **** File:      $Id: stk500boot.c,v 1.11 2006/06/25 12:39:17 peter Exp $
   6:stk500boot.c  **** Compiler:  avr-gcc 3.4.5 or 4.1 / avr-libc 1.4.3
   7:stk500boot.c  **** Hardware:  All AVRs with bootloader support, tested with ATmega8
   8:stk500boot.c  **** License:   GNU General Public License
   9:stk500boot.c  **** 
  10:stk500boot.c  **** Modified:  Worapoht Kornkaewwattanakul <dev@avride.com>   http://www.avride.com
  11:stk500boot.c  **** Date:      17 October 2007
  12:stk500boot.c  **** Update:    1st, 29 Dec 2007 : Enable CMD_SPI_MULTI but ignore unused command by return 0x00 byte re
  13:stk500boot.c  **** Compiler:  WINAVR20060421
  14:stk500boot.c  **** Description: add timeout feature like previous Wiring bootloader
  15:stk500boot.c  **** 
  16:stk500boot.c  **** DESCRIPTION:
  17:stk500boot.c  ****     This program allows an AVR with bootloader capabilities to
  18:stk500boot.c  ****     read/write its own Flash/EEprom. To enter Programming mode
  19:stk500boot.c  ****     an input pin is checked. If this pin is pulled low, programming mode
  20:stk500boot.c  ****     is entered. If not, normal execution is done from $0000
  21:stk500boot.c  ****     "reset" vector in Application area.
  22:stk500boot.c  ****     Size fits into a 1024 word bootloader section
  23:stk500boot.c  **** 	when compiled with avr-gcc 4.1
  24:stk500boot.c  **** 	(direct replace on Wiring Board without fuse setting changed)
  25:stk500boot.c  **** 
  26:stk500boot.c  **** USAGE:
  27:stk500boot.c  ****     - Set AVR MCU type and clock-frequency (F_CPU) in the Makefile.
  28:stk500boot.c  ****     - Set baud rate below (AVRISP only works with 115200 bps)
  29:stk500boot.c  ****     - compile/link the bootloader with the supplied Makefile
  30:stk500boot.c  ****     - program the "Boot Flash section size" (BOOTSZ fuses),
  31:stk500boot.c  ****       for boot-size 1024 words:  program BOOTSZ01
  32:stk500boot.c  ****     - enable the BOOT Reset Vector (program BOOTRST)
  33:stk500boot.c  ****     - Upload the hex file to the AVR using any ISP programmer
  34:stk500boot.c  ****     - Program Boot Lock Mode 3 (program BootLock 11 and BootLock 12 lock bits) // (leave them)
  35:stk500boot.c  ****     - Reset your AVR while keeping PROG_PIN pulled low // (for enter bootloader by switch)
  36:stk500boot.c  ****     - Start AVRISP Programmer (AVRStudio/Tools/Program AVR)
  37:stk500boot.c  ****     - AVRISP will detect the bootloader
  38:stk500boot.c  ****     - Program your application FLASH file and optional EEPROM file using AVRISP
  39:stk500boot.c  **** 
  40:stk500boot.c  **** Note:
  41:stk500boot.c  ****     Erasing the device without flashing, through AVRISP GUI button "Erase Device"
  42:stk500boot.c  ****     is not implemented, due to AVRStudio limitations.
  43:stk500boot.c  ****     Flash is always erased before programming.
  44:stk500boot.c  **** 
  45:stk500boot.c  **** 	AVRdude:
  46:stk500boot.c  **** 	Please uncomment #define REMOVE_CMD_SPI_MULTI when using AVRdude.
  47:stk500boot.c  **** 	Comment #define REMOVE_PROGRAM_LOCK_BIT_SUPPORT to reduce code size
  48:stk500boot.c  **** 	Read Fuse Bits and Read/Write Lock Bits is not supported
  49:stk500boot.c  **** 
  50:stk500boot.c  **** NOTES:
  51:stk500boot.c  ****     Based on Atmel Application Note AVR109 - Self-programming
  52:stk500boot.c  ****     Based on Atmel Application Note AVR068 - STK500v2 Protocol
  53:stk500boot.c  **** 
  54:stk500boot.c  **** LICENSE:
  55:stk500boot.c  ****     Copyright (C) 2006 Peter Fleury
  56:stk500boot.c  **** 
  57:stk500boot.c  ****     This program is free software; you can redistribute it and/or modify
  58:stk500boot.c  ****     it under the terms of the GNU General Public License as published by
  59:stk500boot.c  ****     the Free Software Foundation; either version 2 of the License, or
  60:stk500boot.c  ****     any later version.
  61:stk500boot.c  **** 
  62:stk500boot.c  ****     This program is distributed in the hope that it will be useful,
  63:stk500boot.c  ****     but WITHOUT ANY WARRANTY; without even the implied warranty of
  64:stk500boot.c  ****     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  65:stk500boot.c  ****     GNU General Public License for more details.
  66:stk500boot.c  **** 
  67:stk500boot.c  **** *****************************************************************************/
  68:stk500boot.c  **** 
  69:stk500boot.c  **** //************************************************************************
  70:stk500boot.c  **** //*	Edit History
  71:stk500boot.c  **** //************************************************************************
  72:stk500boot.c  **** //*	Jul  7,	2010	<MLS> = Mark Sproul msproul@skycharoit.com
  73:stk500boot.c  **** //*	Jul  7,	2010	<MLS> Working on mega2560. No Auto-restart
  74:stk500boot.c  **** //*	Jul  7,	2010	<MLS> Switched to 8K bytes (4K words) so that we have room for the monitor
  75:stk500boot.c  **** //*	Jul  8,	2010	<MLS> Found older version of source that had auto restart, put that code back in
  76:stk500boot.c  **** //*	Jul  8,	2010	<MLS> Adding monitor code
  77:stk500boot.c  **** //*	Jul 11,	2010	<MLS> Added blinking LED while waiting for download to start
  78:stk500boot.c  **** //*	Jul 11,	2010	<MLS> Added EEPROM test
  79:stk500boot.c  **** //*	Jul 29,	2010	<MLS> Added recchar_timeout for timing out on bootloading
  80:stk500boot.c  **** //*	Aug 23,	2010	<MLS> Added support for atmega2561
  81:stk500boot.c  **** //*	Aug 26,	2010	<MLS> Removed support for BOOT_BY_SWITCH
  82:stk500boot.c  **** //*	Sep  8,	2010	<MLS> Added support for atmega16
  83:stk500boot.c  **** //*	Nov  9,	2010	<MLS> Issue 392:Fixed bug that 3 !!! in code would cause it to jump to monitor
  84:stk500boot.c  **** //*	Jun 24,	2011	<MLS> Removed analogRead (was not used)
  85:stk500boot.c  **** //*	Dec 29,	2011	<MLS> Issue 181: added watch dog timmer support
  86:stk500boot.c  **** //*	Dec 29,	2011	<MLS> Issue 505:  bootloader is comparing the seqNum to 1 or the current sequence 
  87:stk500boot.c  **** //*	Jan  1,	2012	<MLS> Issue 543: CMD_CHIP_ERASE_ISP now returns STATUS_CMD_FAILED instead of STATU
  88:stk500boot.c  **** //*	Jan  1,	2012	<MLS> Issue 543: Write EEPROM now does something (NOT TESTED)
  89:stk500boot.c  **** //*	Jan  1,	2012	<MLS> Issue 544: stk500v2 bootloader doesn't support reading fuses
  90:stk500boot.c  **** //************************************************************************
  91:stk500boot.c  **** 
  92:stk500boot.c  **** //************************************************************************
  93:stk500boot.c  **** //*	these are used to test issues
  94:stk500boot.c  **** //*	http://code.google.com/p/arduino/issues/detail?id=505
  95:stk500boot.c  **** //*	Reported by mark.stubbs, Mar 14, 2011
  96:stk500boot.c  **** //*	The STK500V2 bootloader is comparing the seqNum to 1 or the current sequence 
  97:stk500boot.c  **** //*	(IE: Requiring the sequence to be 1 or match seqNum before continuing).  
  98:stk500boot.c  **** //*	The correct behavior is for the STK500V2 to accept the PC's sequence number, and echo it back f
  99:stk500boot.c  **** #define	_FIX_ISSUE_505_
 100:stk500boot.c  **** //************************************************************************
 101:stk500boot.c  **** //*	Issue 181: added watch dog timmer support
 102:stk500boot.c  **** #define	_FIX_ISSUE_181_
 103:stk500boot.c  **** 
 104:stk500boot.c  **** #include	<inttypes.h>
 105:stk500boot.c  **** #include	<avr/io.h>
 106:stk500boot.c  **** #include	<avr/interrupt.h>
 107:stk500boot.c  **** #include	<avr/boot.h>
 108:stk500boot.c  **** #include	<avr/pgmspace.h>
 109:stk500boot.c  **** #include	<util/delay.h>
 110:stk500boot.c  **** #include	<avr/eeprom.h>
 111:stk500boot.c  **** #include	<avr/common.h>
 112:stk500boot.c  **** #include	<stdlib.h>
 113:stk500boot.c  **** #include	"command.h"
 114:stk500boot.c  **** 
 115:stk500boot.c  **** 
 116:stk500boot.c  **** #if defined(_MEGA_BOARD_) || defined(_BOARD_AMBER128_) || defined(__AVR_ATmega1280__) || defined(__
 117:stk500boot.c  **** 	|| defined(__AVR_ATmega2561__) || defined(__AVR_ATmega1284P__) || defined(ENABLE_MONITOR) || defin
 118:stk500boot.c  **** 	#undef		ENABLE_MONITOR
 119:stk500boot.c  **** 	#define		ENABLE_MONITOR
 120:stk500boot.c  **** 	static void	RunMonitor(void);
 121:stk500boot.c  **** #endif
 122:stk500boot.c  **** 
 123:stk500boot.c  **** #ifndef EEWE
 124:stk500boot.c  **** 	#define EEWE    1
 125:stk500boot.c  **** #endif
 126:stk500boot.c  **** #ifndef EEMWE
 127:stk500boot.c  **** 	#define EEMWE   2
 128:stk500boot.c  **** #endif
 129:stk500boot.c  **** 
 130:stk500boot.c  **** //#define	_DEBUG_SERIAL_
 131:stk500boot.c  **** //#define	_DEBUG_WITH_LEDS_
 132:stk500boot.c  **** 
 133:stk500boot.c  **** 
 134:stk500boot.c  **** /*
 135:stk500boot.c  ****  * Uncomment the following lines to save code space
 136:stk500boot.c  ****  */
 137:stk500boot.c  **** //#define	REMOVE_PROGRAM_LOCK_BIT_SUPPORT		// disable program lock bits
 138:stk500boot.c  **** //#define	REMOVE_BOOTLOADER_LED				// no LED to show active bootloader
 139:stk500boot.c  **** //#define	REMOVE_CMD_SPI_MULTI				// disable processing of SPI_MULTI commands, Remark this line for
 140:stk500boot.c  **** //
 141:stk500boot.c  **** 
 142:stk500boot.c  **** 
 143:stk500boot.c  **** 
 144:stk500boot.c  **** //************************************************************************
 145:stk500boot.c  **** //*	LED on pin "PROGLED_PIN" on port "PROGLED_PORT"
 146:stk500boot.c  **** //*	indicates that bootloader is active
 147:stk500boot.c  **** //*	PG2 -> LED on Wiring board
 148:stk500boot.c  **** //************************************************************************
 149:stk500boot.c  **** #define		BLINK_LED_WHILE_WAITING
 150:stk500boot.c  **** 
 151:stk500boot.c  **** #ifdef _MEGA_BOARD_
 152:stk500boot.c  **** 	#define PROGLED_PORT	PORTB
 153:stk500boot.c  **** 	#define PROGLED_DDR		DDRB
 154:stk500boot.c  **** 	#define PROGLED_PIN		PINB7
 155:stk500boot.c  **** #elif defined( _BOARD_AMBER128_ )
 156:stk500boot.c  **** 	//*	this is for the amber 128 http://www.soc-robotics.com/
 157:stk500boot.c  **** 	//*	onbarod led is PORTE4
 158:stk500boot.c  **** 	#define PROGLED_PORT	PORTD
 159:stk500boot.c  **** 	#define PROGLED_DDR		DDRD
 160:stk500boot.c  **** 	#define PROGLED_PIN		PINE7
 161:stk500boot.c  **** #elif defined( _CEREBOTPLUS_BOARD_ ) || defined(_CEREBOT_II_BOARD_)
 162:stk500boot.c  **** 	//*	this is for the Cerebot 2560 board and the Cerebot-ii
 163:stk500boot.c  **** 	//*	onbarod leds are on PORTE4-7
 164:stk500boot.c  **** 	#define PROGLED_PORT	PORTE
 165:stk500boot.c  **** 	#define PROGLED_DDR		DDRE
 166:stk500boot.c  **** 	#define PROGLED_PIN		PINE7
 167:stk500boot.c  **** #elif defined( _PENGUINO_ )
 168:stk500boot.c  **** 	//*	this is for the Penguino
 169:stk500boot.c  **** 	//*	onbarod led is PORTE4
 170:stk500boot.c  **** 	#define PROGLED_PORT	PORTC
 171:stk500boot.c  **** 	#define PROGLED_DDR		DDRC
 172:stk500boot.c  **** 	#define PROGLED_PIN		PINC6
 173:stk500boot.c  **** #elif defined( _ANDROID_2561_ ) || defined( __AVR_ATmega2561__ )
 174:stk500boot.c  **** 	//*	this is for the Boston Android 2561
 175:stk500boot.c  **** 	//*	onbarod led is PORTE4
 176:stk500boot.c  **** 	#define PROGLED_PORT	PORTA
 177:stk500boot.c  **** 	#define PROGLED_DDR		DDRA
 178:stk500boot.c  **** 	#define PROGLED_PIN		PINA3
 179:stk500boot.c  **** #elif defined( _BOARD_MEGA16 )
 180:stk500boot.c  **** 	//*	onbarod led is PORTA7
 181:stk500boot.c  **** 	#define PROGLED_PORT	PORTA
 182:stk500boot.c  **** 	#define PROGLED_DDR		DDRA
 183:stk500boot.c  **** 	#define PROGLED_PIN		PINA7
 184:stk500boot.c  **** 	#define UART_BAUDRATE_DOUBLE_SPEED 0
 185:stk500boot.c  **** 
 186:stk500boot.c  **** #elif defined( _BOARD_BAHBOT_ )
 187:stk500boot.c  **** 	//*	dosent have an onboard LED but this is what will probably be added to this port
 188:stk500boot.c  **** 	#define PROGLED_PORT	PORTB
 189:stk500boot.c  **** 	#define PROGLED_DDR		DDRB
 190:stk500boot.c  **** 	#define PROGLED_PIN		PINB0
 191:stk500boot.c  **** 
 192:stk500boot.c  **** #elif defined( _BOARD_ROBOTX_ )
 193:stk500boot.c  **** 	#define PROGLED_PORT	PORTB
 194:stk500boot.c  **** 	#define PROGLED_DDR		DDRB
 195:stk500boot.c  **** 	#define PROGLED_PIN		PINB6
 196:stk500boot.c  **** #elif defined( _BOARD_CUSTOM1284_BLINK_B0_ )
 197:stk500boot.c  **** 	#define PROGLED_PORT	PORTB
 198:stk500boot.c  **** 	#define PROGLED_DDR		DDRB
 199:stk500boot.c  **** 	#define PROGLED_PIN		PINB0
 200:stk500boot.c  **** #elif defined( _BOARD_CUSTOM1284_ )
 201:stk500boot.c  **** 	#define PROGLED_PORT	PORTD
 202:stk500boot.c  **** 	#define PROGLED_DDR		DDRD
 203:stk500boot.c  **** 	#define PROGLED_PIN		PIND5
 204:stk500boot.c  **** #elif defined( _AVRLIP_ )
 205:stk500boot.c  **** 	#define PROGLED_PORT	PORTB
 206:stk500boot.c  **** 	#define PROGLED_DDR		DDRB
 207:stk500boot.c  **** 	#define PROGLED_PIN		PINB5
 208:stk500boot.c  **** #elif defined( _BOARD_STK500_ )
 209:stk500boot.c  **** 	#define PROGLED_PORT	PORTA
 210:stk500boot.c  **** 	#define PROGLED_DDR		DDRA
 211:stk500boot.c  **** 	#define PROGLED_PIN		PINA7
 212:stk500boot.c  **** #elif defined( _BOARD_STK502_ )
 213:stk500boot.c  **** 	#define PROGLED_PORT	PORTB
 214:stk500boot.c  **** 	#define PROGLED_DDR		DDRB
 215:stk500boot.c  **** 	#define PROGLED_PIN		PINB5
 216:stk500boot.c  **** #elif defined( _BOARD_STK525_ )
 217:stk500boot.c  **** 	#define PROGLED_PORT	PORTB
 218:stk500boot.c  **** 	#define PROGLED_DDR		DDRB
 219:stk500boot.c  **** 	#define PROGLED_PIN		PINB7
 220:stk500boot.c  **** #elif defined( __AVR_ATmega256RFR2__ )  || defined(__AVR_ATmega128RFA1__)
 221:stk500boot.c  **** 	#define PROGLED_PORT	PORTD
 222:stk500boot.c  **** 	#define PROGLED_DDR		DDRD
 223:stk500boot.c  **** 	#define PROGLED_PIN		PIND7
 224:stk500boot.c  **** 	#define UART_BAUDRATE_DOUBLE_SPEED 0
 225:stk500boot.c  **** #else
 226:stk500boot.c  **** 	#define PROGLED_PORT	PORTG
 227:stk500boot.c  **** 	#define PROGLED_DDR		DDRG
 228:stk500boot.c  **** 	#define PROGLED_PIN		PING2
 229:stk500boot.c  **** #endif
 230:stk500boot.c  **** 
 231:stk500boot.c  **** 
 232:stk500boot.c  **** 
 233:stk500boot.c  **** /*
 234:stk500boot.c  ****  * define CPU frequency in Mhz here if not defined in Makefile
 235:stk500boot.c  ****  */
 236:stk500boot.c  **** #ifndef F_CPU
 237:stk500boot.c  **** 	#define F_CPU 16000000UL
 238:stk500boot.c  **** #endif
 239:stk500boot.c  **** 
 240:stk500boot.c  **** #define	_BLINK_LOOP_COUNT_	(F_CPU / 2250)
 241:stk500boot.c  **** /*
 242:stk500boot.c  ****  * UART Baudrate, AVRStudio AVRISP only accepts 115200 bps
 243:stk500boot.c  ****  */
 244:stk500boot.c  **** 
 245:stk500boot.c  **** #ifndef BAUDRATE
 246:stk500boot.c  **** 	#define BAUDRATE 115200
 247:stk500boot.c  **** #endif
 248:stk500boot.c  **** 
 249:stk500boot.c  **** /*
 250:stk500boot.c  ****  *  Enable (1) or disable (0) USART double speed operation
 251:stk500boot.c  ****  */
 252:stk500boot.c  **** #ifndef UART_BAUDRATE_DOUBLE_SPEED
 253:stk500boot.c  **** 	#if defined (__AVR_ATmega32__)
 254:stk500boot.c  **** 		#define UART_BAUDRATE_DOUBLE_SPEED 0
 255:stk500boot.c  **** 	#else
 256:stk500boot.c  **** 		#define UART_BAUDRATE_DOUBLE_SPEED 1
 257:stk500boot.c  **** 	#endif
 258:stk500boot.c  **** #endif
 259:stk500boot.c  **** 
 260:stk500boot.c  **** /*
 261:stk500boot.c  ****  * HW and SW version, reported to AVRISP, must match version of AVRStudio
 262:stk500boot.c  ****  */
 263:stk500boot.c  **** #define CONFIG_PARAM_BUILD_NUMBER_LOW	0
 264:stk500boot.c  **** #define CONFIG_PARAM_BUILD_NUMBER_HIGH	0
 265:stk500boot.c  **** #define CONFIG_PARAM_HW_VER				0x0F
 266:stk500boot.c  **** #define CONFIG_PARAM_SW_MAJOR			2
 267:stk500boot.c  **** #define CONFIG_PARAM_SW_MINOR			0x0A
 268:stk500boot.c  **** 
 269:stk500boot.c  **** /*
 270:stk500boot.c  ****  * Calculate the address where the bootloader starts from FLASHEND and BOOTSIZE
 271:stk500boot.c  ****  * (adjust BOOTSIZE below and BOOTLOADER_ADDRESS in Makefile if you want to change the size of the 
 272:stk500boot.c  ****  */
 273:stk500boot.c  **** //#define BOOTSIZE 1024
 274:stk500boot.c  **** #if FLASHEND > 0x0F000
 275:stk500boot.c  **** 	#define BOOTSIZE 8192
 276:stk500boot.c  **** #else
 277:stk500boot.c  **** 	#define BOOTSIZE 2048
 278:stk500boot.c  **** #endif
 279:stk500boot.c  **** 
 280:stk500boot.c  **** #define APP_END  (FLASHEND -(2*BOOTSIZE) + 1)
 281:stk500boot.c  **** 
 282:stk500boot.c  **** /*
 283:stk500boot.c  ****  * Signature bytes are not available in avr-gcc io_xxx.h
 284:stk500boot.c  ****  */
 285:stk500boot.c  **** #if defined (__AVR_ATmega8__)
 286:stk500boot.c  **** 	#define SIGNATURE_BYTES 0x1E9307
 287:stk500boot.c  **** #elif defined (__AVR_ATmega16__)
 288:stk500boot.c  **** 	#define SIGNATURE_BYTES 0x1E9403
 289:stk500boot.c  **** #elif defined (__AVR_ATmega32__)
 290:stk500boot.c  **** 	#define SIGNATURE_BYTES 0x1E9502
 291:stk500boot.c  **** #elif defined (__AVR_ATmega8515__)
 292:stk500boot.c  **** 	#define SIGNATURE_BYTES 0x1E9306
 293:stk500boot.c  **** #elif defined (__AVR_ATmega8535__)
 294:stk500boot.c  **** 	#define SIGNATURE_BYTES 0x1E9308
 295:stk500boot.c  **** #elif defined (__AVR_ATmega162__)
 296:stk500boot.c  **** 	#define SIGNATURE_BYTES 0x1E9404
 297:stk500boot.c  **** #elif defined (__AVR_ATmega128__)
 298:stk500boot.c  **** 	#define SIGNATURE_BYTES 0x1E9702
 299:stk500boot.c  **** #elif defined (__AVR_ATmega1280__)
 300:stk500boot.c  **** 	#define SIGNATURE_BYTES 0x1E9703
 301:stk500boot.c  **** #elif defined (__AVR_ATmega2560__)
 302:stk500boot.c  **** 	#define SIGNATURE_BYTES 0x1E9801
 303:stk500boot.c  **** #elif defined (__AVR_ATmega2561__)
 304:stk500boot.c  **** 	#define SIGNATURE_BYTES 0x1e9802
 305:stk500boot.c  **** #elif defined (__AVR_ATmega1284P__)
 306:stk500boot.c  **** 	#define SIGNATURE_BYTES 0x1e9705
 307:stk500boot.c  **** #elif defined (__AVR_ATmega640__)
 308:stk500boot.c  **** 	#define SIGNATURE_BYTES  0x1e9608
 309:stk500boot.c  **** #elif defined (__AVR_ATmega64__)
 310:stk500boot.c  **** 	#define SIGNATURE_BYTES  0x1E9602
 311:stk500boot.c  **** #elif defined (__AVR_ATmega169__)
 312:stk500boot.c  **** 	#define SIGNATURE_BYTES  0x1e9405
 313:stk500boot.c  **** #elif defined (__AVR_AT90USB1287__)
 314:stk500boot.c  **** 	#define SIGNATURE_BYTES  0x1e9782
 315:stk500boot.c  **** #elif defined (__AVR_ATmega256RFR2__)
 316:stk500boot.c  **** 	#define SIGNATURE_BYTES  0x1eA802
 317:stk500boot.c  **** #elif defined (__AVR_ATmega128RFA1__)
 318:stk500boot.c  **** 	#define SIGNATURE_BYTES  0x1eA701
 319:stk500boot.c  **** 
 320:stk500boot.c  **** #else
 321:stk500boot.c  **** 	#error "no signature definition for MCU available"
 322:stk500boot.c  **** #endif
 323:stk500boot.c  **** 
 324:stk500boot.c  **** 
 325:stk500boot.c  **** #if defined(_BOARD_ROBOTX_) || defined(__AVR_AT90USB1287__) || defined(__AVR_AT90USB1286__)
 326:stk500boot.c  **** 	#define	UART_BAUD_RATE_LOW			UBRR1L
 327:stk500boot.c  **** 	#define	UART_STATUS_REG				UCSR1A
 328:stk500boot.c  **** 	#define	UART_CONTROL_REG			UCSR1B
 329:stk500boot.c  **** 	#define	UART_ENABLE_TRANSMITTER		TXEN1
 330:stk500boot.c  **** 	#define	UART_ENABLE_RECEIVER		RXEN1
 331:stk500boot.c  **** 	#define	UART_TRANSMIT_COMPLETE		TXC1
 332:stk500boot.c  **** 	#define	UART_RECEIVE_COMPLETE		RXC1
 333:stk500boot.c  **** 	#define	UART_DATA_REG				UDR1
 334:stk500boot.c  **** 	#define	UART_DOUBLE_SPEED			U2X1
 335:stk500boot.c  **** 
 336:stk500boot.c  **** #elif defined(__AVR_ATmega8__) || defined(__AVR_ATmega16__) || defined(__AVR_ATmega32__) \
 337:stk500boot.c  **** 	|| defined(__AVR_ATmega8515__) || defined(__AVR_ATmega8535__)
 338:stk500boot.c  **** 	/* ATMega8 with one USART */
 339:stk500boot.c  **** 	#define	UART_BAUD_RATE_LOW			UBRRL
 340:stk500boot.c  **** 	#define	UART_STATUS_REG				UCSRA
 341:stk500boot.c  **** 	#define	UART_CONTROL_REG			UCSRB
 342:stk500boot.c  **** 	#define	UART_ENABLE_TRANSMITTER		TXEN
 343:stk500boot.c  **** 	#define	UART_ENABLE_RECEIVER		RXEN
 344:stk500boot.c  **** 	#define	UART_TRANSMIT_COMPLETE		TXC
 345:stk500boot.c  **** 	#define	UART_RECEIVE_COMPLETE		RXC
 346:stk500boot.c  **** 	#define	UART_DATA_REG				UDR
 347:stk500boot.c  **** 	#define	UART_DOUBLE_SPEED			U2X
 348:stk500boot.c  **** 
 349:stk500boot.c  **** #elif defined(__AVR_ATmega64__) || defined(__AVR_ATmega128__) || defined(__AVR_ATmega162__) \
 350:stk500boot.c  **** 	 || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__) || d
 351:stk500boot.c  **** 	/* ATMega with two USART, use UART0 */
 352:stk500boot.c  **** 	#define	UART_BAUD_RATE_LOW			UBRR0L
 353:stk500boot.c  **** 	#define	UART_STATUS_REG				UCSR0A
 354:stk500boot.c  **** 	#define	UART_CONTROL_REG			UCSR0B
 355:stk500boot.c  **** 	#define	UART_ENABLE_TRANSMITTER		TXEN0
 356:stk500boot.c  **** 	#define	UART_ENABLE_RECEIVER		RXEN0
 357:stk500boot.c  **** 	#define	UART_TRANSMIT_COMPLETE		TXC0
 358:stk500boot.c  **** 	#define	UART_RECEIVE_COMPLETE		RXC0
 359:stk500boot.c  **** 	#define	UART_DATA_REG				UDR0
 360:stk500boot.c  **** 	#define	UART_DOUBLE_SPEED			U2X0
 361:stk500boot.c  **** #elif defined(UBRR0L) && defined(UCSR0A) && defined(TXEN0)
 362:stk500boot.c  **** 	/* ATMega with two USART, use UART0 */
 363:stk500boot.c  **** 	#define	UART_BAUD_RATE_LOW			UBRR0L
 364:stk500boot.c  **** 	#define	UART_STATUS_REG				UCSR0A
 365:stk500boot.c  **** 	#define	UART_CONTROL_REG			UCSR0B
 366:stk500boot.c  **** 	#define	UART_ENABLE_TRANSMITTER		TXEN0
 367:stk500boot.c  **** 	#define	UART_ENABLE_RECEIVER		RXEN0
 368:stk500boot.c  **** 	#define	UART_TRANSMIT_COMPLETE		TXC0
 369:stk500boot.c  **** 	#define	UART_RECEIVE_COMPLETE		RXC0
 370:stk500boot.c  **** 	#define	UART_DATA_REG				UDR0
 371:stk500boot.c  **** 	#define	UART_DOUBLE_SPEED			U2X0
 372:stk500boot.c  **** #elif defined(UBRRL) && defined(UCSRA) && defined(UCSRB) && defined(TXEN) && defined(RXEN)
 373:stk500boot.c  **** 	//* catch all
 374:stk500boot.c  **** 	#define	UART_BAUD_RATE_LOW			UBRRL
 375:stk500boot.c  **** 	#define	UART_STATUS_REG				UCSRA
 376:stk500boot.c  **** 	#define	UART_CONTROL_REG			UCSRB
 377:stk500boot.c  **** 	#define	UART_ENABLE_TRANSMITTER		TXEN
 378:stk500boot.c  **** 	#define	UART_ENABLE_RECEIVER		RXEN
 379:stk500boot.c  **** 	#define	UART_TRANSMIT_COMPLETE		TXC
 380:stk500boot.c  **** 	#define	UART_RECEIVE_COMPLETE		RXC
 381:stk500boot.c  **** 	#define	UART_DATA_REG				UDR
 382:stk500boot.c  **** 	#define	UART_DOUBLE_SPEED			U2X
 383:stk500boot.c  **** #else
 384:stk500boot.c  **** 	#error "no UART definition for MCU available"
 385:stk500boot.c  **** #endif
 386:stk500boot.c  **** 
 387:stk500boot.c  **** 
 388:stk500boot.c  **** 
 389:stk500boot.c  **** /*
 390:stk500boot.c  ****  * Macro to calculate UBBR from XTAL and baudrate
 391:stk500boot.c  ****  */
 392:stk500boot.c  **** #if defined(__AVR_ATmega32__) && UART_BAUDRATE_DOUBLE_SPEED
 393:stk500boot.c  **** 	#define UART_BAUD_SELECT(baudRate,xtalCpu) ((xtalCpu / 4 / baudRate - 1) / 2)
 394:stk500boot.c  **** #elif defined(__AVR_ATmega32__)
 395:stk500boot.c  **** 	#define UART_BAUD_SELECT(baudRate,xtalCpu) ((xtalCpu / 8 / baudRate - 1) / 2)
 396:stk500boot.c  **** #elif UART_BAUDRATE_DOUBLE_SPEED
 397:stk500boot.c  **** 	#define UART_BAUD_SELECT(baudRate,xtalCpu) (((float)(xtalCpu))/(((float)(baudRate))*8.0)-1.0+0.5)
 398:stk500boot.c  **** #else
 399:stk500boot.c  **** 	#define UART_BAUD_SELECT(baudRate,xtalCpu) (((float)(xtalCpu))/(((float)(baudRate))*16.0)-1.0+0.5)
 400:stk500boot.c  **** #endif
 401:stk500boot.c  **** 
 402:stk500boot.c  **** 
 403:stk500boot.c  **** /*
 404:stk500boot.c  ****  * States used in the receive state machine
 405:stk500boot.c  ****  */
 406:stk500boot.c  **** #define	ST_START		0
 407:stk500boot.c  **** #define	ST_GET_SEQ_NUM	1
 408:stk500boot.c  **** #define ST_MSG_SIZE_1	2
 409:stk500boot.c  **** #define ST_MSG_SIZE_2	3
 410:stk500boot.c  **** #define ST_GET_TOKEN	4
 411:stk500boot.c  **** #define ST_GET_DATA		5
 412:stk500boot.c  **** #define	ST_GET_CHECK	6
 413:stk500boot.c  **** #define	ST_PROCESS		7
 414:stk500boot.c  **** 
 415:stk500boot.c  **** /*
 416:stk500boot.c  ****  * use 16bit address variable for ATmegas with <= 64K flash
 417:stk500boot.c  ****  */
 418:stk500boot.c  **** #if defined(RAMPZ)
 419:stk500boot.c  **** 	typedef uint32_t address_t;
 420:stk500boot.c  **** #else
 421:stk500boot.c  **** 	typedef uint16_t address_t;
 422:stk500boot.c  **** #endif
 423:stk500boot.c  **** 
 424:stk500boot.c  **** /*
 425:stk500boot.c  ****  * function prototypes
 426:stk500boot.c  ****  */
 427:stk500boot.c  **** static void sendchar(char c);
 428:stk500boot.c  **** static unsigned char recchar(void);
 429:stk500boot.c  **** 
 430:stk500boot.c  **** /*
 431:stk500boot.c  ****  * since this bootloader is not linked against the avr-gcc crt1 functions,
 432:stk500boot.c  ****  * to reduce the code size, we need to provide our own initialization
 433:stk500boot.c  ****  */
 434:stk500boot.c  **** void __jumpMain	(void) __attribute__ ((naked)) __attribute__ ((section (".init9")));
 435:stk500boot.c  **** #include <avr/sfr_defs.h>
 436:stk500boot.c  **** 
 437:stk500boot.c  **** //#define	SPH_REG	0x3E
 438:stk500boot.c  **** //#define	SPL_REG	0x3D
 439:stk500boot.c  **** 
 440:stk500boot.c  **** //*****************************************************************************
 441:stk500boot.c  **** void __jumpMain(void)
 442:stk500boot.c  **** {
 443:stk500boot.c  **** //*	July 17, 2010	<MLS> Added stack pointer initialzation
 444:stk500boot.c  **** //*	the first line did not do the job on the ATmega128
 445:stk500boot.c  **** 
 446:stk500boot.c  **** 	asm volatile ( ".set __stack, %0" :: "i" (RAMEND) );
 447:stk500boot.c  **** 
 448:stk500boot.c  **** //*	set stack pointer to top of RAM
 449:stk500boot.c  **** 
 450:stk500boot.c  **** 	asm volatile ( "ldi	16, %0" :: "i" (RAMEND >> 8) );
 451:stk500boot.c  **** 	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_HI_ADDR) );
 452:stk500boot.c  **** 
 453:stk500boot.c  **** 	asm volatile ( "ldi	16, %0" :: "i" (RAMEND & 0x0ff) );
 454:stk500boot.c  **** 	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_LO_ADDR) );
 455:stk500boot.c  **** 
 456:stk500boot.c  **** 	asm volatile ( "clr __zero_reg__" );									// GCC depends on register r1 set to 0
 457:stk500boot.c  **** 	asm volatile ( "out %0, __zero_reg__" :: "I" (_SFR_IO_ADDR(SREG)) );	// set SREG to 0
 458:stk500boot.c  **** 	asm volatile ( "jmp main");												// jump to main()
 459:stk500boot.c  **** }
 460:stk500boot.c  **** 
 461:stk500boot.c  **** 
 462:stk500boot.c  **** //*****************************************************************************
 463:stk500boot.c  **** void delay_ms(unsigned int timedelay)
 464:stk500boot.c  **** {
 465:stk500boot.c  **** 	unsigned int i;
 466:stk500boot.c  **** 	for (i=0;i<timedelay;i++)
 467:stk500boot.c  **** 	{
 468:stk500boot.c  **** 		_delay_ms(0.5);
 469:stk500boot.c  **** 	}
 470:stk500boot.c  **** }
 471:stk500boot.c  **** 
 472:stk500boot.c  **** 
 473:stk500boot.c  **** //*****************************************************************************
 474:stk500boot.c  **** /*
 475:stk500boot.c  ****  * send single byte to USART, wait until transmission is completed
 476:stk500boot.c  ****  */
 477:stk500boot.c  **** static void sendchar(char c)
 478:stk500boot.c  **** {
  17               		.loc 1 478 0
  18               		.cfi_startproc
  19               	.LVL0:
  20               	/* prologue: function */
  21               	/* frame size = 0 */
  22               	/* stack size = 0 */
  23               	.L__stack_usage = 0
 479:stk500boot.c  **** 	UART_DATA_REG	=	c;										// prepare transmission
  24               		.loc 1 479 0
  25 0000 8093 C600 		sts 198,r24
  26               	.LVL1:
  27               	.L2:
 480:stk500boot.c  **** 	while (!(UART_STATUS_REG & (1 << UART_TRANSMIT_COMPLETE)));	// wait until byte sent
  28               		.loc 1 480 0 discriminator 1
  29 0004 8091 C000 		lds r24,192
  30 0008 86FF      		sbrs r24,6
  31 000a 00C0      		rjmp .L2
 481:stk500boot.c  **** 	UART_STATUS_REG |= (1 << UART_TRANSMIT_COMPLETE);			// delete TXCflag
  32               		.loc 1 481 0
  33 000c 8091 C000 		lds r24,192
  34 0010 8064      		ori r24,lo8(64)
  35 0012 8093 C000 		sts 192,r24
  36               	/* epilogue start */
 482:stk500boot.c  **** }
  37               		.loc 1 482 0
  38 0016 0895      		ret
  39               		.cfi_endproc
  40               	.LFE9:
  42               		.section	.text.unlikely,"ax",@progbits
  44               	recchar:
  45               	.LFB11:
 483:stk500boot.c  **** 
 484:stk500boot.c  **** 
 485:stk500boot.c  **** //************************************************************************
 486:stk500boot.c  **** static int	Serial_Available(void)
 487:stk500boot.c  **** {
 488:stk500boot.c  **** 	return(UART_STATUS_REG & (1 << UART_RECEIVE_COMPLETE));	// wait for data
 489:stk500boot.c  **** }
 490:stk500boot.c  **** 
 491:stk500boot.c  **** 
 492:stk500boot.c  **** //*****************************************************************************
 493:stk500boot.c  **** /*
 494:stk500boot.c  ****  * Read single byte from USART, block if no data available
 495:stk500boot.c  ****  */
 496:stk500boot.c  **** static unsigned char recchar(void)
 497:stk500boot.c  **** {
  46               		.loc 1 497 0
  47               		.cfi_startproc
  48               	/* prologue: function */
  49               	/* frame size = 0 */
  50               	/* stack size = 0 */
  51               	.L__stack_usage = 0
  52               	.L5:
 498:stk500boot.c  **** 	while (!(UART_STATUS_REG & (1 << UART_RECEIVE_COMPLETE)))
  53               		.loc 1 498 0 discriminator 1
  54 0000 8091 C000 		lds r24,192
  55 0004 87FF      		sbrs r24,7
  56 0006 00C0      		rjmp .L5
 499:stk500boot.c  **** 	{
 500:stk500boot.c  **** 		// wait for data
 501:stk500boot.c  **** 	}
 502:stk500boot.c  **** 	return UART_DATA_REG;
  57               		.loc 1 502 0
  58 0008 8091 C600 		lds r24,198
  59               	/* epilogue start */
 503:stk500boot.c  **** }
  60               		.loc 1 503 0
  61 000c 0895      		ret
  62               		.cfi_endproc
  63               	.LFE11:
  65               		.section	.init9,"ax",@progbits
  66               	.global	__jumpMain
  68               	__jumpMain:
  69               	.LFB7:
 442:stk500boot.c  **** {
  70               		.loc 1 442 0
  71               		.cfi_startproc
  72               	/* prologue: naked */
  73               	/* frame size = 0 */
  74               	/* stack size = 0 */
  75               	.L__stack_usage = 0
 446:stk500boot.c  **** 	asm volatile ( ".set __stack, %0" :: "i" (RAMEND) );
  76               		.loc 1 446 0
  77               	/* #APP */
  78               	 ;  446 "stk500boot.c" 1
  79               		.set __stack, -32257
  80               	 ;  0 "" 2
 450:stk500boot.c  **** 	asm volatile ( "ldi	16, %0" :: "i" (RAMEND >> 8) );
  81               		.loc 1 450 0
  82               	 ;  450 "stk500boot.c" 1
  83 0000 01E8      		ldi	16, 129
  84               	 ;  0 "" 2
 451:stk500boot.c  **** 	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_HI_ADDR) );
  85               		.loc 1 451 0
  86               	 ;  451 "stk500boot.c" 1
  87 0002 0EBF      		out 62,16
  88               	 ;  0 "" 2
 453:stk500boot.c  **** 	asm volatile ( "ldi	16, %0" :: "i" (RAMEND & 0x0ff) );
  89               		.loc 1 453 0
  90               	 ;  453 "stk500boot.c" 1
  91 0004 0FEF      		ldi	16, 255
  92               	 ;  0 "" 2
 454:stk500boot.c  **** 	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_LO_ADDR) );
  93               		.loc 1 454 0
  94               	 ;  454 "stk500boot.c" 1
  95 0006 0DBF      		out 61,16
  96               	 ;  0 "" 2
 456:stk500boot.c  **** 	asm volatile ( "clr __zero_reg__" );									// GCC depends on register r1 set to 0
  97               		.loc 1 456 0
  98               	 ;  456 "stk500boot.c" 1
  99 0008 1124      		clr __zero_reg__
 100               	 ;  0 "" 2
 457:stk500boot.c  **** 	asm volatile ( "out %0, __zero_reg__" :: "I" (_SFR_IO_ADDR(SREG)) );	// set SREG to 0
 101               		.loc 1 457 0
 102               	 ;  457 "stk500boot.c" 1
 103 000a 1FBE      		out 63, __zero_reg__
 104               	 ;  0 "" 2
 458:stk500boot.c  **** 	asm volatile ( "jmp main");												// jump to main()
 105               		.loc 1 458 0
 106               	 ;  458 "stk500boot.c" 1
 107 000c 0C94 0000 		jmp main
 108               	 ;  0 "" 2
 109               	/* epilogue start */
 459:stk500boot.c  **** }
 110               		.loc 1 459 0
 111               	/* #NOAPP */
 112               		.cfi_endproc
 113               	.LFE7:
 115               		.text
 116               	.global	delay_ms
 118               	delay_ms:
 119               	.LFB8:
 464:stk500boot.c  **** {
 120               		.loc 1 464 0
 121               		.cfi_startproc
 122               	.LVL2:
 123               	/* prologue: function */
 124               	/* frame size = 0 */
 125               	/* stack size = 0 */
 126               	.L__stack_usage = 0
 466:stk500boot.c  **** 	for (i=0;i<timedelay;i++)
 127               		.loc 1 466 0
 128 0018 20E0      		ldi r18,lo8(0)
 129 001a 30E0      		ldi r19,hi8(0)
 130 001c 00C0      		rjmp .L9
 131               	.LVL3:
 132               	.L10:
 133               	.LBB55:
 134               	.LBB56:
 135               		.file 2 "c:\\winavr-20100110\\bin\\../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h"
   1:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h ****    All rights reserved.
   5:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h **** 
   6:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h ****    Redistribution and use in source and binary forms, with or without
   7:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h ****    modification, are permitted provided that the following conditions are met:
   8:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h **** 
   9:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h ****    * Redistributions of source code must retain the above copyright
  10:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h ****      notice, this list of conditions and the following disclaimer.
  11:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h **** 
  12:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h ****      notice, this list of conditions and the following disclaimer in
  14:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h ****      the documentation and/or other materials provided with the
  15:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h ****      distribution.
  16:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h **** 
  17:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h ****    * Neither the name of the copyright holders nor the names of
  18:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h ****      contributors may be used to endorse or promote products derived
  19:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h ****      from this software without specific prior written permission.
  20:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h **** 
  21:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h **** 
  33:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h **** /* $Id: delay.h.in 2251 2011-09-14 08:20:33Z joerg_wunsch $ */
  34:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h **** 
  35:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h **** #ifndef _UTIL_DELAY_H_
  36:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h **** #define _UTIL_DELAY_H_ 1
  37:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h **** 
  38:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h **** #ifndef __HAS_DELAY_CYCLES
  39:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h **** #define __HAS_DELAY_CYCLES 1
  40:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h **** #endif
  41:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h **** 
  42:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h **** #include <inttypes.h>
  43:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h **** #include <util/delay_basic.h>
  44:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h **** #include <math.h>
  45:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h **** 
  46:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h **** /** \file */
  47:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  48:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h ****     \code
  49:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  50:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h ****     //#define F_CPU 14.7456E6
  51:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h ****     #include <util/delay.h>
  52:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h ****     \endcode
  53:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h **** 
  54:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h ****     \note As an alternative method, it is possible to pass the
  55:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h ****     F_CPU macro down to the compiler from the Makefile.
  56:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h ****     Obviously, in that case, no \c \#define statement should be
  57:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h ****     used.
  58:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h **** 
  59:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h ****     The functions in this header file are wrappers around the basic
  60:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  61:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h ****     convenience functions where actual time values can be specified
  62:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  63:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h ****     that compile-time constant expressions will be eliminated by
  64:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h ****     compiler optimization so floating-point expressions can be used
  65:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h ****     to calculate the number of delay cycles needed based on the CPU
  66:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h ****     frequency passed by the macro F_CPU.
  67:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h **** 
  68:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h ****     \note In order for these functions to work as intended, compiler
  69:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  70:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h ****     <em>must</em> be an expression that is a known constant at
  71:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h ****     compile-time.  If these requirements are not met, the resulting
  72:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h ****     delay will be much longer (and basically unpredictable), and
  73:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h ****     applications that otherwise do not use floating-point calculations
  74:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h ****     will experience severe code bloat by the floating-point library
  75:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h ****     routines linked into the application.
  76:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h **** 
  77:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h ****     The functions available allow the specification of microsecond, and
  78:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h ****     millisecond delays directly, using the application-supplied macro
  79:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  80:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h **** 
  81:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h **** */
  82:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h **** 
  83:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h **** #if !defined(__DOXYGEN__)
  84:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  85:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  86:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h **** #endif
  87:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h **** 
  88:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h **** #ifndef F_CPU
  89:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h **** /* prevent compiler error by supplying a default */
  90:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  91:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h **** # define F_CPU 1000000UL
  92:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h **** #endif
  93:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h **** 
  94:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h **** #ifndef __OPTIMIZE__
  95:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  96:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h **** #endif
  97:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h **** 
  98:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
  99:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 100:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h ****   __STDC_HOSTED__
 101:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h **** #  include <math.h>
 102:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h **** #endif
 103:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h **** 
 104:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h **** /**
 105:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h ****    \ingroup util_delay
 106:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h **** 
 107:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 108:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h **** 
 109:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h ****    The macro F_CPU is supposed to be defined to a
 110:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h ****    constant defining the CPU clock frequency (in Hertz).
 111:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h **** 
 112:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 113:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h **** 
 114:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h ****    When the user request delay which exceed the maximum possible one,
 115:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 116:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 117:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 118:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h ****    user will not be informed about decreased resolution.
 119:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h **** 
 120:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 121:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 122:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h ****    values greater than the maximal possible delay, overflows results in
 123:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h ****    no delay i.e., 0ms.
 124:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h **** 
 125:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 126:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 127:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h ****    the user gets atleast __us microseconds of delay.
 128:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h **** 
 129:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 130:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h ****    to round down and round to closest integer.
 131:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h **** 
 132:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h ****    Note: The new implementation of _delay_ms(double __ms) with 
 133:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible. 
 134:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 135:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h ****    Also, the backward compatible
 136:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 137:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 138:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h ****    required for rounding are not available to the compiler then.
 139:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h **** 
 140:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h ****  */
 141:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h **** void
 142:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h **** _delay_ms(double __ms)
 143:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h **** {
 144:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h **** 	uint16_t __ticks;
 145:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h **** 	double __tmp ; 
 146:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 147:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 148:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h ****   __STDC_HOSTED__
 149:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h **** 	uint32_t __ticks_dc;
 150:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 151:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 152:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h **** 
 153:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 154:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 155:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h **** 
 156:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 157:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 158:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h **** 
 159:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h **** 	#else
 160:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h **** 		//round up by default
 161:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 162:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h **** 	#endif
 163:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h **** 
 164:c:\winavr-20100110\bin\../lib/gcc/avr/4.6.2/../../../../avr/include/util\delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 136               		.loc 2 164 0
 137 001e EFEC      		 ldi r30,lo8(1999)
 138 0020 F7E0      	    ldi r31,hi8(1999)
 139 0022 3197      	    1:sbiw r30,1
 140 0024 01F4      	    brne 1b
 141 0026 00C0      		rjmp .
 142 0028 0000      		nop
 143               	.LBE56:
 144               	.LBE55:
 466:stk500boot.c  **** 	for (i=0;i<timedelay;i++)
 145               		.loc 1 466 0
 146 002a 2F5F      		subi r18,lo8(-(1))
 147 002c 3F4F      		sbci r19,hi8(-(1))
 148               	.LVL4:
 149               	.L9:
 466:stk500boot.c  **** 	for (i=0;i<timedelay;i++)
 150               		.loc 1 466 0 is_stmt 0 discriminator 1
 151 002e 2817      		cp r18,r24
 152 0030 3907      		cpc r19,r25
 153 0032 01F4      		brne .L10
 154               	/* epilogue start */
 470:stk500boot.c  **** }
 155               		.loc 1 470 0 is_stmt 1
 156 0034 0895      		ret
 157               		.cfi_endproc
 158               	.LFE8:
 160               	.global	PrintFromPROGMEM
 162               	PrintFromPROGMEM:
 163               	.LFB14:
 504:stk500boot.c  **** 
 505:stk500boot.c  **** #define	MAX_TIME_COUNT	(F_CPU >> 1)
 506:stk500boot.c  **** //*****************************************************************************
 507:stk500boot.c  **** static unsigned char recchar_timeout(void)
 508:stk500boot.c  **** {
 509:stk500boot.c  **** uint32_t count = 0;
 510:stk500boot.c  **** 
 511:stk500boot.c  **** 	while (!(UART_STATUS_REG & (1 << UART_RECEIVE_COMPLETE)))
 512:stk500boot.c  **** 	{
 513:stk500boot.c  **** 		// wait for data
 514:stk500boot.c  **** 		count++;
 515:stk500boot.c  **** 		if (count > MAX_TIME_COUNT)
 516:stk500boot.c  **** 		{
 517:stk500boot.c  **** 		unsigned int	data;
 518:stk500boot.c  **** 		#if (FLASHEND > 0x10000)
 519:stk500boot.c  **** 			data	=	pgm_read_word_far(0);	//*	get the first word of the user program
 520:stk500boot.c  **** 		#else
 521:stk500boot.c  **** 			data	=	pgm_read_word_near(0);	//*	get the first word of the user program
 522:stk500boot.c  **** 		#endif
 523:stk500boot.c  **** 			if (data != 0xffff)					//*	make sure its valid before jumping to it.
 524:stk500boot.c  **** 			{
 525:stk500boot.c  **** 				asm volatile(
 526:stk500boot.c  **** 						"clr	r30		\n\t"
 527:stk500boot.c  **** 						"clr	r31		\n\t"
 528:stk500boot.c  **** 						"ijmp	\n\t"
 529:stk500boot.c  **** 						);
 530:stk500boot.c  **** 			}
 531:stk500boot.c  **** 			count	=	0;
 532:stk500boot.c  **** 		}
 533:stk500boot.c  **** 	}
 534:stk500boot.c  **** 	return UART_DATA_REG;
 535:stk500boot.c  **** }
 536:stk500boot.c  **** 
 537:stk500boot.c  **** //*	for watch dog timer startup
 538:stk500boot.c  **** void (*app_start)(void) = 0x0000;
 539:stk500boot.c  **** 
 540:stk500boot.c  **** 
 541:stk500boot.c  **** //*****************************************************************************
 542:stk500boot.c  **** int main(void)
 543:stk500boot.c  **** {
 544:stk500boot.c  **** 	address_t		address			=	0;
 545:stk500boot.c  **** 	address_t		eraseAddress	=	0;
 546:stk500boot.c  **** 	unsigned char	msgParseState;
 547:stk500boot.c  **** 	unsigned int	ii				=	0;
 548:stk500boot.c  **** 	unsigned char	checksum		=	0;
 549:stk500boot.c  **** 	unsigned char	seqNum			=	0;
 550:stk500boot.c  **** 	unsigned int	msgLength		=	0;
 551:stk500boot.c  **** 	unsigned char	msgBuffer[285];
 552:stk500boot.c  **** 	unsigned char	c, *p;
 553:stk500boot.c  **** 	unsigned char   isLeave = 0;
 554:stk500boot.c  **** 
 555:stk500boot.c  **** 	unsigned long	boot_timeout;
 556:stk500boot.c  **** 	unsigned long	boot_timer;
 557:stk500boot.c  **** 	unsigned int	boot_state;
 558:stk500boot.c  **** #ifdef ENABLE_MONITOR
 559:stk500boot.c  **** 	unsigned int	exPointCntr		=	0;
 560:stk500boot.c  **** 	unsigned int	rcvdCharCntr	=	0;
 561:stk500boot.c  **** #endif
 562:stk500boot.c  **** 
 563:stk500boot.c  **** 	//*	some chips dont set the stack properly
 564:stk500boot.c  **** 	asm volatile ( ".set __stack, %0" :: "i" (RAMEND) );
 565:stk500boot.c  **** 	asm volatile ( "ldi	16, %0" :: "i" (RAMEND >> 8) );
 566:stk500boot.c  **** 	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_HI_ADDR) );
 567:stk500boot.c  **** 	asm volatile ( "ldi	16, %0" :: "i" (RAMEND & 0x0ff) );
 568:stk500boot.c  **** 	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_LO_ADDR) );
 569:stk500boot.c  **** 
 570:stk500boot.c  **** #ifdef _FIX_ISSUE_181_
 571:stk500boot.c  **** 	//************************************************************************
 572:stk500boot.c  **** 	//*	Dec 29,	2011	<MLS> Issue #181, added watch dog timmer support
 573:stk500boot.c  **** 	//*	handle the watch dog timer
 574:stk500boot.c  **** 	uint8_t	mcuStatusReg;
 575:stk500boot.c  **** 	mcuStatusReg	=	MCUSR;
 576:stk500boot.c  **** 
 577:stk500boot.c  **** 	__asm__ __volatile__ ("cli");
 578:stk500boot.c  **** 	__asm__ __volatile__ ("wdr");
 579:stk500boot.c  **** 	MCUSR	=	0;
 580:stk500boot.c  **** 	WDTCSR	|=	_BV(WDCE) | _BV(WDE);
 581:stk500boot.c  **** 	WDTCSR	=	0;
 582:stk500boot.c  **** 	__asm__ __volatile__ ("sei");
 583:stk500boot.c  **** 	// check if WDT generated the reset, if so, go straight to app
 584:stk500boot.c  **** 	if (mcuStatusReg & _BV(WDRF))
 585:stk500boot.c  **** 	{
 586:stk500boot.c  **** 		app_start();
 587:stk500boot.c  **** 	}
 588:stk500boot.c  **** 	//************************************************************************
 589:stk500boot.c  **** #endif
 590:stk500boot.c  **** 
 591:stk500boot.c  **** 
 592:stk500boot.c  **** 	boot_timer	=	0;
 593:stk500boot.c  **** 	boot_state	=	0;
 594:stk500boot.c  **** 
 595:stk500boot.c  **** #ifdef BLINK_LED_WHILE_WAITING
 596:stk500boot.c  **** //	boot_timeout	=	 90000;		//*	should be about 4 seconds
 597:stk500boot.c  **** //	boot_timeout	=	170000;
 598:stk500boot.c  **** 	boot_timeout	=	 20000;		//*	should be about 1 second
 599:stk500boot.c  **** #else
 600:stk500boot.c  **** 	boot_timeout	=	3500000; // 7 seconds , approx 2us per step when optimize "s"
 601:stk500boot.c  **** #endif
 602:stk500boot.c  **** 	/*
 603:stk500boot.c  **** 	 * Branch to bootloader or application code ?
 604:stk500boot.c  **** 	 */
 605:stk500boot.c  **** 
 606:stk500boot.c  **** #ifndef REMOVE_BOOTLOADER_LED
 607:stk500boot.c  **** 	/* PROG_PIN pulled low, indicate with LED that bootloader is active */
 608:stk500boot.c  **** 	PROGLED_DDR		|=	(1<<PROGLED_PIN);
 609:stk500boot.c  **** //	PROGLED_PORT	&=	~(1<<PROGLED_PIN);	// active low LED ON
 610:stk500boot.c  **** 	PROGLED_PORT	|=	(1<<PROGLED_PIN);	// active high LED ON
 611:stk500boot.c  **** 
 612:stk500boot.c  **** #ifdef _DEBUG_WITH_LEDS_
 613:stk500boot.c  **** 	for (ii=0; ii<3; ii++)
 614:stk500boot.c  **** 	{
 615:stk500boot.c  **** 		PROGLED_PORT	&=	~(1<<PROGLED_PIN);	// turn LED off
 616:stk500boot.c  **** 		delay_ms(100);
 617:stk500boot.c  **** 		PROGLED_PORT	|=	(1<<PROGLED_PIN);	// turn LED on
 618:stk500boot.c  **** 		delay_ms(100);
 619:stk500boot.c  **** 	}
 620:stk500boot.c  **** #endif
 621:stk500boot.c  **** 
 622:stk500boot.c  **** #endif
 623:stk500boot.c  **** 	/*
 624:stk500boot.c  **** 	 * Init UART
 625:stk500boot.c  **** 	 * set baudrate and enable USART receiver and transmiter without interrupts
 626:stk500boot.c  **** 	 */
 627:stk500boot.c  **** #if UART_BAUDRATE_DOUBLE_SPEED
 628:stk500boot.c  **** 	UART_STATUS_REG		|=	(1 <<UART_DOUBLE_SPEED);
 629:stk500boot.c  **** #endif
 630:stk500boot.c  **** 	UART_BAUD_RATE_LOW	=	UART_BAUD_SELECT(BAUDRATE,F_CPU);
 631:stk500boot.c  **** 	UART_CONTROL_REG	=	(1 << UART_ENABLE_RECEIVER) | (1 << UART_ENABLE_TRANSMITTER);
 632:stk500boot.c  **** 
 633:stk500boot.c  **** 	asm volatile ("nop");			// wait until port has changed
 634:stk500boot.c  **** 
 635:stk500boot.c  **** #ifdef _DEBUG_SERIAL_
 636:stk500boot.c  **** //	delay_ms(500);
 637:stk500boot.c  **** 
 638:stk500boot.c  **** 	sendchar('s');
 639:stk500boot.c  **** 	sendchar('t');
 640:stk500boot.c  **** 	sendchar('k');
 641:stk500boot.c  **** //	sendchar('5');
 642:stk500boot.c  **** //	sendchar('0');
 643:stk500boot.c  **** //	sendchar('0');
 644:stk500boot.c  **** 	sendchar('v');
 645:stk500boot.c  **** 	sendchar('2');
 646:stk500boot.c  **** 	sendchar(0x0d);
 647:stk500boot.c  **** 	sendchar(0x0a);
 648:stk500boot.c  **** 
 649:stk500boot.c  **** 	delay_ms(100);
 650:stk500boot.c  **** #endif
 651:stk500boot.c  **** 
 652:stk500boot.c  **** 	while (boot_state==0)
 653:stk500boot.c  **** 	{
 654:stk500boot.c  **** 		while ((!(Serial_Available())) && (boot_state == 0))		// wait for data
 655:stk500boot.c  **** 		{
 656:stk500boot.c  **** 			_delay_ms(0.001);
 657:stk500boot.c  **** 			boot_timer++;
 658:stk500boot.c  **** 			if (boot_timer > boot_timeout)
 659:stk500boot.c  **** 			{
 660:stk500boot.c  **** 				boot_state	=	1; // (after ++ -> boot_state=2 bootloader timeout, jump to main 0x00000 )
 661:stk500boot.c  **** 			}
 662:stk500boot.c  **** 		#ifdef BLINK_LED_WHILE_WAITING
 663:stk500boot.c  **** 			if ((boot_timer % _BLINK_LOOP_COUNT_) == 0)
 664:stk500boot.c  **** 			{
 665:stk500boot.c  **** 				//*	toggle the LED
 666:stk500boot.c  **** 				PROGLED_PORT	^=	(1<<PROGLED_PIN);	// turn LED ON
 667:stk500boot.c  **** 			}
 668:stk500boot.c  **** 		#endif
 669:stk500boot.c  **** 		}
 670:stk500boot.c  **** 		boot_state++; // ( if boot_state=1 bootloader received byte from UART, enter bootloader mode)
 671:stk500boot.c  **** 	}
 672:stk500boot.c  **** 
 673:stk500boot.c  **** 
 674:stk500boot.c  **** 	if (boot_state==1)
 675:stk500boot.c  **** 	{
 676:stk500boot.c  **** 		//*	main loop
 677:stk500boot.c  **** 		while (!isLeave)
 678:stk500boot.c  **** 		{
 679:stk500boot.c  **** 			/*
 680:stk500boot.c  **** 			 * Collect received bytes to a complete message
 681:stk500boot.c  **** 			 */
 682:stk500boot.c  **** 			msgParseState	=	ST_START;
 683:stk500boot.c  **** 			while ( msgParseState != ST_PROCESS )
 684:stk500boot.c  **** 			{
 685:stk500boot.c  **** 				if (boot_state==1)
 686:stk500boot.c  **** 				{
 687:stk500boot.c  **** 					boot_state	=	0;
 688:stk500boot.c  **** 					c			=	UART_DATA_REG;
 689:stk500boot.c  **** 				}
 690:stk500boot.c  **** 				else
 691:stk500boot.c  **** 				{
 692:stk500boot.c  **** 				//	c	=	recchar();
 693:stk500boot.c  **** 					c	=	recchar_timeout();
 694:stk500boot.c  **** 					
 695:stk500boot.c  **** 				}
 696:stk500boot.c  **** 
 697:stk500boot.c  **** 			#ifdef ENABLE_MONITOR
 698:stk500boot.c  **** 				rcvdCharCntr++;
 699:stk500boot.c  **** 
 700:stk500boot.c  **** 				if ((c == '!')  && (rcvdCharCntr < 10))
 701:stk500boot.c  **** 				{
 702:stk500boot.c  **** 					exPointCntr++;
 703:stk500boot.c  **** 					if (exPointCntr == 3)
 704:stk500boot.c  **** 					{
 705:stk500boot.c  **** 						RunMonitor();
 706:stk500boot.c  **** 						exPointCntr		=	0;	//	reset back to zero so we dont get in an endless loop
 707:stk500boot.c  **** 						isLeave			=	1;
 708:stk500boot.c  **** 						msgParseState	=	99;	//*	we dont want it do anything
 709:stk500boot.c  **** 						break;
 710:stk500boot.c  **** 					}
 711:stk500boot.c  **** 				}
 712:stk500boot.c  **** 				else
 713:stk500boot.c  **** 				{
 714:stk500boot.c  **** 					exPointCntr	=	0;
 715:stk500boot.c  **** 				}
 716:stk500boot.c  **** 			#endif
 717:stk500boot.c  **** 
 718:stk500boot.c  **** 				switch (msgParseState)
 719:stk500boot.c  **** 				{
 720:stk500boot.c  **** 					case ST_START:
 721:stk500boot.c  **** 						if ( c == MESSAGE_START )
 722:stk500boot.c  **** 						{
 723:stk500boot.c  **** 							msgParseState	=	ST_GET_SEQ_NUM;
 724:stk500boot.c  **** 							checksum		=	MESSAGE_START^0;
 725:stk500boot.c  **** 						}
 726:stk500boot.c  **** 						break;
 727:stk500boot.c  **** 
 728:stk500boot.c  **** 					case ST_GET_SEQ_NUM:
 729:stk500boot.c  **** 					#ifdef _FIX_ISSUE_505_
 730:stk500boot.c  **** 						seqNum			=	c;
 731:stk500boot.c  **** 						msgParseState	=	ST_MSG_SIZE_1;
 732:stk500boot.c  **** 						checksum		^=	c;
 733:stk500boot.c  **** 					#else
 734:stk500boot.c  **** 						if ( (c == 1) || (c == seqNum) )
 735:stk500boot.c  **** 						{
 736:stk500boot.c  **** 							seqNum			=	c;
 737:stk500boot.c  **** 							msgParseState	=	ST_MSG_SIZE_1;
 738:stk500boot.c  **** 							checksum		^=	c;
 739:stk500boot.c  **** 						}
 740:stk500boot.c  **** 						else
 741:stk500boot.c  **** 						{
 742:stk500boot.c  **** 							msgParseState	=	ST_START;
 743:stk500boot.c  **** 						}
 744:stk500boot.c  **** 					#endif
 745:stk500boot.c  **** 						break;
 746:stk500boot.c  **** 
 747:stk500boot.c  **** 					case ST_MSG_SIZE_1:
 748:stk500boot.c  **** 						msgLength		=	c<<8;
 749:stk500boot.c  **** 						msgParseState	=	ST_MSG_SIZE_2;
 750:stk500boot.c  **** 						checksum		^=	c;
 751:stk500boot.c  **** 						break;
 752:stk500boot.c  **** 
 753:stk500boot.c  **** 					case ST_MSG_SIZE_2:
 754:stk500boot.c  **** 						msgLength		|=	c;
 755:stk500boot.c  **** 						msgParseState	=	ST_GET_TOKEN;
 756:stk500boot.c  **** 						checksum		^=	c;
 757:stk500boot.c  **** 						break;
 758:stk500boot.c  **** 
 759:stk500boot.c  **** 					case ST_GET_TOKEN:
 760:stk500boot.c  **** 						if ( c == TOKEN )
 761:stk500boot.c  **** 						{
 762:stk500boot.c  **** 							msgParseState	=	ST_GET_DATA;
 763:stk500boot.c  **** 							checksum		^=	c;
 764:stk500boot.c  **** 							ii				=	0;
 765:stk500boot.c  **** 						}
 766:stk500boot.c  **** 						else
 767:stk500boot.c  **** 						{
 768:stk500boot.c  **** 							msgParseState	=	ST_START;
 769:stk500boot.c  **** 						}
 770:stk500boot.c  **** 						break;
 771:stk500boot.c  **** 
 772:stk500boot.c  **** 					case ST_GET_DATA:
 773:stk500boot.c  **** 						msgBuffer[ii++]	=	c;
 774:stk500boot.c  **** 						checksum		^=	c;
 775:stk500boot.c  **** 						if (ii == msgLength )
 776:stk500boot.c  **** 						{
 777:stk500boot.c  **** 							msgParseState	=	ST_GET_CHECK;
 778:stk500boot.c  **** 						}
 779:stk500boot.c  **** 						break;
 780:stk500boot.c  **** 
 781:stk500boot.c  **** 					case ST_GET_CHECK:
 782:stk500boot.c  **** 						if ( c == checksum )
 783:stk500boot.c  **** 						{
 784:stk500boot.c  **** 							msgParseState	=	ST_PROCESS;
 785:stk500boot.c  **** 						}
 786:stk500boot.c  **** 						else
 787:stk500boot.c  **** 						{
 788:stk500boot.c  **** 							msgParseState	=	ST_START;
 789:stk500boot.c  **** 						}
 790:stk500boot.c  **** 						break;
 791:stk500boot.c  **** 				}	//	switch
 792:stk500boot.c  **** 			}	//	while(msgParseState)
 793:stk500boot.c  **** 
 794:stk500boot.c  **** 			/*
 795:stk500boot.c  **** 			 * Now process the STK500 commands, see Atmel Appnote AVR068
 796:stk500boot.c  **** 			 */
 797:stk500boot.c  **** 
 798:stk500boot.c  **** 			switch (msgBuffer[0])
 799:stk500boot.c  **** 			{
 800:stk500boot.c  **** 	#ifndef REMOVE_CMD_SPI_MULTI
 801:stk500boot.c  **** 				case CMD_SPI_MULTI:
 802:stk500boot.c  **** 					{
 803:stk500boot.c  **** 						unsigned char answerByte;
 804:stk500boot.c  **** 						unsigned char flag=0;
 805:stk500boot.c  **** 
 806:stk500boot.c  **** 						if ( msgBuffer[4]== 0x30 )
 807:stk500boot.c  **** 						{
 808:stk500boot.c  **** 							unsigned char signatureIndex	=	msgBuffer[6];
 809:stk500boot.c  **** 
 810:stk500boot.c  **** 							if ( signatureIndex == 0 )
 811:stk500boot.c  **** 							{
 812:stk500boot.c  **** 								answerByte	=	(SIGNATURE_BYTES >> 16) & 0x000000FF;
 813:stk500boot.c  **** 							}
 814:stk500boot.c  **** 							else if ( signatureIndex == 1 )
 815:stk500boot.c  **** 							{
 816:stk500boot.c  **** 								answerByte	=	(SIGNATURE_BYTES >> 8) & 0x000000FF;
 817:stk500boot.c  **** 							}
 818:stk500boot.c  **** 							else
 819:stk500boot.c  **** 							{
 820:stk500boot.c  **** 								answerByte	=	SIGNATURE_BYTES & 0x000000FF;
 821:stk500boot.c  **** 							}
 822:stk500boot.c  **** 						}
 823:stk500boot.c  **** 						else if ( msgBuffer[4] & 0x50 )
 824:stk500boot.c  **** 						{
 825:stk500boot.c  **** 						//*	Issue 544: 	stk500v2 bootloader doesn't support reading fuses
 826:stk500boot.c  **** 						//*	I cant find the docs that say what these are supposed to be but this was figured out by t
 827:stk500boot.c  **** 						//	answerByte	=	boot_lock_fuse_bits_get(GET_LOW_FUSE_BITS);
 828:stk500boot.c  **** 						//	answerByte	=	boot_lock_fuse_bits_get(GET_HIGH_FUSE_BITS);
 829:stk500boot.c  **** 						//	answerByte	=	boot_lock_fuse_bits_get(GET_EXTENDED_FUSE_BITS);
 830:stk500boot.c  **** 							if (msgBuffer[4] == 0x50)
 831:stk500boot.c  **** 							{
 832:stk500boot.c  **** 								answerByte	=	boot_lock_fuse_bits_get(GET_LOW_FUSE_BITS);
 833:stk500boot.c  **** 							}
 834:stk500boot.c  **** 							else if (msgBuffer[4] == 0x58)
 835:stk500boot.c  **** 							{
 836:stk500boot.c  **** 								answerByte	=	boot_lock_fuse_bits_get(GET_HIGH_FUSE_BITS);
 837:stk500boot.c  **** 							}
 838:stk500boot.c  **** 							else
 839:stk500boot.c  **** 							{
 840:stk500boot.c  **** 								answerByte	=	0;
 841:stk500boot.c  **** 							}
 842:stk500boot.c  **** 						}
 843:stk500boot.c  **** 						else
 844:stk500boot.c  **** 						{
 845:stk500boot.c  **** 							answerByte	=	0; // for all others command are not implemented, return dummy value for AVRDUD
 846:stk500boot.c  **** 						}
 847:stk500boot.c  **** 						if ( !flag )
 848:stk500boot.c  **** 						{
 849:stk500boot.c  **** 							msgLength		=	7;
 850:stk500boot.c  **** 							msgBuffer[1]	=	STATUS_CMD_OK;
 851:stk500boot.c  **** 							msgBuffer[2]	=	0;
 852:stk500boot.c  **** 							msgBuffer[3]	=	msgBuffer[4];
 853:stk500boot.c  **** 							msgBuffer[4]	=	0;
 854:stk500boot.c  **** 							msgBuffer[5]	=	answerByte;
 855:stk500boot.c  **** 							msgBuffer[6]	=	STATUS_CMD_OK;
 856:stk500boot.c  **** 						}
 857:stk500boot.c  **** 					}
 858:stk500boot.c  **** 					break;
 859:stk500boot.c  **** 	#endif
 860:stk500boot.c  **** 				case CMD_SIGN_ON:
 861:stk500boot.c  **** 					msgLength		=	11;
 862:stk500boot.c  **** 					msgBuffer[1] 	=	STATUS_CMD_OK;
 863:stk500boot.c  **** 					msgBuffer[2] 	=	8;
 864:stk500boot.c  **** 					msgBuffer[3] 	=	'A';
 865:stk500boot.c  **** 					msgBuffer[4] 	=	'V';
 866:stk500boot.c  **** 					msgBuffer[5] 	=	'R';
 867:stk500boot.c  **** 					msgBuffer[6] 	=	'I';
 868:stk500boot.c  **** 					msgBuffer[7] 	=	'S';
 869:stk500boot.c  **** 					msgBuffer[8] 	=	'P';
 870:stk500boot.c  **** 					msgBuffer[9] 	=	'_';
 871:stk500boot.c  **** 					msgBuffer[10]	=	'2';
 872:stk500boot.c  **** 					break;
 873:stk500boot.c  **** 
 874:stk500boot.c  **** 				case CMD_GET_PARAMETER:
 875:stk500boot.c  **** 					{
 876:stk500boot.c  **** 						unsigned char value;
 877:stk500boot.c  **** 
 878:stk500boot.c  **** 						switch(msgBuffer[1])
 879:stk500boot.c  **** 						{
 880:stk500boot.c  **** 						case PARAM_BUILD_NUMBER_LOW:
 881:stk500boot.c  **** 							value	=	CONFIG_PARAM_BUILD_NUMBER_LOW;
 882:stk500boot.c  **** 							break;
 883:stk500boot.c  **** 						case PARAM_BUILD_NUMBER_HIGH:
 884:stk500boot.c  **** 							value	=	CONFIG_PARAM_BUILD_NUMBER_HIGH;
 885:stk500boot.c  **** 							break;
 886:stk500boot.c  **** 						case PARAM_HW_VER:
 887:stk500boot.c  **** 							value	=	CONFIG_PARAM_HW_VER;
 888:stk500boot.c  **** 							break;
 889:stk500boot.c  **** 						case PARAM_SW_MAJOR:
 890:stk500boot.c  **** 							value	=	CONFIG_PARAM_SW_MAJOR;
 891:stk500boot.c  **** 							break;
 892:stk500boot.c  **** 						case PARAM_SW_MINOR:
 893:stk500boot.c  **** 							value	=	CONFIG_PARAM_SW_MINOR;
 894:stk500boot.c  **** 							break;
 895:stk500boot.c  **** 						default:
 896:stk500boot.c  **** 							value	=	0;
 897:stk500boot.c  **** 							break;
 898:stk500boot.c  **** 						}
 899:stk500boot.c  **** 						msgLength		=	3;
 900:stk500boot.c  **** 						msgBuffer[1]	=	STATUS_CMD_OK;
 901:stk500boot.c  **** 						msgBuffer[2]	=	value;
 902:stk500boot.c  **** 					}
 903:stk500boot.c  **** 					break;
 904:stk500boot.c  **** 
 905:stk500boot.c  **** 				case CMD_LEAVE_PROGMODE_ISP:
 906:stk500boot.c  **** 					isLeave	=	1;
 907:stk500boot.c  **** 					//*	fall thru
 908:stk500boot.c  **** 
 909:stk500boot.c  **** 				case CMD_SET_PARAMETER:
 910:stk500boot.c  **** 				case CMD_ENTER_PROGMODE_ISP:
 911:stk500boot.c  **** 					msgLength		=	2;
 912:stk500boot.c  **** 					msgBuffer[1]	=	STATUS_CMD_OK;
 913:stk500boot.c  **** 					break;
 914:stk500boot.c  **** 
 915:stk500boot.c  **** 				case CMD_READ_SIGNATURE_ISP:
 916:stk500boot.c  **** 					{
 917:stk500boot.c  **** 						unsigned char signatureIndex	=	msgBuffer[4];
 918:stk500boot.c  **** 						unsigned char signature;
 919:stk500boot.c  **** 
 920:stk500boot.c  **** 						if ( signatureIndex == 0 )
 921:stk500boot.c  **** 							signature	=	(SIGNATURE_BYTES >>16) & 0x000000FF;
 922:stk500boot.c  **** 						else if ( signatureIndex == 1 )
 923:stk500boot.c  **** 							signature	=	(SIGNATURE_BYTES >> 8) & 0x000000FF;
 924:stk500boot.c  **** 						else
 925:stk500boot.c  **** 							signature	=	SIGNATURE_BYTES & 0x000000FF;
 926:stk500boot.c  **** 
 927:stk500boot.c  **** 						msgLength		=	4;
 928:stk500boot.c  **** 						msgBuffer[1]	=	STATUS_CMD_OK;
 929:stk500boot.c  **** 						msgBuffer[2]	=	signature;
 930:stk500boot.c  **** 						msgBuffer[3]	=	STATUS_CMD_OK;
 931:stk500boot.c  **** 					}
 932:stk500boot.c  **** 					break;
 933:stk500boot.c  **** 
 934:stk500boot.c  **** 				case CMD_READ_LOCK_ISP:
 935:stk500boot.c  **** 					msgLength		=	4;
 936:stk500boot.c  **** 					msgBuffer[1]	=	STATUS_CMD_OK;
 937:stk500boot.c  **** 					msgBuffer[2]	=	boot_lock_fuse_bits_get( GET_LOCK_BITS );
 938:stk500boot.c  **** 					msgBuffer[3]	=	STATUS_CMD_OK;
 939:stk500boot.c  **** 					break;
 940:stk500boot.c  **** 
 941:stk500boot.c  **** 				case CMD_READ_FUSE_ISP:
 942:stk500boot.c  **** 					{
 943:stk500boot.c  **** 						unsigned char fuseBits;
 944:stk500boot.c  **** 
 945:stk500boot.c  **** 						if ( msgBuffer[2] == 0x50 )
 946:stk500boot.c  **** 						{
 947:stk500boot.c  **** 							if ( msgBuffer[3] == 0x08 )
 948:stk500boot.c  **** 								fuseBits	=	boot_lock_fuse_bits_get( GET_EXTENDED_FUSE_BITS );
 949:stk500boot.c  **** 							else
 950:stk500boot.c  **** 								fuseBits	=	boot_lock_fuse_bits_get( GET_LOW_FUSE_BITS );
 951:stk500boot.c  **** 						}
 952:stk500boot.c  **** 						else
 953:stk500boot.c  **** 						{
 954:stk500boot.c  **** 							fuseBits	=	boot_lock_fuse_bits_get( GET_HIGH_FUSE_BITS );
 955:stk500boot.c  **** 						}
 956:stk500boot.c  **** 						msgLength		=	4;
 957:stk500boot.c  **** 						msgBuffer[1]	=	STATUS_CMD_OK;
 958:stk500boot.c  **** 						msgBuffer[2]	=	fuseBits;
 959:stk500boot.c  **** 						msgBuffer[3]	=	STATUS_CMD_OK;
 960:stk500boot.c  **** 					}
 961:stk500boot.c  **** 					break;
 962:stk500boot.c  **** 
 963:stk500boot.c  **** 	#ifndef REMOVE_PROGRAM_LOCK_BIT_SUPPORT
 964:stk500boot.c  **** 				case CMD_PROGRAM_LOCK_ISP:
 965:stk500boot.c  **** 					{
 966:stk500boot.c  **** 						unsigned char lockBits	=	msgBuffer[4];
 967:stk500boot.c  **** 
 968:stk500boot.c  **** 						lockBits	=	(~lockBits) & 0x3C;	// mask BLBxx bits
 969:stk500boot.c  **** 						boot_lock_bits_set(lockBits);		// and program it
 970:stk500boot.c  **** 						boot_spm_busy_wait();
 971:stk500boot.c  **** 
 972:stk500boot.c  **** 						msgLength		=	3;
 973:stk500boot.c  **** 						msgBuffer[1]	=	STATUS_CMD_OK;
 974:stk500boot.c  **** 						msgBuffer[2]	=	STATUS_CMD_OK;
 975:stk500boot.c  **** 					}
 976:stk500boot.c  **** 					break;
 977:stk500boot.c  **** 	#endif
 978:stk500boot.c  **** 				case CMD_CHIP_ERASE_ISP:
 979:stk500boot.c  **** 					eraseAddress	=	0;
 980:stk500boot.c  **** 					msgLength		=	2;
 981:stk500boot.c  **** 					msgBuffer[1]	=	STATUS_CMD_OK;
 982:stk500boot.c  **** 					//msgBuffer[1]	=	STATUS_CMD_FAILED;	//*	isue 543, return FAILED instead of OK
 983:stk500boot.c  **** 					break;
 984:stk500boot.c  **** 
 985:stk500boot.c  **** 				case CMD_LOAD_ADDRESS:
 986:stk500boot.c  **** 	#if defined(RAMPZ)
 987:stk500boot.c  **** 					address	=	( ((address_t)(msgBuffer[1])<<24)|((address_t)(msgBuffer[2])<<16)|((address_t)(msgBu
 988:stk500boot.c  **** 	#else
 989:stk500boot.c  **** 					address	=	( ((msgBuffer[3])<<8)|(msgBuffer[4]) )<<1;		//convert word to byte address
 990:stk500boot.c  **** 	#endif
 991:stk500boot.c  **** 					msgLength		=	2;
 992:stk500boot.c  **** 					msgBuffer[1]	=	STATUS_CMD_OK;
 993:stk500boot.c  **** 					break;
 994:stk500boot.c  **** 
 995:stk500boot.c  **** 				case CMD_PROGRAM_FLASH_ISP:
 996:stk500boot.c  **** 				case CMD_PROGRAM_EEPROM_ISP:
 997:stk500boot.c  **** 					{
 998:stk500boot.c  **** 						unsigned int	size	=	((msgBuffer[1])<<8) | msgBuffer[2];
 999:stk500boot.c  **** 						unsigned char	*p	=	msgBuffer+10;
1000:stk500boot.c  **** 						unsigned int	data;
1001:stk500boot.c  **** 						unsigned char	highByte, lowByte;
1002:stk500boot.c  **** 						address_t		tempaddress	=	address;
1003:stk500boot.c  **** 
1004:stk500boot.c  **** 
1005:stk500boot.c  **** 						if ( msgBuffer[0] == CMD_PROGRAM_FLASH_ISP )
1006:stk500boot.c  **** 						{
1007:stk500boot.c  **** 							// erase only main section (bootloader protection)
1008:stk500boot.c  **** 							if (eraseAddress < APP_END )
1009:stk500boot.c  **** 							{
1010:stk500boot.c  **** 								boot_page_erase(eraseAddress);	// Perform page erase
1011:stk500boot.c  **** 								boot_spm_busy_wait();		// Wait until the memory is erased.
1012:stk500boot.c  **** 								eraseAddress += SPM_PAGESIZE;	// point to next page to be erase
1013:stk500boot.c  **** 							}
1014:stk500boot.c  **** 
1015:stk500boot.c  **** 							/* Write FLASH */
1016:stk500boot.c  **** 							do {
1017:stk500boot.c  **** 								lowByte		=	*p++;
1018:stk500boot.c  **** 								highByte 	=	*p++;
1019:stk500boot.c  **** 
1020:stk500boot.c  **** 								data		=	(highByte << 8) | lowByte;
1021:stk500boot.c  **** 								boot_page_fill(address,data);
1022:stk500boot.c  **** 
1023:stk500boot.c  **** 								address	=	address + 2;	// Select next word in memory
1024:stk500boot.c  **** 								size	-=	2;				// Reduce number of bytes to write by two
1025:stk500boot.c  **** 							} while (size);					// Loop until all bytes written
1026:stk500boot.c  **** 
1027:stk500boot.c  **** 							boot_page_write(tempaddress);
1028:stk500boot.c  **** 							boot_spm_busy_wait();
1029:stk500boot.c  **** 							boot_rww_enable();				// Re-enable the RWW section
1030:stk500boot.c  **** 						}
1031:stk500boot.c  **** 						else
1032:stk500boot.c  **** 						{
1033:stk500boot.c  **** 							//*	issue 543, this should work, It has not been tested.
1034:stk500boot.c  **** 							uint16_t ii = address >> 1;
1035:stk500boot.c  **** 							/* write EEPROM */
1036:stk500boot.c  **** 							while (size) {
1037:stk500boot.c  **** 								eeprom_write_byte((uint8_t*)ii, *p++);
1038:stk500boot.c  **** 								address+=2;						// Select next EEPROM byte
1039:stk500boot.c  **** 								ii++;
1040:stk500boot.c  **** 								size--;
1041:stk500boot.c  **** 							}
1042:stk500boot.c  **** 						}
1043:stk500boot.c  **** 						msgLength		=	2;
1044:stk500boot.c  **** 						msgBuffer[1]	=	STATUS_CMD_OK;
1045:stk500boot.c  **** 					}
1046:stk500boot.c  **** 					break;
1047:stk500boot.c  **** 
1048:stk500boot.c  **** 				case CMD_READ_FLASH_ISP:
1049:stk500boot.c  **** 				case CMD_READ_EEPROM_ISP:
1050:stk500boot.c  **** 					{
1051:stk500boot.c  **** 						unsigned int	size	=	((msgBuffer[1])<<8) | msgBuffer[2];
1052:stk500boot.c  **** 						unsigned char	*p		=	msgBuffer+1;
1053:stk500boot.c  **** 						msgLength				=	size+3;
1054:stk500boot.c  **** 
1055:stk500boot.c  **** 						*p++	=	STATUS_CMD_OK;
1056:stk500boot.c  **** 						if (msgBuffer[0] == CMD_READ_FLASH_ISP )
1057:stk500boot.c  **** 						{
1058:stk500boot.c  **** 							unsigned int data;
1059:stk500boot.c  **** 
1060:stk500boot.c  **** 							// Read FLASH
1061:stk500boot.c  **** 							do {
1062:stk500boot.c  **** 						//#if defined(RAMPZ)
1063:stk500boot.c  **** 						#if (FLASHEND > 0x10000)
1064:stk500boot.c  **** 								data	=	pgm_read_word_far(address);
1065:stk500boot.c  **** 						#else
1066:stk500boot.c  **** 								data	=	pgm_read_word_near(address);
1067:stk500boot.c  **** 						#endif
1068:stk500boot.c  **** 								*p++	=	(unsigned char)data;		//LSB
1069:stk500boot.c  **** 								*p++	=	(unsigned char)(data >> 8);	//MSB
1070:stk500boot.c  **** 								address	+=	2;							// Select next word in memory
1071:stk500boot.c  **** 								size	-=	2;
1072:stk500boot.c  **** 							}while (size);
1073:stk500boot.c  **** 						}
1074:stk500boot.c  **** 						else
1075:stk500boot.c  **** 						{
1076:stk500boot.c  **** 							/* Read EEPROM */
1077:stk500boot.c  **** 							do {
1078:stk500boot.c  **** 								EEARL	=	address;			// Setup EEPROM address
1079:stk500boot.c  **** 								EEARH	=	((address >> 8));
1080:stk500boot.c  **** 								address++;					// Select next EEPROM byte
1081:stk500boot.c  **** 								EECR	|=	(1<<EERE);			// Read EEPROM
1082:stk500boot.c  **** 								*p++	=	EEDR;				// Send EEPROM data
1083:stk500boot.c  **** 								size--;
1084:stk500boot.c  **** 							} while (size);
1085:stk500boot.c  **** 						}
1086:stk500boot.c  **** 						*p++	=	STATUS_CMD_OK;
1087:stk500boot.c  **** 					}
1088:stk500boot.c  **** 					break;
1089:stk500boot.c  **** 
1090:stk500boot.c  **** 				default:
1091:stk500boot.c  **** 					msgLength		=	2;
1092:stk500boot.c  **** 					msgBuffer[1]	=	STATUS_CMD_FAILED;
1093:stk500boot.c  **** 					break;
1094:stk500boot.c  **** 			}
1095:stk500boot.c  **** 
1096:stk500boot.c  **** 			/*
1097:stk500boot.c  **** 			 * Now send answer message back
1098:stk500boot.c  **** 			 */
1099:stk500boot.c  **** 			sendchar(MESSAGE_START);
1100:stk500boot.c  **** 			checksum	=	MESSAGE_START^0;
1101:stk500boot.c  **** 
1102:stk500boot.c  **** 			sendchar(seqNum);
1103:stk500boot.c  **** 			checksum	^=	seqNum;
1104:stk500boot.c  **** 
1105:stk500boot.c  **** 			c			=	((msgLength>>8)&0xFF);
1106:stk500boot.c  **** 			sendchar(c);
1107:stk500boot.c  **** 			checksum	^=	c;
1108:stk500boot.c  **** 
1109:stk500boot.c  **** 			c			=	msgLength&0x00FF;
1110:stk500boot.c  **** 			sendchar(c);
1111:stk500boot.c  **** 			checksum ^= c;
1112:stk500boot.c  **** 
1113:stk500boot.c  **** 			sendchar(TOKEN);
1114:stk500boot.c  **** 			checksum ^= TOKEN;
1115:stk500boot.c  **** 
1116:stk500boot.c  **** 			p	=	msgBuffer;
1117:stk500boot.c  **** 			while ( msgLength )
1118:stk500boot.c  **** 			{
1119:stk500boot.c  **** 				c	=	*p++;
1120:stk500boot.c  **** 				sendchar(c);
1121:stk500boot.c  **** 				checksum ^=c;
1122:stk500boot.c  **** 				msgLength--;
1123:stk500boot.c  **** 			}
1124:stk500boot.c  **** 			sendchar(checksum);
1125:stk500boot.c  **** 			seqNum++;
1126:stk500boot.c  **** 	
1127:stk500boot.c  **** 		#ifndef REMOVE_BOOTLOADER_LED
1128:stk500boot.c  **** 			//*	<MLS>	toggle the LED
1129:stk500boot.c  **** 			PROGLED_PORT	^=	(1<<PROGLED_PIN);	// active high LED ON
1130:stk500boot.c  **** 		#endif
1131:stk500boot.c  **** 
1132:stk500boot.c  **** 		}
1133:stk500boot.c  **** 	}
1134:stk500boot.c  **** 
1135:stk500boot.c  **** #ifdef _DEBUG_WITH_LEDS_
1136:stk500boot.c  **** 	//*	this is for debugging it can be removed
1137:stk500boot.c  **** 	for (ii=0; ii<10; ii++)
1138:stk500boot.c  **** 	{
1139:stk500boot.c  **** 		PROGLED_PORT	&=	~(1<<PROGLED_PIN);	// turn LED off
1140:stk500boot.c  **** 		delay_ms(200);
1141:stk500boot.c  **** 		PROGLED_PORT	|=	(1<<PROGLED_PIN);	// turn LED on
1142:stk500boot.c  **** 		delay_ms(200);
1143:stk500boot.c  **** 	}
1144:stk500boot.c  **** 	PROGLED_PORT	&=	~(1<<PROGLED_PIN);	// turn LED off
1145:stk500boot.c  **** #endif
1146:stk500boot.c  **** 
1147:stk500boot.c  **** #ifdef _DEBUG_SERIAL_
1148:stk500boot.c  **** 	sendchar('j');
1149:stk500boot.c  **** //	sendchar('u');
1150:stk500boot.c  **** //	sendchar('m');
1151:stk500boot.c  **** //	sendchar('p');
1152:stk500boot.c  **** //	sendchar(' ');
1153:stk500boot.c  **** //	sendchar('u');
1154:stk500boot.c  **** //	sendchar('s');
1155:stk500boot.c  **** //	sendchar('r');
1156:stk500boot.c  **** 	sendchar(0x0d);
1157:stk500boot.c  **** 	sendchar(0x0a);
1158:stk500boot.c  **** 
1159:stk500boot.c  **** 	delay_ms(100);
1160:stk500boot.c  **** #endif
1161:stk500boot.c  **** 
1162:stk500boot.c  **** 
1163:stk500boot.c  **** #ifndef REMOVE_BOOTLOADER_LED
1164:stk500boot.c  **** 	PROGLED_DDR		&=	~(1<<PROGLED_PIN);	// set to default
1165:stk500boot.c  **** 	PROGLED_PORT	&=	~(1<<PROGLED_PIN);	// active low LED OFF
1166:stk500boot.c  **** //	PROGLED_PORT	|=	(1<<PROGLED_PIN);	// active high LED OFf
1167:stk500boot.c  **** 	delay_ms(100);							// delay after exit
1168:stk500boot.c  **** #endif
1169:stk500boot.c  **** 
1170:stk500boot.c  **** 
1171:stk500boot.c  **** 	asm volatile ("nop");			// wait until port has changed
1172:stk500boot.c  **** 
1173:stk500boot.c  **** 	/*
1174:stk500boot.c  **** 	 * Now leave bootloader
1175:stk500boot.c  **** 	 */
1176:stk500boot.c  **** 
1177:stk500boot.c  **** 	UART_STATUS_REG	&=	0xfd;
1178:stk500boot.c  **** 	boot_rww_enable();				// enable application section
1179:stk500boot.c  **** 
1180:stk500boot.c  **** 
1181:stk500boot.c  **** 	asm volatile(
1182:stk500boot.c  **** 			"clr	r30		\n\t"
1183:stk500boot.c  **** 			"clr	r31		\n\t"
1184:stk500boot.c  **** 			"ijmp	\n\t"
1185:stk500boot.c  **** 			);
1186:stk500boot.c  **** //	asm volatile ( "push r1" "\n\t"		// Jump to Reset vector in Application Section
1187:stk500boot.c  **** //					"push r1" "\n\t"
1188:stk500boot.c  **** //					"ret"	 "\n\t"
1189:stk500boot.c  **** //					::);
1190:stk500boot.c  **** 
1191:stk500boot.c  **** 	 /*
1192:stk500boot.c  **** 	 * Never return to stop GCC to generate exit return code
1193:stk500boot.c  **** 	 * Actually we will never reach this point, but the compiler doesn't
1194:stk500boot.c  **** 	 * understand this
1195:stk500boot.c  **** 	 */
1196:stk500boot.c  **** 	for(;;);
1197:stk500boot.c  **** }
1198:stk500boot.c  **** 
1199:stk500boot.c  **** /*
1200:stk500boot.c  **** base address = f800
1201:stk500boot.c  **** 
1202:stk500boot.c  **** avrdude: Device signature = 0x1e9703
1203:stk500boot.c  **** avrdude: safemode: lfuse reads as FF
1204:stk500boot.c  **** avrdude: safemode: hfuse reads as DA
1205:stk500boot.c  **** avrdude: safemode: efuse reads as F5
1206:stk500boot.c  **** avrdude>
1207:stk500boot.c  **** 
1208:stk500boot.c  **** 
1209:stk500boot.c  **** base address = f000
1210:stk500boot.c  **** avrdude: Device signature = 0x1e9703
1211:stk500boot.c  **** avrdude: safemode: lfuse reads as FF
1212:stk500boot.c  **** avrdude: safemode: hfuse reads as D8
1213:stk500boot.c  **** avrdude: safemode: efuse reads as F5
1214:stk500boot.c  **** avrdude>
1215:stk500boot.c  **** */
1216:stk500boot.c  **** 
1217:stk500boot.c  **** //************************************************************************
1218:stk500boot.c  **** #ifdef ENABLE_MONITOR
1219:stk500boot.c  **** #include	<math.h>
1220:stk500boot.c  **** 
1221:stk500boot.c  **** unsigned long	gRamIndex;
1222:stk500boot.c  **** unsigned long	gFlashIndex;
1223:stk500boot.c  **** unsigned long	gEepromIndex;
1224:stk500boot.c  **** 
1225:stk500boot.c  **** 
1226:stk500boot.c  **** #define	true	1
1227:stk500boot.c  **** #define	false	0
1228:stk500boot.c  **** 
1229:stk500boot.c  **** #include	"avr_cpunames.h"
1230:stk500boot.c  **** 
1231:stk500boot.c  **** #ifndef _AVR_CPU_NAME_
1232:stk500boot.c  **** 	#error cpu name not defined
1233:stk500boot.c  **** #endif
1234:stk500boot.c  **** 
1235:stk500boot.c  **** #ifdef _VECTORS_SIZE
1236:stk500boot.c  **** 	#define	kInterruptVectorCount (_VECTORS_SIZE / 4)
1237:stk500boot.c  **** #else
1238:stk500boot.c  **** 	#define	kInterruptVectorCount 23
1239:stk500boot.c  **** #endif
1240:stk500boot.c  **** 
1241:stk500boot.c  **** 
1242:stk500boot.c  **** void	PrintDecInt(int theNumber, int digitCnt);
1243:stk500boot.c  **** 
1244:stk500boot.c  **** #ifdef _AVR_CPU_NAME_
1245:stk500boot.c  **** 	const char	gTextMsg_CPU_Name[]			PROGMEM	=	_AVR_CPU_NAME_;
1246:stk500boot.c  **** #else
1247:stk500boot.c  **** 	const char	gTextMsg_CPU_Name[]			PROGMEM	=	"UNKNOWN";
1248:stk500boot.c  **** #endif
1249:stk500boot.c  **** 
1250:stk500boot.c  **** 	const char	gTextMsg_Explorer[]			PROGMEM	=	"Arduino explorer stk500V2 by MLS";
1251:stk500boot.c  **** 	const char	gTextMsg_Prompt[]			PROGMEM	=	"Bootloader>";
1252:stk500boot.c  **** 	const char	gTextMsg_HUH[]				PROGMEM	=	"Huh?";
1253:stk500boot.c  **** 	const char	gTextMsg_COMPILED_ON[]		PROGMEM	=	"Compiled on = ";
1254:stk500boot.c  **** 	const char	gTextMsg_CPU_Type[]			PROGMEM	=	"CPU Type    = ";
1255:stk500boot.c  **** 	const char	gTextMsg_AVR_ARCH[]			PROGMEM	=	"__AVR_ARCH__= ";
1256:stk500boot.c  **** 	const char	gTextMsg_AVR_LIBC[]			PROGMEM	=	"AVR LibC Ver= ";
1257:stk500boot.c  **** 	const char	gTextMsg_GCC_VERSION[]		PROGMEM	=	"GCC Version = ";
1258:stk500boot.c  **** 	const char	gTextMsg_CPU_SIGNATURE[]	PROGMEM	=	"CPU ID      = ";
1259:stk500boot.c  **** 	const char	gTextMsg_FUSE_BYTE_LOW[]	PROGMEM	=	"Low fuse    = ";
1260:stk500boot.c  **** 	const char	gTextMsg_FUSE_BYTE_HIGH[]	PROGMEM	=	"High fuse   = ";
1261:stk500boot.c  **** 	const char	gTextMsg_FUSE_BYTE_EXT[]	PROGMEM	=	"Ext fuse    = ";
1262:stk500boot.c  **** 	const char	gTextMsg_FUSE_BYTE_LOCK[]	PROGMEM	=	"Lock fuse   = ";
1263:stk500boot.c  **** 	const char	gTextMsg_GCC_DATE_STR[]		PROGMEM	=	__DATE__;
1264:stk500boot.c  **** 	const char	gTextMsg_AVR_LIBC_VER_STR[]	PROGMEM	=	__AVR_LIBC_VERSION_STRING__;
1265:stk500boot.c  **** 	const char	gTextMsg_GCC_VERSION_STR[]	PROGMEM	=	__VERSION__;
1266:stk500boot.c  **** 	const char	gTextMsg_VECTOR_HEADER[]	PROGMEM	=	"V#   ADDR   op code     instruction addr   Interrup
1267:stk500boot.c  **** 	const char	gTextMsg_noVector[]			PROGMEM	=	"no vector";
1268:stk500boot.c  **** 	const char	gTextMsg_rjmp[]				PROGMEM	=	"rjmp  ";
1269:stk500boot.c  **** 	const char	gTextMsg_jmp[]				PROGMEM	=	"jmp ";
1270:stk500boot.c  **** 	const char	gTextMsg_WHAT_PORT[]		PROGMEM	=	"What port:";
1271:stk500boot.c  **** 	const char	gTextMsg_PortNotSupported[]	PROGMEM	=	"Port not supported";
1272:stk500boot.c  **** 	const char	gTextMsg_MustBeLetter[]		PROGMEM	=	"Must be a letter";
1273:stk500boot.c  **** 	const char	gTextMsg_SPACE[]			PROGMEM	=	" ";
1274:stk500boot.c  **** 	const char	gTextMsg_WriteToEEprom[]	PROGMEM	=	"Writting EE";
1275:stk500boot.c  **** 	const char	gTextMsg_ReadingEEprom[]	PROGMEM	=	"Reading EE";
1276:stk500boot.c  **** 	const char	gTextMsg_EEPROMerrorCnt[]	PROGMEM	=	"EE err cnt=";
1277:stk500boot.c  **** 	const char	gTextMsg_PORT[]				PROGMEM	=	"PORT";
1278:stk500boot.c  **** 
1279:stk500boot.c  **** 
1280:stk500boot.c  **** //************************************************************************
1281:stk500boot.c  **** //*	Help messages
1282:stk500boot.c  **** 	const char	gTextMsg_HELP_MSG_0[]		PROGMEM	=	"0=Zero addr";
1283:stk500boot.c  **** 	const char	gTextMsg_HELP_MSG_QM[]		PROGMEM	=	"?=CPU stats";
1284:stk500boot.c  **** 	const char	gTextMsg_HELP_MSG_AT[]		PROGMEM	=	"@=EEPROM test";
1285:stk500boot.c  **** 	const char	gTextMsg_HELP_MSG_B[]		PROGMEM	=	"B=Blink LED";
1286:stk500boot.c  **** 	const char	gTextMsg_HELP_MSG_E[]		PROGMEM	=	"E=Dump EEPROM";
1287:stk500boot.c  **** 	const char	gTextMsg_HELP_MSG_F[]		PROGMEM	=	"F=Dump FLASH";
1288:stk500boot.c  **** 	const char	gTextMsg_HELP_MSG_H[]		PROGMEM	=	"H=Help";
1289:stk500boot.c  **** 	const char	gTextMsg_HELP_MSG_L[]		PROGMEM	=	"L=List I/O Ports";
1290:stk500boot.c  **** //	const char	gTextMsg_HELP_MSG_Q[]		PROGMEM	=	"Q=Quit & jump to user pgm";
1291:stk500boot.c  **** 	const char	gTextMsg_HELP_MSG_Q[]		PROGMEM	=	"Q=Quit";
1292:stk500boot.c  **** 	const char	gTextMsg_HELP_MSG_R[]		PROGMEM	=	"R=Dump RAM";
1293:stk500boot.c  **** 	const char	gTextMsg_HELP_MSG_V[]		PROGMEM	=	"V=show interrupt Vectors";
1294:stk500boot.c  **** 	const char	gTextMsg_HELP_MSG_Y[]		PROGMEM	=	"Y=Port blink";
1295:stk500boot.c  **** 
1296:stk500boot.c  **** 	const char	gTextMsg_END[]				PROGMEM	=	"*";
1297:stk500boot.c  **** 
1298:stk500boot.c  **** 
1299:stk500boot.c  **** //************************************************************************
1300:stk500boot.c  **** void	PrintFromPROGMEM(const void *dataPtr, unsigned char offset)
1301:stk500boot.c  **** {
 164               		.loc 1 1301 0
 165               		.cfi_startproc
 166               	.LVL5:
 167 0036 CF93      		push r28
 168               	.LCFI0:
 169               		.cfi_def_cfa_offset 4
 170               		.cfi_offset 28, -3
 171 0038 DF93      		push r29
 172               	.LCFI1:
 173               		.cfi_def_cfa_offset 5
 174               		.cfi_offset 29, -4
 175               	/* prologue: function */
 176               	/* frame size = 0 */
 177               	/* stack size = 2 */
 178               	.L__stack_usage = 2
1302:stk500boot.c  **** char	theChar;
1303:stk500boot.c  **** 
1304:stk500boot.c  **** 	dataPtr		+=	offset;
 179               		.loc 1 1304 0
 180 003a EC01      		movw r28,r24
 181 003c C60F      		add r28,r22
 182 003e D11D      		adc r29,__zero_reg__
 183               	.LVL6:
 184               	.L13:
 185               	.LBB57:
1305:stk500boot.c  **** 
1306:stk500boot.c  **** 	do {
1307:stk500boot.c  **** 	#if (FLASHEND > 0x10000)
1308:stk500boot.c  **** 		theChar	=	pgm_read_byte_far((uint16_t)dataPtr++);
 186               		.loc 1 1308 0
 187 0040 CE01      		movw r24,r28
 188 0042 A0E0      		ldi r26,lo8(0)
 189 0044 B0E0      		ldi r27,hi8(0)
 190               	.LVL7:
 191 0046 2196      		adiw r28,1
 192               	.LVL8:
 193               	/* #APP */
 194               	 ;  1308 "stk500boot.c" 1
 195 0048 ABBF      		out 59, r26
 196 004a FC01      		movw r30, r24
 197 004c 8791      		elpm r24, Z+
 198               		
 199               	 ;  0 "" 2
 200               	.LVL9:
 201               	/* #NOAPP */
 202               	.LBE57:
1309:stk500boot.c  **** 	#else
1310:stk500boot.c  **** 		theChar	=	pgm_read_byte_near((uint16_t)dataPtr++);
1311:stk500boot.c  **** 	#endif
1312:stk500boot.c  **** 		if (theChar != 0)
 203               		.loc 1 1312 0
 204 004e 8823      		tst r24
 205 0050 01F0      		breq .L11
1313:stk500boot.c  **** 		{
1314:stk500boot.c  **** 			sendchar(theChar);
 206               		.loc 1 1314 0
 207 0052 0E94 0000 		call sendchar
 208               	.LVL10:
 209 0056 00C0      		rjmp .L13
 210               	.LVL11:
 211               	.L11:
 212               	/* epilogue start */
1315:stk500boot.c  **** 		}
1316:stk500boot.c  **** 	} while (theChar != 0);
1317:stk500boot.c  **** }
 213               		.loc 1 1317 0
 214 0058 DF91      		pop r29
 215 005a CF91      		pop r28
 216               	.LVL12:
 217 005c 0895      		ret
 218               		.cfi_endproc
 219               	.LFE14:
 221               	.global	PrintNewLine
 223               	PrintNewLine:
 224               	.LFB15:
1318:stk500boot.c  **** 
1319:stk500boot.c  **** //************************************************************************
1320:stk500boot.c  **** void	PrintNewLine(void)
1321:stk500boot.c  **** {
 225               		.loc 1 1321 0
 226               		.cfi_startproc
 227               	/* prologue: function */
 228               	/* frame size = 0 */
 229               	/* stack size = 0 */
 230               	.L__stack_usage = 0
1322:stk500boot.c  **** 	sendchar(0x0d);
 231               		.loc 1 1322 0
 232 005e 8DE0      		ldi r24,lo8(13)
 233 0060 0E94 0000 		call sendchar
1323:stk500boot.c  **** 	sendchar(0x0a);
 234               		.loc 1 1323 0
 235 0064 8AE0      		ldi r24,lo8(10)
 236 0066 0E94 0000 		call sendchar
 237               	/* epilogue start */
1324:stk500boot.c  **** }
 238               		.loc 1 1324 0
 239 006a 0895      		ret
 240               		.cfi_endproc
 241               	.LFE15:
 243               		.section	.text.unlikely
 245               	PrintAvailablePort:
 246               	.LFB25:
1325:stk500boot.c  **** 
1326:stk500boot.c  **** 
1327:stk500boot.c  **** //************************************************************************
1328:stk500boot.c  **** void	PrintFromPROGMEMln(const void *dataPtr, unsigned char offset)
1329:stk500boot.c  **** {
1330:stk500boot.c  **** 	PrintFromPROGMEM(dataPtr, offset);
1331:stk500boot.c  **** 
1332:stk500boot.c  **** 	PrintNewLine();
1333:stk500boot.c  **** }
1334:stk500boot.c  **** 
1335:stk500boot.c  **** 
1336:stk500boot.c  **** //************************************************************************
1337:stk500boot.c  **** void	PrintString(char *textString)
1338:stk500boot.c  **** {
1339:stk500boot.c  **** char	theChar;
1340:stk500boot.c  **** int		ii;
1341:stk500boot.c  **** 
1342:stk500boot.c  **** 	theChar		=	1;
1343:stk500boot.c  **** 	ii			=	0;
1344:stk500boot.c  **** 	while (theChar != 0)
1345:stk500boot.c  **** 	{
1346:stk500boot.c  **** 		theChar	=	textString[ii];
1347:stk500boot.c  **** 		if (theChar != 0)
1348:stk500boot.c  **** 		{
1349:stk500boot.c  **** 			sendchar(theChar);
1350:stk500boot.c  **** 		}
1351:stk500boot.c  **** 		ii++;
1352:stk500boot.c  **** 	}
1353:stk500boot.c  **** }
1354:stk500boot.c  **** 
1355:stk500boot.c  **** //************************************************************************
1356:stk500boot.c  **** void	PrintHexByte(unsigned char theByte)
1357:stk500boot.c  **** {
1358:stk500boot.c  **** char	theChar;
1359:stk500boot.c  **** 
1360:stk500boot.c  **** 	theChar	=	0x30 + ((theByte >> 4) & 0x0f);
1361:stk500boot.c  **** 	if (theChar > 0x39)
1362:stk500boot.c  **** 	{
1363:stk500boot.c  **** 		theChar	+=	7;
1364:stk500boot.c  **** 	}
1365:stk500boot.c  **** 	sendchar(theChar );
1366:stk500boot.c  **** 
1367:stk500boot.c  **** 	theChar	=	0x30 + (theByte & 0x0f);
1368:stk500boot.c  **** 	if (theChar > 0x39)
1369:stk500boot.c  **** 	{
1370:stk500boot.c  **** 		theChar	+=	7;
1371:stk500boot.c  **** 	}
1372:stk500boot.c  **** 	sendchar(theChar );
1373:stk500boot.c  **** }
1374:stk500boot.c  **** 
1375:stk500boot.c  **** //************************************************************************
1376:stk500boot.c  **** void	PrintDecInt(int theNumber, int digitCnt)
1377:stk500boot.c  **** {
1378:stk500boot.c  **** int	theChar;
1379:stk500boot.c  **** int	myNumber;
1380:stk500boot.c  **** 
1381:stk500boot.c  **** 	myNumber	=	theNumber;
1382:stk500boot.c  **** 
1383:stk500boot.c  **** 	if ((myNumber > 100) || (digitCnt >= 3))
1384:stk500boot.c  **** 	{
1385:stk500boot.c  **** 		theChar		=	0x30 + myNumber / 100;
1386:stk500boot.c  **** 		sendchar(theChar );
1387:stk500boot.c  **** 	}
1388:stk500boot.c  **** 
1389:stk500boot.c  **** 	if ((myNumber > 10) || (digitCnt >= 2))
1390:stk500boot.c  **** 	{
1391:stk500boot.c  **** 		theChar	=	0x30  + ((myNumber % 100) / 10 );
1392:stk500boot.c  **** 		sendchar(theChar );
1393:stk500boot.c  **** 	}
1394:stk500boot.c  **** 	theChar	=	0x30 + (myNumber % 10);
1395:stk500boot.c  **** 	sendchar(theChar );
1396:stk500boot.c  **** }
1397:stk500boot.c  **** 
1398:stk500boot.c  **** 
1399:stk500boot.c  **** 
1400:stk500boot.c  **** 
1401:stk500boot.c  **** //************************************************************************
1402:stk500boot.c  **** static void	PrintCPUstats(void)
1403:stk500boot.c  **** {
1404:stk500boot.c  **** unsigned char fuseByte;
1405:stk500boot.c  **** 
1406:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_Explorer, 0);
1407:stk500boot.c  **** 
1408:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_COMPILED_ON, 0);
1409:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_GCC_DATE_STR, 0);
1410:stk500boot.c  **** 
1411:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_CPU_Type, 0);
1412:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_CPU_Name, 0);
1413:stk500boot.c  **** 
1414:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_AVR_ARCH, 0);
1415:stk500boot.c  **** 	PrintDecInt(__AVR_ARCH__, 1);
1416:stk500boot.c  **** 	PrintNewLine();
1417:stk500boot.c  **** 
1418:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_GCC_VERSION, 0);
1419:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_GCC_VERSION_STR, 0);
1420:stk500boot.c  **** 
1421:stk500boot.c  **** 	//*	these can be found in avr/version.h
1422:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_AVR_LIBC, 0);
1423:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_AVR_LIBC_VER_STR, 0);
1424:stk500boot.c  **** 
1425:stk500boot.c  **** #if defined(SIGNATURE_0)
1426:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_CPU_SIGNATURE, 0);
1427:stk500boot.c  **** 	//*	these can be found in avr/iomxxx.h
1428:stk500boot.c  **** 	PrintHexByte(SIGNATURE_0);
1429:stk500boot.c  **** 	PrintHexByte(SIGNATURE_1);
1430:stk500boot.c  **** 	PrintHexByte(SIGNATURE_2);
1431:stk500boot.c  **** 	PrintNewLine();
1432:stk500boot.c  **** #endif
1433:stk500boot.c  **** 
1434:stk500boot.c  **** 
1435:stk500boot.c  **** #if defined(GET_LOW_FUSE_BITS)
1436:stk500boot.c  **** 	//*	fuse settings
1437:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_FUSE_BYTE_LOW, 0);
1438:stk500boot.c  **** 	fuseByte	=	boot_lock_fuse_bits_get(GET_LOW_FUSE_BITS);
1439:stk500boot.c  **** 	PrintHexByte(fuseByte);
1440:stk500boot.c  **** 	PrintNewLine();
1441:stk500boot.c  **** 
1442:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_FUSE_BYTE_HIGH, 0);
1443:stk500boot.c  **** 	fuseByte	=	boot_lock_fuse_bits_get(GET_HIGH_FUSE_BITS);
1444:stk500boot.c  **** 	PrintHexByte(fuseByte);
1445:stk500boot.c  **** 	PrintNewLine();
1446:stk500boot.c  **** 
1447:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_FUSE_BYTE_EXT, 0);
1448:stk500boot.c  **** 	fuseByte	=	boot_lock_fuse_bits_get(GET_EXTENDED_FUSE_BITS);
1449:stk500boot.c  **** 	PrintHexByte(fuseByte);
1450:stk500boot.c  **** 	PrintNewLine();
1451:stk500boot.c  **** 
1452:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_FUSE_BYTE_LOCK, 0);
1453:stk500boot.c  **** 	fuseByte	=	boot_lock_fuse_bits_get(GET_LOCK_BITS);
1454:stk500boot.c  **** 	PrintHexByte(fuseByte);
1455:stk500boot.c  **** 	PrintNewLine();
1456:stk500boot.c  **** 
1457:stk500boot.c  **** #endif
1458:stk500boot.c  **** 
1459:stk500boot.c  **** }
1460:stk500boot.c  **** 
1461:stk500boot.c  **** 
1462:stk500boot.c  **** //************************************************************************
1463:stk500boot.c  **** static void BlinkLED(void)
1464:stk500boot.c  **** {
1465:stk500boot.c  **** 	PROGLED_DDR		|=	(1<<PROGLED_PIN);
1466:stk500boot.c  **** 	PROGLED_PORT	|=	(1<<PROGLED_PIN);	// active high LED ON
1467:stk500boot.c  **** 
1468:stk500boot.c  **** 	while (!Serial_Available())
1469:stk500boot.c  **** 	{
1470:stk500boot.c  **** 		PROGLED_PORT	&=	~(1<<PROGLED_PIN);	// turn LED off
1471:stk500boot.c  **** 		delay_ms(100);
1472:stk500boot.c  **** 		PROGLED_PORT	|=	(1<<PROGLED_PIN);	// turn LED on
1473:stk500boot.c  **** 		delay_ms(100);
1474:stk500boot.c  **** 	}
1475:stk500boot.c  **** 	recchar();	//	get the char out of the buffer
1476:stk500boot.c  **** }
1477:stk500boot.c  **** 
1478:stk500boot.c  **** enum
1479:stk500boot.c  **** {
1480:stk500boot.c  **** 	kDUMP_FLASH	=	0,
1481:stk500boot.c  **** 	kDUMP_EEPROM,
1482:stk500boot.c  **** 	kDUMP_RAM
1483:stk500boot.c  **** };
1484:stk500boot.c  **** 
1485:stk500boot.c  **** //************************************************************************
1486:stk500boot.c  **** static void	DumpHex(unsigned char dumpWhat, unsigned long startAddress, unsigned char numRows)
1487:stk500boot.c  **** {
1488:stk500boot.c  **** unsigned long	myAddressPointer;
1489:stk500boot.c  **** uint8_t			ii;
1490:stk500boot.c  **** unsigned char	theValue;
1491:stk500boot.c  **** char			asciiDump[18];
1492:stk500boot.c  **** unsigned char	*ramPtr;
1493:stk500boot.c  **** 
1494:stk500boot.c  **** 
1495:stk500boot.c  **** 	ramPtr				=	0;
1496:stk500boot.c  **** 	theValue			=	0;
1497:stk500boot.c  **** 	myAddressPointer	=	startAddress;
1498:stk500boot.c  **** 	while (numRows > 0)
1499:stk500boot.c  **** 	{
1500:stk500boot.c  **** 		if (myAddressPointer > 0x10000)
1501:stk500boot.c  **** 		{
1502:stk500boot.c  **** 			PrintHexByte((myAddressPointer >> 16) & 0x00ff);
1503:stk500boot.c  **** 		}
1504:stk500boot.c  **** 		PrintHexByte((myAddressPointer >> 8) & 0x00ff);
1505:stk500boot.c  **** 		PrintHexByte(myAddressPointer & 0x00ff);
1506:stk500boot.c  **** 		sendchar(0x20);
1507:stk500boot.c  **** 		sendchar('-');
1508:stk500boot.c  **** 		sendchar(0x20);
1509:stk500boot.c  **** 
1510:stk500boot.c  **** 		asciiDump[0]		=	0;
1511:stk500boot.c  **** 		for (ii=0; ii<16; ii++)
1512:stk500boot.c  **** 		{
1513:stk500boot.c  **** 			switch(dumpWhat)
1514:stk500boot.c  **** 			{
1515:stk500boot.c  **** 				case kDUMP_FLASH:
1516:stk500boot.c  **** 				#if (FLASHEND > 0x10000)
1517:stk500boot.c  **** 					theValue	=	pgm_read_byte_far(myAddressPointer);
1518:stk500boot.c  **** 				#else
1519:stk500boot.c  **** 					theValue	=	pgm_read_byte_near(myAddressPointer);
1520:stk500boot.c  **** 				#endif
1521:stk500boot.c  **** 					break;
1522:stk500boot.c  **** 
1523:stk500boot.c  **** 				case kDUMP_EEPROM:
1524:stk500boot.c  **** 					theValue	=	eeprom_read_byte((uint8_t *)(uint16_t)myAddressPointer);
1525:stk500boot.c  **** 					break;
1526:stk500boot.c  **** 
1527:stk500boot.c  **** 				case kDUMP_RAM:
1528:stk500boot.c  **** 					theValue	=	ramPtr[myAddressPointer];
1529:stk500boot.c  **** 					break;
1530:stk500boot.c  **** 
1531:stk500boot.c  **** 			}
1532:stk500boot.c  **** 			PrintHexByte(theValue);
1533:stk500boot.c  **** 			sendchar(0x20);
1534:stk500boot.c  **** 			if ((theValue >= 0x20) && (theValue < 0x7f))
1535:stk500boot.c  **** 			{
1536:stk500boot.c  **** 				asciiDump[ii % 16]	=	theValue;
1537:stk500boot.c  **** 			}
1538:stk500boot.c  **** 			else
1539:stk500boot.c  **** 			{
1540:stk500boot.c  **** 				asciiDump[ii % 16]	=	'.';
1541:stk500boot.c  **** 			}
1542:stk500boot.c  **** 
1543:stk500boot.c  **** 			myAddressPointer++;
1544:stk500boot.c  **** 		}
1545:stk500boot.c  **** 		asciiDump[16]	=	0;
1546:stk500boot.c  **** 		PrintString(asciiDump);
1547:stk500boot.c  **** 		PrintNewLine();
1548:stk500boot.c  **** 
1549:stk500boot.c  **** 		numRows--;
1550:stk500boot.c  **** 	}
1551:stk500boot.c  **** }
1552:stk500boot.c  **** 
1553:stk500boot.c  **** 
1554:stk500boot.c  **** 
1555:stk500boot.c  **** //************************************************************************
1556:stk500boot.c  **** //*	returns amount of extended memory
1557:stk500boot.c  **** static void	EEPROMtest(void)
1558:stk500boot.c  **** {
1559:stk500boot.c  **** int		ii;
1560:stk500boot.c  **** char	theChar;
1561:stk500boot.c  **** char	theEEPROMchar;
1562:stk500boot.c  **** int		errorCount;
1563:stk500boot.c  **** 
1564:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_WriteToEEprom, 0);
1565:stk500boot.c  **** 	PrintNewLine();
1566:stk500boot.c  **** 	ii			=	0;
1567:stk500boot.c  **** #if (FLASHEND > 0x10000)
1568:stk500boot.c  **** 	while (((theChar = pgm_read_byte_far(((uint16_t)gTextMsg_Explorer) + ii)) != '*') && (ii < 512))
1569:stk500boot.c  **** #else
1570:stk500boot.c  **** 	while (((theChar = pgm_read_byte_near(((uint16_t)gTextMsg_Explorer) + ii)) != '*') && (ii < 512))
1571:stk500boot.c  **** #endif
1572:stk500boot.c  **** 	{
1573:stk500boot.c  **** 		eeprom_write_byte((uint8_t *)ii, theChar);
1574:stk500boot.c  **** 		if (theChar == 0)
1575:stk500boot.c  **** 		{
1576:stk500boot.c  **** 			PrintFromPROGMEM(gTextMsg_SPACE, 0);
1577:stk500boot.c  **** 		}
1578:stk500boot.c  **** 		else
1579:stk500boot.c  **** 		{
1580:stk500boot.c  **** 			sendchar(theChar);
1581:stk500boot.c  **** 		}
1582:stk500boot.c  **** 		ii++;
1583:stk500boot.c  **** 	}
1584:stk500boot.c  **** 
1585:stk500boot.c  **** 	//*	no go back through and test
1586:stk500boot.c  **** 	PrintNewLine();
1587:stk500boot.c  **** 	PrintNewLine();
1588:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_ReadingEEprom, 0);
1589:stk500boot.c  **** 	PrintNewLine();
1590:stk500boot.c  **** 	errorCount	=	0;
1591:stk500boot.c  **** 	ii			=	0;
1592:stk500boot.c  **** #if (FLASHEND > 0x10000)
1593:stk500boot.c  **** 	while (((theChar = pgm_read_byte_far((uint16_t)gTextMsg_Explorer + ii)) != '*') && (ii < 512))
1594:stk500boot.c  **** #else
1595:stk500boot.c  **** 	while (((theChar = pgm_read_byte_near((uint16_t)gTextMsg_Explorer + ii)) != '*') && (ii < 512))
1596:stk500boot.c  **** #endif
1597:stk500boot.c  **** 	{
1598:stk500boot.c  **** 		theEEPROMchar	=	eeprom_read_byte((uint8_t *)ii);
1599:stk500boot.c  **** 		if (theEEPROMchar == 0)
1600:stk500boot.c  **** 		{
1601:stk500boot.c  **** 			PrintFromPROGMEM(gTextMsg_SPACE, 0);
1602:stk500boot.c  **** 		}
1603:stk500boot.c  **** 		else
1604:stk500boot.c  **** 		{
1605:stk500boot.c  **** 			sendchar(theEEPROMchar);
1606:stk500boot.c  **** 		}
1607:stk500boot.c  **** 		if (theEEPROMchar != theChar)
1608:stk500boot.c  **** 		{
1609:stk500boot.c  **** 			errorCount++;
1610:stk500boot.c  **** 		}
1611:stk500boot.c  **** 		ii++;
1612:stk500boot.c  **** 	}
1613:stk500boot.c  **** 	PrintNewLine();
1614:stk500boot.c  **** 	PrintNewLine();
1615:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_EEPROMerrorCnt, 0);
1616:stk500boot.c  **** 	PrintDecInt(errorCount, 1);
1617:stk500boot.c  **** 	PrintNewLine();
1618:stk500boot.c  **** 	PrintNewLine();
1619:stk500boot.c  **** 
1620:stk500boot.c  **** 	gEepromIndex	=	0;	//*	set index back to zero for next eeprom dump
1621:stk500boot.c  **** 
1622:stk500boot.c  **** }
1623:stk500boot.c  **** 
1624:stk500boot.c  **** 
1625:stk500boot.c  **** 
1626:stk500boot.c  **** #if (FLASHEND > 0x08000)
1627:stk500boot.c  **** //*	this includes the interrupt names for the monitor portion. There is no longer enough 
1628:stk500boot.c  **** //*	memory to include this
1629:stk500boot.c  **** //	#include	"avrinterruptnames.h"
1630:stk500boot.c  **** //	#ifndef _INTERRUPT_NAMES_DEFINED_
1631:stk500boot.c  **** //		#warning Interrupt vectors not defined
1632:stk500boot.c  **** //	#endif
1633:stk500boot.c  **** #endif
1634:stk500boot.c  **** 
1635:stk500boot.c  **** //************************************************************************
1636:stk500boot.c  **** static void	VectorDisplay(void)
1637:stk500boot.c  **** {
1638:stk500boot.c  **** unsigned long	byte1;
1639:stk500boot.c  **** unsigned long	byte2;
1640:stk500boot.c  **** unsigned long	byte3;
1641:stk500boot.c  **** unsigned long	byte4;
1642:stk500boot.c  **** unsigned long	word1;
1643:stk500boot.c  **** unsigned long	word2;
1644:stk500boot.c  **** int				vectorIndex;
1645:stk500boot.c  **** unsigned long	myMemoryPtr;
1646:stk500boot.c  **** unsigned long	wordMemoryAddress;
1647:stk500boot.c  **** unsigned long	realitiveAddr;
1648:stk500boot.c  **** unsigned long	myFullAddress;
1649:stk500boot.c  **** unsigned long	absoluteAddr;
1650:stk500boot.c  **** #if defined(_INTERRUPT_NAMES_DEFINED_)
1651:stk500boot.c  **** 	long		stringPointer;
1652:stk500boot.c  **** #endif
1653:stk500boot.c  **** 
1654:stk500boot.c  **** 	myMemoryPtr		=	0;
1655:stk500boot.c  **** 	vectorIndex		=	0;
1656:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_CPU_Name, 0);
1657:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_VECTOR_HEADER, 0);
1658:stk500boot.c  **** 	//					 V#   ADDR   op code
1659:stk500boot.c  **** 	//					  1 - 0000 = C3 BB 00 00 rjmp 03BB >000776 RESET
1660:stk500boot.c  **** 	while (vectorIndex < kInterruptVectorCount)
1661:stk500boot.c  **** 	{
1662:stk500boot.c  **** 		wordMemoryAddress	=	myMemoryPtr / 2;
1663:stk500boot.c  **** 		//					 01 - 0000 = 12 34
1664:stk500boot.c  **** 		PrintDecInt(vectorIndex + 1, 2);
1665:stk500boot.c  **** 		sendchar(0x20);
1666:stk500boot.c  **** 		sendchar('-');
1667:stk500boot.c  **** 		sendchar(0x20);
1668:stk500boot.c  **** 		PrintHexByte((wordMemoryAddress >> 8) & 0x00ff);
1669:stk500boot.c  **** 		PrintHexByte((wordMemoryAddress) & 0x00ff);
1670:stk500boot.c  **** 		sendchar(0x20);
1671:stk500boot.c  **** 		sendchar('=');
1672:stk500boot.c  **** 		sendchar(0x20);
1673:stk500boot.c  **** 
1674:stk500boot.c  **** 	
1675:stk500boot.c  **** 		//*	the AVR is LITTLE ENDIAN, swap the byte order
1676:stk500boot.c  **** 	#if (FLASHEND > 0x10000)
1677:stk500boot.c  **** 		byte1	=	pgm_read_byte_far(myMemoryPtr++);
1678:stk500boot.c  **** 		byte2	=	pgm_read_byte_far(myMemoryPtr++);
1679:stk500boot.c  **** 		byte3	=	pgm_read_byte_far(myMemoryPtr++);
1680:stk500boot.c  **** 		byte4	=	pgm_read_byte_far(myMemoryPtr++);
1681:stk500boot.c  **** 	#else
1682:stk500boot.c  **** 		byte1	=	pgm_read_byte_near(myMemoryPtr++);
1683:stk500boot.c  **** 		byte2	=	pgm_read_byte_near(myMemoryPtr++);
1684:stk500boot.c  **** 		byte3	=	pgm_read_byte_near(myMemoryPtr++);
1685:stk500boot.c  **** 		byte4	=	pgm_read_byte_near(myMemoryPtr++);
1686:stk500boot.c  **** 	#endif
1687:stk500boot.c  **** 		word1	=	(byte2 << 8) + byte1;
1688:stk500boot.c  **** 		word2	=	(byte4 << 8) + byte3;
1689:stk500boot.c  **** 
1690:stk500boot.c  **** 
1691:stk500boot.c  **** 		PrintHexByte(byte2);
1692:stk500boot.c  **** 		sendchar(0x20);
1693:stk500boot.c  **** 		PrintHexByte(byte1);
1694:stk500boot.c  **** 		sendchar(0x20);
1695:stk500boot.c  **** 		PrintHexByte(byte4);
1696:stk500boot.c  **** 		sendchar(0x20);
1697:stk500boot.c  **** 		PrintHexByte(byte3);
1698:stk500boot.c  **** 		sendchar(0x20);
1699:stk500boot.c  **** 	
1700:stk500boot.c  **** 		if (word1 == 0xffff)
1701:stk500boot.c  **** 		{
1702:stk500boot.c  **** 			PrintFromPROGMEM(gTextMsg_noVector, 0);
1703:stk500boot.c  **** 		}
1704:stk500boot.c  **** 		else if ((word1 & 0xc000) == 0xc000)
1705:stk500boot.c  **** 		{
1706:stk500boot.c  **** 			//*	rjmp instruction
1707:stk500boot.c  **** 			realitiveAddr	=	word1 & 0x3FFF;
1708:stk500boot.c  **** 			absoluteAddr	=	wordMemoryAddress + realitiveAddr;	//*	add the offset to the current address
1709:stk500boot.c  **** 			absoluteAddr	=	absoluteAddr << 1;					//*	multiply by 2 for byte address
1710:stk500boot.c  **** 
1711:stk500boot.c  **** 			PrintFromPROGMEM(gTextMsg_rjmp, 0);
1712:stk500boot.c  **** 			PrintHexByte((realitiveAddr >> 8) & 0x00ff);
1713:stk500boot.c  **** 			PrintHexByte((realitiveAddr) & 0x00ff);
1714:stk500boot.c  **** 			sendchar(0x20);
1715:stk500boot.c  **** 			sendchar('>');
1716:stk500boot.c  **** 			PrintHexByte((absoluteAddr >> 16) & 0x00ff);
1717:stk500boot.c  **** 			PrintHexByte((absoluteAddr >> 8) & 0x00ff);
1718:stk500boot.c  **** 			PrintHexByte((absoluteAddr) & 0x00ff);
1719:stk500boot.c  **** 	
1720:stk500boot.c  **** 		}
1721:stk500boot.c  **** 		else if ((word1 & 0xfE0E) == 0x940c)
1722:stk500boot.c  **** 		{
1723:stk500boot.c  **** 			//*	jmp instruction, this is REALLY complicated, refer to the instruction manual (JMP)
1724:stk500boot.c  **** 			myFullAddress	=	((byte1 & 0x01) << 16) +
1725:stk500boot.c  **** 								((byte1 & 0xf0) << 17) +
1726:stk500boot.c  **** 								((byte2 & 0x01) << 21) +
1727:stk500boot.c  **** 								word2;
1728:stk500boot.c  **** 							
1729:stk500boot.c  **** 			absoluteAddr	=	myFullAddress << 1;
1730:stk500boot.c  **** 							
1731:stk500boot.c  **** 			PrintFromPROGMEM(gTextMsg_jmp, 0);
1732:stk500boot.c  **** 			PrintHexByte((myFullAddress >> 16) & 0x00ff);
1733:stk500boot.c  **** 			PrintHexByte((myFullAddress >> 8) & 0x00ff);
1734:stk500boot.c  **** 			PrintHexByte((myFullAddress) & 0x00ff);
1735:stk500boot.c  **** 			sendchar(0x20);
1736:stk500boot.c  **** 			sendchar('>');
1737:stk500boot.c  **** 			PrintHexByte((absoluteAddr >> 16) & 0x00ff);
1738:stk500boot.c  **** 			PrintHexByte((absoluteAddr >> 8) & 0x00ff);
1739:stk500boot.c  **** 			PrintHexByte((absoluteAddr) & 0x00ff);
1740:stk500boot.c  **** 		}
1741:stk500boot.c  **** 
1742:stk500boot.c  **** 	#if defined(_INTERRUPT_NAMES_DEFINED_)
1743:stk500boot.c  **** 		sendchar(0x20);
1744:stk500boot.c  **** 	#if (FLASHEND > 0x10000)
1745:stk500boot.c  **** 		stringPointer	=	pgm_read_word_far(&(gInterruptNameTable[vectorIndex]));
1746:stk500boot.c  **** 	#else
1747:stk500boot.c  **** 		stringPointer	=	pgm_read_word_near(&(gInterruptNameTable[vectorIndex]));
1748:stk500boot.c  **** 	#endif
1749:stk500boot.c  **** 		PrintFromPROGMEM((char *)stringPointer, 0);
1750:stk500boot.c  **** 	#endif
1751:stk500boot.c  **** 		PrintNewLine();
1752:stk500boot.c  **** 
1753:stk500boot.c  **** 		vectorIndex++;
1754:stk500boot.c  **** 	}
1755:stk500boot.c  **** }
1756:stk500boot.c  **** 
1757:stk500boot.c  **** //************************************************************************
1758:stk500boot.c  **** static void	PrintAvailablePort(char thePortLetter)
1759:stk500boot.c  **** {
 247               		.loc 1 1759 0
 248               		.cfi_startproc
 249               	.LVL13:
 250 000e CF93      		push r28
 251               	.LCFI2:
 252               		.cfi_def_cfa_offset 4
 253               		.cfi_offset 28, -3
 254               	/* prologue: function */
 255               	/* frame size = 0 */
 256               	/* stack size = 1 */
 257               	.L__stack_usage = 1
 258 0010 C82F      		mov r28,r24
1760:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_PORT, 0);
 259               		.loc 1 1760 0
 260 0012 80E0      		ldi r24,lo8(gTextMsg_PORT)
 261 0014 90E0      		ldi r25,hi8(gTextMsg_PORT)
 262               	.LVL14:
 263 0016 60E0      		ldi r22,lo8(0)
 264 0018 0E94 0000 		call PrintFromPROGMEM
1761:stk500boot.c  **** 	sendchar(thePortLetter);
 265               		.loc 1 1761 0
 266 001c 8C2F      		mov r24,r28
 267 001e 0E94 0000 		call sendchar
1762:stk500boot.c  **** 	PrintNewLine();
 268               		.loc 1 1762 0
 269 0022 0E94 0000 		call PrintNewLine
 270               	/* epilogue start */
1763:stk500boot.c  **** }
 271               		.loc 1 1763 0
 272 0026 CF91      		pop r28
 273               	.LVL15:
 274 0028 0895      		ret
 275               		.cfi_endproc
 276               	.LFE25:
 278               		.text
 279               	.global	PrintFromPROGMEMln
 281               	PrintFromPROGMEMln:
 282               	.LFB16:
1329:stk500boot.c  **** {
 283               		.loc 1 1329 0
 284               		.cfi_startproc
 285               	.LVL16:
 286               	/* prologue: function */
 287               	/* frame size = 0 */
 288               	/* stack size = 0 */
 289               	.L__stack_usage = 0
1330:stk500boot.c  **** 	PrintFromPROGMEM(dataPtr, offset);
 290               		.loc 1 1330 0
 291 006c 0E94 0000 		call PrintFromPROGMEM
 292               	.LVL17:
1332:stk500boot.c  **** 	PrintNewLine();
 293               		.loc 1 1332 0
 294 0070 0E94 0000 		call PrintNewLine
 295               	/* epilogue start */
1333:stk500boot.c  **** }
 296               		.loc 1 1333 0
 297 0074 0895      		ret
 298               		.cfi_endproc
 299               	.LFE16:
 301               	.global	PrintString
 303               	PrintString:
 304               	.LFB17:
1338:stk500boot.c  **** {
 305               		.loc 1 1338 0
 306               		.cfi_startproc
 307               	.LVL18:
 308 0076 CF93      		push r28
 309               	.LCFI3:
 310               		.cfi_def_cfa_offset 4
 311               		.cfi_offset 28, -3
 312 0078 DF93      		push r29
 313               	.LCFI4:
 314               		.cfi_def_cfa_offset 5
 315               		.cfi_offset 29, -4
 316               	/* prologue: function */
 317               	/* frame size = 0 */
 318               	/* stack size = 2 */
 319               	.L__stack_usage = 2
 320               	.LVL19:
1338:stk500boot.c  **** {
 321               		.loc 1 1338 0
 322 007a EC01      		movw r28,r24
 323               	.LVL20:
 324               	.L19:
1346:stk500boot.c  **** 		theChar	=	textString[ii];
 325               		.loc 1 1346 0
 326 007c 8991      		ld r24,Y+
 327               	.LVL21:
1347:stk500boot.c  **** 		if (theChar != 0)
 328               		.loc 1 1347 0
 329 007e 8823      		tst r24
 330 0080 01F0      		breq .L17
1349:stk500boot.c  **** 			sendchar(theChar);
 331               		.loc 1 1349 0
 332 0082 0E94 0000 		call sendchar
 333               	.LVL22:
 334 0086 00C0      		rjmp .L19
 335               	.LVL23:
 336               	.L17:
 337               	/* epilogue start */
1353:stk500boot.c  **** }
 338               		.loc 1 1353 0
 339 0088 DF91      		pop r29
 340 008a CF91      		pop r28
 341 008c 0895      		ret
 342               		.cfi_endproc
 343               	.LFE17:
 345               	.global	PrintHexByte
 347               	PrintHexByte:
 348               	.LFB18:
1357:stk500boot.c  **** {
 349               		.loc 1 1357 0
 350               		.cfi_startproc
 351               	.LVL24:
 352 008e CF93      		push r28
 353               	.LCFI5:
 354               		.cfi_def_cfa_offset 4
 355               		.cfi_offset 28, -3
 356               	/* prologue: function */
 357               	/* frame size = 0 */
 358               	/* stack size = 1 */
 359               	.L__stack_usage = 1
 360 0090 C82F      		mov r28,r24
1360:stk500boot.c  **** 	theChar	=	0x30 + ((theByte >> 4) & 0x0f);
 361               		.loc 1 1360 0
 362 0092 982F      		mov r25,r24
 363 0094 9295      		swap r25
 364 0096 9F70      		andi r25,lo8(15)
 365 0098 892F      		mov r24,r25
 366               	.LVL25:
 367 009a 805D      		subi r24,lo8(-(48))
 368               	.LVL26:
1361:stk500boot.c  **** 	if (theChar > 0x39)
 369               		.loc 1 1361 0
 370 009c 8A33      		cpi r24,lo8(58)
 371 009e 00F0      		brlo .L21
1363:stk500boot.c  **** 		theChar	+=	7;
 372               		.loc 1 1363 0
 373 00a0 895F      		subi r24,lo8(-(7))
 374               	.LVL27:
 375               	.L21:
1365:stk500boot.c  **** 	sendchar(theChar );
 376               		.loc 1 1365 0
 377 00a2 0E94 0000 		call sendchar
 378               	.LVL28:
1367:stk500boot.c  **** 	theChar	=	0x30 + (theByte & 0x0f);
 379               		.loc 1 1367 0
 380 00a6 CF70      		andi r28,lo8(15)
 381               	.LVL29:
 382 00a8 8C2F      		mov r24,r28
 383 00aa 805D      		subi r24,lo8(-(48))
 384               	.LVL30:
1368:stk500boot.c  **** 	if (theChar > 0x39)
 385               		.loc 1 1368 0
 386 00ac 8A33      		cpi r24,lo8(58)
 387 00ae 00F0      		brlo .L22
1370:stk500boot.c  **** 		theChar	+=	7;
 388               		.loc 1 1370 0
 389 00b0 895F      		subi r24,lo8(-(7))
 390               	.LVL31:
 391               	.L22:
1372:stk500boot.c  **** 	sendchar(theChar );
 392               		.loc 1 1372 0
 393 00b2 0E94 0000 		call sendchar
 394               	.LVL32:
 395               	/* epilogue start */
1373:stk500boot.c  **** }
 396               		.loc 1 1373 0
 397 00b6 CF91      		pop r28
 398 00b8 0895      		ret
 399               		.cfi_endproc
 400               	.LFE18:
 402               		.section	.text.unlikely
 404               	DumpHex.constprop.0:
 405               	.LFB30:
1486:stk500boot.c  **** static void	DumpHex(unsigned char dumpWhat, unsigned long startAddress, unsigned char numRows)
 406               		.loc 1 1486 0
 407               		.cfi_startproc
 408               	.LVL33:
 409 002a 3F92      		push r3
 410               	.LCFI6:
 411               		.cfi_def_cfa_offset 4
 412               		.cfi_offset 3, -3
 413 002c 4F92      		push r4
 414               	.LCFI7:
 415               		.cfi_def_cfa_offset 5
 416               		.cfi_offset 4, -4
 417 002e 5F92      		push r5
 418               	.LCFI8:
 419               		.cfi_def_cfa_offset 6
 420               		.cfi_offset 5, -5
 421 0030 6F92      		push r6
 422               	.LCFI9:
 423               		.cfi_def_cfa_offset 7
 424               		.cfi_offset 6, -6
 425 0032 7F92      		push r7
 426               	.LCFI10:
 427               		.cfi_def_cfa_offset 8
 428               		.cfi_offset 7, -7
 429 0034 8F92      		push r8
 430               	.LCFI11:
 431               		.cfi_def_cfa_offset 9
 432               		.cfi_offset 8, -8
 433 0036 9F92      		push r9
 434               	.LCFI12:
 435               		.cfi_def_cfa_offset 10
 436               		.cfi_offset 9, -9
 437 0038 AF92      		push r10
 438               	.LCFI13:
 439               		.cfi_def_cfa_offset 11
 440               		.cfi_offset 10, -10
 441 003a BF92      		push r11
 442               	.LCFI14:
 443               		.cfi_def_cfa_offset 12
 444               		.cfi_offset 11, -11
 445 003c CF92      		push r12
 446               	.LCFI15:
 447               		.cfi_def_cfa_offset 13
 448               		.cfi_offset 12, -12
 449 003e DF92      		push r13
 450               	.LCFI16:
 451               		.cfi_def_cfa_offset 14
 452               		.cfi_offset 13, -13
 453 0040 EF92      		push r14
 454               	.LCFI17:
 455               		.cfi_def_cfa_offset 15
 456               		.cfi_offset 14, -14
 457 0042 FF92      		push r15
 458               	.LCFI18:
 459               		.cfi_def_cfa_offset 16
 460               		.cfi_offset 15, -15
 461 0044 0F93      		push r16
 462               	.LCFI19:
 463               		.cfi_def_cfa_offset 17
 464               		.cfi_offset 16, -16
 465 0046 1F93      		push r17
 466               	.LCFI20:
 467               		.cfi_def_cfa_offset 18
 468               		.cfi_offset 17, -17
 469 0048 CF93      		push r28
 470               	.LCFI21:
 471               		.cfi_def_cfa_offset 19
 472               		.cfi_offset 28, -18
 473 004a DF93      		push r29
 474               	.LCFI22:
 475               		.cfi_def_cfa_offset 20
 476               		.cfi_offset 29, -19
 477 004c CDB7      		in r28,__SP_L__
 478 004e DEB7      		in r29,__SP_H__
 479 0050 6297      		sbiw r28,18
 480               	.LCFI23:
 481               		.cfi_def_cfa 28, 38
 482 0052 0FB6      		in __tmp_reg__,__SREG__
 483 0054 F894      		cli
 484 0056 DEBF      		out __SP_H__,r29
 485 0058 0FBE      		out __SREG__,__tmp_reg__
 486 005a CDBF      		out __SP_L__,r28
 487               	/* prologue: function */
 488               	/* frame size = 18 */
 489               	/* stack size = 35 */
 490               	.L__stack_usage = 35
 491 005c 582E      		mov r5,r24
 492 005e 6A01      		movw r12,r20
 493 0060 7B01      		movw r14,r22
 494               	.LVL34:
1486:stk500boot.c  **** static void	DumpHex(unsigned char dumpWhat, unsigned long startAddress, unsigned char numRows)
 495               		.loc 1 1486 0
 496 0062 10E1      		ldi r17,lo8(16)
1496:stk500boot.c  **** 	theValue			=	0;
 497               		.loc 1 1496 0
 498 0064 4424      		clr r4
1540:stk500boot.c  **** 				asciiDump[ii % 16]	=	'.';
 499               		.loc 1 1540 0
 500 0066 8EE2      		ldi r24,lo8(46)
 501 0068 382E      		mov r3,r24
 502               	.LVL35:
 503               	.L32:
1500:stk500boot.c  **** 		if (myAddressPointer > 0x10000)
 504               		.loc 1 1500 0
 505 006a 81E0      		ldi r24,lo8(65537)
 506 006c C816      		cp r12,r24
 507 006e 80E0      		ldi r24,hi8(65537)
 508 0070 D806      		cpc r13,r24
 509 0072 81E0      		ldi r24,hlo8(65537)
 510 0074 E806      		cpc r14,r24
 511 0076 80E0      		ldi r24,hhi8(65537)
 512 0078 F806      		cpc r15,r24
 513 007a 00F0      		brlo .L24
1502:stk500boot.c  **** 			PrintHexByte((myAddressPointer >> 16) & 0x00ff);
 514               		.loc 1 1502 0
 515 007c 8E2D      		mov r24,r14
 516 007e 0E94 0000 		call PrintHexByte
 517               	.L24:
1504:stk500boot.c  **** 		PrintHexByte((myAddressPointer >> 8) & 0x00ff);
 518               		.loc 1 1504 0
 519 0082 8D2D      		mov r24,r13
 520 0084 0E94 0000 		call PrintHexByte
1505:stk500boot.c  **** 		PrintHexByte(myAddressPointer & 0x00ff);
 521               		.loc 1 1505 0
 522 0088 8C2D      		mov r24,r12
 523 008a 0E94 0000 		call PrintHexByte
1506:stk500boot.c  **** 		sendchar(0x20);
 524               		.loc 1 1506 0
 525 008e 80E2      		ldi r24,lo8(32)
 526 0090 0E94 0000 		call sendchar
1507:stk500boot.c  **** 		sendchar('-');
 527               		.loc 1 1507 0
 528 0094 8DE2      		ldi r24,lo8(45)
 529 0096 0E94 0000 		call sendchar
1508:stk500boot.c  **** 		sendchar(0x20);
 530               		.loc 1 1508 0
 531 009a 80E2      		ldi r24,lo8(32)
 532 009c 0E94 0000 		call sendchar
1510:stk500boot.c  **** 		asciiDump[0]		=	0;
 533               		.loc 1 1510 0
 534 00a0 1982      		std Y+1,__zero_reg__
 535               	.LVL36:
 536 00a2 3E01      		movw r6,r28
 537 00a4 0894      		sec
 538 00a6 611C      		adc r6,__zero_reg__
 539 00a8 711C      		adc r7,__zero_reg__
 540 00aa 4601      		movw r8,r12
 541 00ac 5701      		movw r10,r14
 542 00ae 00E1      		ldi r16,lo8(16)
 543               	.LVL37:
 544               	.L31:
1513:stk500boot.c  **** 			switch(dumpWhat)
 545               		.loc 1 1513 0
 546 00b0 91E0      		ldi r25,lo8(1)
 547 00b2 5916      		cp r5,r25
 548 00b4 01F0      		breq .L27
 549 00b6 5916      		cp r5,r25
 550 00b8 00F0      		brlo .L26
 551 00ba A2E0      		ldi r26,lo8(2)
 552 00bc 5A16      		cp r5,r26
 553 00be 01F4      		brne .L25
 554 00c0 00C0      		rjmp .L35
 555               	.L26:
 556               	.LVL38:
 557               	.LBB58:
1517:stk500boot.c  **** 					theValue	=	pgm_read_byte_far(myAddressPointer);
 558               		.loc 1 1517 0
 559               	/* #APP */
 560               	 ;  1517 "stk500boot.c" 1
 561 00c2 ABBE      		out 59, r10
 562 00c4 F401      		movw r30, r8
 563 00c6 4790      		elpm r4, Z+
 564               		
 565               	 ;  0 "" 2
 566               	.LVL39:
 567               	/* #NOAPP */
 568 00c8 00C0      		rjmp .L25
 569               	.LVL40:
 570               	.L27:
 571               	.LBE58:
1524:stk500boot.c  **** 					theValue	=	eeprom_read_byte((uint8_t *)(uint16_t)myAddressPointer);
 572               		.loc 1 1524 0
 573 00ca C401      		movw r24,r8
 574 00cc 0E94 0000 		call __eerd_byte_m256rfr2
 575 00d0 482E      		mov r4,r24
 576               	.LVL41:
 577 00d2 00C0      		rjmp .L25
 578               	.LVL42:
 579               	.L35:
1528:stk500boot.c  **** 					theValue	=	ramPtr[myAddressPointer];
 580               		.loc 1 1528 0
 581 00d4 F401      		movw r30,r8
 582 00d6 4080      		ld r4,Z
 583               	.LVL43:
 584               	.L25:
1532:stk500boot.c  **** 			PrintHexByte(theValue);
 585               		.loc 1 1532 0
 586 00d8 842D      		mov r24,r4
 587 00da 0E94 0000 		call PrintHexByte
1533:stk500boot.c  **** 			sendchar(0x20);
 588               		.loc 1 1533 0
 589 00de 80E2      		ldi r24,lo8(32)
 590 00e0 0E94 0000 		call sendchar
1534:stk500boot.c  **** 			if ((theValue >= 0x20) && (theValue < 0x7f))
 591               		.loc 1 1534 0
 592 00e4 842D      		mov r24,r4
 593 00e6 8052      		subi r24,lo8(-(-32))
 594 00e8 8F35      		cpi r24,lo8(95)
 595 00ea 00F4      		brsh .L29
1536:stk500boot.c  **** 				asciiDump[ii % 16]	=	theValue;
 596               		.loc 1 1536 0
 597 00ec F301      		movw r30,r6
 598 00ee 4082      		st Z,r4
 599 00f0 00C0      		rjmp .L30
 600               	.L29:
1540:stk500boot.c  **** 				asciiDump[ii % 16]	=	'.';
 601               		.loc 1 1540 0
 602 00f2 D301      		movw r26,r6
 603 00f4 3C92      		st X,r3
 604               	.L30:
1543:stk500boot.c  **** 			myAddressPointer++;
 605               		.loc 1 1543 0
 606 00f6 0894      		sec
 607 00f8 811C      		adc r8,__zero_reg__
 608 00fa 911C      		adc r9,__zero_reg__
 609 00fc A11C      		adc r10,__zero_reg__
 610 00fe B11C      		adc r11,__zero_reg__
 611               	.LVL44:
 612 0100 0150      		subi r16,lo8(-(-1))
 613 0102 0894      		sec
 614 0104 611C      		adc r6,__zero_reg__
 615 0106 711C      		adc r7,__zero_reg__
1511:stk500boot.c  **** 		for (ii=0; ii<16; ii++)
 616               		.loc 1 1511 0
 617 0108 0023      		tst r16
 618 010a 01F4      		brne .L31
 619 010c 80E1      		ldi r24,lo8(16)
 620 010e 90E0      		ldi r25,hi8(16)
 621 0110 A0E0      		ldi r26,hlo8(16)
 622 0112 B0E0      		ldi r27,hhi8(16)
 623 0114 C80E      		add r12,r24
 624 0116 D91E      		adc r13,r25
 625 0118 EA1E      		adc r14,r26
 626 011a FB1E      		adc r15,r27
1545:stk500boot.c  **** 		asciiDump[16]	=	0;
 627               		.loc 1 1545 0
 628 011c 198A      		std Y+17,__zero_reg__
1546:stk500boot.c  **** 		PrintString(asciiDump);
 629               		.loc 1 1546 0
 630 011e CE01      		movw r24,r28
 631 0120 0196      		adiw r24,1
 632 0122 0E94 0000 		call PrintString
1547:stk500boot.c  **** 		PrintNewLine();
 633               		.loc 1 1547 0
 634 0126 0E94 0000 		call PrintNewLine
 635               	.LVL45:
 636 012a 1150      		subi r17,lo8(-(-1))
1498:stk500boot.c  **** 	while (numRows > 0)
 637               		.loc 1 1498 0
 638 012c 01F0      		breq .+2
 639 012e 00C0      		rjmp .L32
 640               	/* epilogue start */
1551:stk500boot.c  **** }
 641               		.loc 1 1551 0
 642 0130 6296      		adiw r28,18
 643 0132 0FB6      		in __tmp_reg__,__SREG__
 644 0134 F894      		cli
 645 0136 DEBF      		out __SP_H__,r29
 646 0138 0FBE      		out __SREG__,__tmp_reg__
 647 013a CDBF      		out __SP_L__,r28
 648 013c DF91      		pop r29
 649 013e CF91      		pop r28
 650 0140 1F91      		pop r17
 651 0142 0F91      		pop r16
 652 0144 FF90      		pop r15
 653 0146 EF90      		pop r14
 654 0148 DF90      		pop r13
 655 014a CF90      		pop r12
 656               	.LVL46:
 657 014c BF90      		pop r11
 658 014e AF90      		pop r10
 659 0150 9F90      		pop r9
 660 0152 8F90      		pop r8
 661 0154 7F90      		pop r7
 662 0156 6F90      		pop r6
 663 0158 5F90      		pop r5
 664               	.LVL47:
 665 015a 4F90      		pop r4
 666               	.LVL48:
 667 015c 3F90      		pop r3
 668 015e 0895      		ret
 669               		.cfi_endproc
 670               	.LFE30:
 672               		.text
 673               	.global	PrintDecInt
 675               	PrintDecInt:
 676               	.LFB19:
1377:stk500boot.c  **** {
 677               		.loc 1 1377 0
 678               		.cfi_startproc
 679               	.LVL49:
 680 00ba 0F93      		push r16
 681               	.LCFI24:
 682               		.cfi_def_cfa_offset 4
 683               		.cfi_offset 16, -3
 684 00bc 1F93      		push r17
 685               	.LCFI25:
 686               		.cfi_def_cfa_offset 5
 687               		.cfi_offset 17, -4
 688 00be CF93      		push r28
 689               	.LCFI26:
 690               		.cfi_def_cfa_offset 6
 691               		.cfi_offset 28, -5
 692 00c0 DF93      		push r29
 693               	.LCFI27:
 694               		.cfi_def_cfa_offset 7
 695               		.cfi_offset 29, -6
 696               	/* prologue: function */
 697               	/* frame size = 0 */
 698               	/* stack size = 4 */
 699               	.L__stack_usage = 4
 700 00c2 EC01      		movw r28,r24
 701 00c4 8B01      		movw r16,r22
 702               	.LVL50:
1383:stk500boot.c  **** 	if ((myNumber > 100) || (digitCnt >= 3))
 703               		.loc 1 1383 0
 704 00c6 8536      		cpi r24,101
 705 00c8 9105      		cpc r25,__zero_reg__
 706 00ca 04F4      		brge .L37
 707               	.LVL51:
1383:stk500boot.c  **** 	if ((myNumber > 100) || (digitCnt >= 3))
 708               		.loc 1 1383 0 is_stmt 0 discriminator 1
 709 00cc 6330      		cpi r22,3
 710 00ce 7105      		cpc r23,__zero_reg__
 711 00d0 04F0      		brlt .L38
 712               	.L37:
 713               	.LVL52:
1385:stk500boot.c  **** 		theChar		=	0x30 + myNumber / 100;
 714               		.loc 1 1385 0 is_stmt 1
 715 00d2 CE01      		movw r24,r28
 716               	.LVL53:
 717 00d4 64E6      		ldi r22,lo8(100)
 718 00d6 70E0      		ldi r23,hi8(100)
 719 00d8 0E94 0000 		call __divmodhi4
1386:stk500boot.c  **** 		sendchar(theChar );
 720               		.loc 1 1386 0
 721 00dc 862F      		mov r24,r22
 722 00de 805D      		subi r24,lo8(-(48))
 723 00e0 0E94 0000 		call sendchar
 724               	.LVL54:
 725               	.L38:
1389:stk500boot.c  **** 	if ((myNumber > 10) || (digitCnt >= 2))
 726               		.loc 1 1389 0
 727 00e4 CB30      		cpi r28,11
 728 00e6 D105      		cpc r29,__zero_reg__
 729 00e8 04F4      		brge .L39
1389:stk500boot.c  **** 	if ((myNumber > 10) || (digitCnt >= 2))
 730               		.loc 1 1389 0 is_stmt 0 discriminator 1
 731 00ea 0230      		cpi r16,2
 732 00ec 1105      		cpc r17,__zero_reg__
 733 00ee 04F0      		brlt .L40
 734               	.L39:
 735               	.LVL55:
1391:stk500boot.c  **** 		theChar	=	0x30  + ((myNumber % 100) / 10 );
 736               		.loc 1 1391 0 is_stmt 1
 737 00f0 CE01      		movw r24,r28
 738 00f2 64E6      		ldi r22,lo8(100)
 739 00f4 70E0      		ldi r23,hi8(100)
 740 00f6 0E94 0000 		call __divmodhi4
 741 00fa 6AE0      		ldi r22,lo8(10)
 742 00fc 70E0      		ldi r23,hi8(10)
 743 00fe 0E94 0000 		call __divmodhi4
1392:stk500boot.c  **** 		sendchar(theChar );
 744               		.loc 1 1392 0
 745 0102 862F      		mov r24,r22
 746 0104 805D      		subi r24,lo8(-(48))
 747 0106 0E94 0000 		call sendchar
 748               	.LVL56:
 749               	.L40:
1394:stk500boot.c  **** 	theChar	=	0x30 + (myNumber % 10);
 750               		.loc 1 1394 0
 751 010a CE01      		movw r24,r28
 752 010c 6AE0      		ldi r22,lo8(10)
 753 010e 70E0      		ldi r23,hi8(10)
 754 0110 0E94 0000 		call __divmodhi4
1395:stk500boot.c  **** 	sendchar(theChar );
 755               		.loc 1 1395 0
 756 0114 805D      		subi r24,lo8(-(48))
 757 0116 0E94 0000 		call sendchar
 758               	/* epilogue start */
1396:stk500boot.c  **** }
 759               		.loc 1 1396 0
 760 011a DF91      		pop r29
 761 011c CF91      		pop r28
 762               	.LVL57:
 763 011e 1F91      		pop r17
 764 0120 0F91      		pop r16
 765               	.LVL58:
 766 0122 0895      		ret
 767               		.cfi_endproc
 768               	.LFE19:
 770               		.section	.text.startup,"ax",@progbits
 771               	.global	main
 773               	main:
 774               	.LFB13:
 543:stk500boot.c  **** {
 775               		.loc 1 543 0
 776               		.cfi_startproc
 777 0000 CF93      		push r28
 778               	.LCFI28:
 779               		.cfi_def_cfa_offset 4
 780               		.cfi_offset 28, -3
 781 0002 DF93      		push r29
 782               	.LCFI29:
 783               		.cfi_def_cfa_offset 5
 784               		.cfi_offset 29, -4
 785 0004 CDB7      		in r28,__SP_L__
 786 0006 DEB7      		in r29,__SP_H__
 787 0008 C054      		subi r28,lo8(-(-320))
 788 000a D140      		sbci r29,hi8(-(-320))
 789               	.LCFI30:
 790               		.cfi_def_cfa 28, 325
 791 000c 0FB6      		in __tmp_reg__,__SREG__
 792 000e F894      		cli
 793 0010 DEBF      		out __SP_H__,r29
 794 0012 0FBE      		out __SREG__,__tmp_reg__
 795 0014 CDBF      		out __SP_L__,r28
 796               	/* prologue: function */
 797               	/* frame size = 320 */
 798               	/* stack size = 322 */
 799               	.L__stack_usage = 322
 800               	.LVL59:
 564:stk500boot.c  **** 	asm volatile ( ".set __stack, %0" :: "i" (RAMEND) );
 801               		.loc 1 564 0
 802               	/* #APP */
 803               	 ;  564 "stk500boot.c" 1
 804               		.set __stack, -32257
 805               	 ;  0 "" 2
 565:stk500boot.c  **** 	asm volatile ( "ldi	16, %0" :: "i" (RAMEND >> 8) );
 806               		.loc 1 565 0
 807               	 ;  565 "stk500boot.c" 1
 808 0016 01E8      		ldi	16, 129
 809               	 ;  0 "" 2
 566:stk500boot.c  **** 	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_HI_ADDR) );
 810               		.loc 1 566 0
 811               	 ;  566 "stk500boot.c" 1
 812 0018 0EBF      		out 62,16
 813               	 ;  0 "" 2
 567:stk500boot.c  **** 	asm volatile ( "ldi	16, %0" :: "i" (RAMEND & 0x0ff) );
 814               		.loc 1 567 0
 815               	 ;  567 "stk500boot.c" 1
 816 001a 0FEF      		ldi	16, 255
 817               	 ;  0 "" 2
 568:stk500boot.c  **** 	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_LO_ADDR) );
 818               		.loc 1 568 0
 819               	 ;  568 "stk500boot.c" 1
 820 001c 0DBF      		out 61,16
 821               	 ;  0 "" 2
 575:stk500boot.c  **** 	mcuStatusReg	=	MCUSR;
 822               		.loc 1 575 0
 823               	/* #NOAPP */
 824 001e 94B7      		in r25,84-32
 825               	.LVL60:
 577:stk500boot.c  **** 	__asm__ __volatile__ ("cli");
 826               		.loc 1 577 0
 827               	/* #APP */
 828               	 ;  577 "stk500boot.c" 1
 829 0020 F894      		cli
 830               	 ;  0 "" 2
 578:stk500boot.c  **** 	__asm__ __volatile__ ("wdr");
 831               		.loc 1 578 0
 832               	 ;  578 "stk500boot.c" 1
 833 0022 A895      		wdr
 834               	 ;  0 "" 2
 579:stk500boot.c  **** 	MCUSR	=	0;
 835               		.loc 1 579 0
 836               	/* #NOAPP */
 837 0024 14BE      		out 84-32,__zero_reg__
 580:stk500boot.c  **** 	WDTCSR	|=	_BV(WDCE) | _BV(WDE);
 838               		.loc 1 580 0
 839 0026 8091 6000 		lds r24,96
 840 002a 8861      		ori r24,lo8(24)
 841 002c 8093 6000 		sts 96,r24
 581:stk500boot.c  **** 	WDTCSR	=	0;
 842               		.loc 1 581 0
 843 0030 1092 6000 		sts 96,__zero_reg__
 582:stk500boot.c  **** 	__asm__ __volatile__ ("sei");
 844               		.loc 1 582 0
 845               	/* #APP */
 846               	 ;  582 "stk500boot.c" 1
 847 0034 7894      		sei
 848               	 ;  0 "" 2
 584:stk500boot.c  **** 	if (mcuStatusReg & _BV(WDRF))
 849               		.loc 1 584 0
 850               	/* #NOAPP */
 851 0036 93FF      		sbrs r25,3
 852 0038 00C0      		rjmp .L42
 586:stk500boot.c  **** 		app_start();
 853               		.loc 1 586 0
 854 003a E091 0000 		lds r30,app_start
 855 003e F091 0000 		lds r31,app_start+1
 856 0042 1995      		eicall
 857               	.LVL61:
 858               	.L42:
 608:stk500boot.c  **** 	PROGLED_DDR		|=	(1<<PROGLED_PIN);
 859               		.loc 1 608 0
 860 0044 579A      		sbi 42-32,7
 610:stk500boot.c  **** 	PROGLED_PORT	|=	(1<<PROGLED_PIN);	// active high LED ON
 861               		.loc 1 610 0
 862 0046 5F9A      		sbi 43-32,7
 630:stk500boot.c  **** 	UART_BAUD_RATE_LOW	=	UART_BAUD_SELECT(BAUDRATE,F_CPU);
 863               		.loc 1 630 0
 864 0048 80E1      		ldi r24,lo8(16)
 865 004a 8093 C400 		sts 196,r24
 631:stk500boot.c  **** 	UART_CONTROL_REG	=	(1 << UART_ENABLE_RECEIVER) | (1 << UART_ENABLE_TRANSMITTER);
 866               		.loc 1 631 0
 867 004e 88E1      		ldi r24,lo8(24)
 868 0050 8093 C100 		sts 193,r24
 633:stk500boot.c  **** 	asm volatile ("nop");			// wait until port has changed
 869               		.loc 1 633 0
 870               	/* #APP */
 871               	 ;  633 "stk500boot.c" 1
 872 0054 0000      		nop
 873               	 ;  0 "" 2
 592:stk500boot.c  **** 	boot_timer	=	0;
 874               		.loc 1 592 0
 875               	/* #NOAPP */
 876 0056 CC24      		clr r12
 877 0058 DD24      		clr r13
 878 005a 7601      		movw r14,r12
 663:stk500boot.c  **** 			if ((boot_timer % _BLINK_LOOP_COUNT_) == 0)
 879               		.loc 1 663 0
 880 005c A7EC      		ldi r26,lo8(7111)
 881 005e 8A2E      		mov r8,r26
 882 0060 ABE1      		ldi r26,hi8(7111)
 883 0062 9A2E      		mov r9,r26
 884 0064 A12C      		mov r10,__zero_reg__
 885 0066 B12C      		mov r11,__zero_reg__
 543:stk500boot.c  **** {
 886               		.loc 1 543 0
 887 0068 00E0      		ldi r16,lo8(0)
 888 006a 10E0      		ldi r17,hi8(0)
 889 006c 00C0      		rjmp .L210
 890               	.LVL62:
 891               	.L47:
 892               	.LBB127:
 893               	.LBB128:
 894               		.loc 2 164 0
 895 006e 25E0      		 ldi r18,lo8(5)
 896 0070 2A95      	    1:dec r18
 897 0072 01F4      	    brne 1b
 898 0074 0000      		nop
 899               	.LBE128:
 900               	.LBE127:
 657:stk500boot.c  **** 			boot_timer++;
 901               		.loc 1 657 0
 902 0076 0894      		sec
 903 0078 C11C      		adc r12,__zero_reg__
 904 007a D11C      		adc r13,__zero_reg__
 905 007c E11C      		adc r14,__zero_reg__
 906 007e F11C      		adc r15,__zero_reg__
 907               	.LVL63:
 660:stk500boot.c  **** 				boot_state	=	1; // (after ++ -> boot_state=2 bootloader timeout, jump to main 0x00000 )
 908               		.loc 1 660 0
 909 0080 01E0      		ldi r16,lo8(1)
 910 0082 10E0      		ldi r17,hi8(1)
 911               	.LVL64:
 912 0084 31E2      		ldi r19,lo8(20001)
 913 0086 C316      		cp r12,r19
 914 0088 3EE4      		ldi r19,hi8(20001)
 915 008a D306      		cpc r13,r19
 916 008c 30E0      		ldi r19,hlo8(20001)
 917 008e E306      		cpc r14,r19
 918 0090 30E0      		ldi r19,hhi8(20001)
 919 0092 F306      		cpc r15,r19
 920 0094 00F4      		brsh .L44
 921 0096 00E0      		ldi r16,lo8(0)
 922 0098 10E0      		ldi r17,hi8(0)
 923               	.L44:
 924               	.LVL65:
 663:stk500boot.c  **** 			if ((boot_timer % _BLINK_LOOP_COUNT_) == 0)
 925               		.loc 1 663 0
 926 009a C701      		movw r24,r14
 927 009c B601      		movw r22,r12
 928 009e A501      		movw r20,r10
 929 00a0 9401      		movw r18,r8
 930 00a2 0E94 0000 		call __udivmodsi4
 931 00a6 DC01      		movw r26,r24
 932 00a8 CB01      		movw r24,r22
 933 00aa 0097      		sbiw r24,0
 934 00ac A105      		cpc r26,__zero_reg__
 935 00ae B105      		cpc r27,__zero_reg__
 936 00b0 01F4      		brne .L210
 666:stk500boot.c  **** 				PROGLED_PORT	^=	(1<<PROGLED_PIN);	// turn LED ON
 937               		.loc 1 666 0
 938 00b2 8BB1      		in r24,43-32
 939 00b4 8058      		subi r24,lo8(-(-128))
 940 00b6 8BB9      		out 43-32,r24
 941               	.LVL66:
 942               	.L210:
 943               	.LBB129:
 944               	.LBB130:
 488:stk500boot.c  **** 	return(UART_STATUS_REG & (1 << UART_RECEIVE_COMPLETE));	// wait for data
 945               		.loc 1 488 0 discriminator 1
 946 00b8 8091 C000 		lds r24,192
 947               	.LBE130:
 948               	.LBE129:
 654:stk500boot.c  **** 		while ((!(Serial_Available())) && (boot_state == 0))		// wait for data
 949               		.loc 1 654 0 discriminator 1
 950 00bc 87FD      		sbrc r24,7
 951 00be 00C0      		rjmp .L46
 654:stk500boot.c  **** 		while ((!(Serial_Available())) && (boot_state == 0))		// wait for data
 952               		.loc 1 654 0 is_stmt 0 discriminator 2
 953 00c0 0115      		cp r16,__zero_reg__
 954 00c2 1105      		cpc r17,__zero_reg__
 955 00c4 01F0      		breq .L47
 956               	.L46:
 957               	.LVL67:
 652:stk500boot.c  **** 	while (boot_state==0)
 958               		.loc 1 652 0 is_stmt 1
 959 00c6 C801      		movw r24,r16
 960 00c8 0196      		adiw r24,1
 674:stk500boot.c  **** 	if (boot_state==1)
 961               		.loc 1 674 0
 962 00ca 8130      		cpi r24,1
 963 00cc 9105      		cpc r25,__zero_reg__
 964 00ce 01F0      		breq .+4
 965 00d0 0C94 0000 		jmp .L51
 966 00d4 0C94 0000 		jmp .L228
 967               	.LVL68:
 968               	.L134:
 969 00d8 80E0      		ldi r24,lo8(0)
 970 00da 90E0      		ldi r25,hi8(0)
 971               	.LVL69:
 972               	.L176:
 685:stk500boot.c  **** 				if (boot_state==1)
 973               		.loc 1 685 0
 974 00dc 8130      		cpi r24,1
 975 00de 9105      		cpc r25,__zero_reg__
 976 00e0 01F4      		brne .L179
 977 00e2 00C0      		rjmp .L217
 978               	.LVL70:
 979               	.L55:
 980               	.LBB131:
 981               	.LBB132:
 514:stk500boot.c  **** 		count++;
 982               		.loc 1 514 0
 983 00e4 0196      		adiw r24,1
 984 00e6 A11D      		adc r26,__zero_reg__
 985 00e8 B11D      		adc r27,__zero_reg__
 986               	.LVL71:
 515:stk500boot.c  **** 		if (count > MAX_TIME_COUNT)
 987               		.loc 1 515 0
 988 00ea 8130      		cpi r24,lo8(8000001)
 989 00ec E2E1      		ldi r30,hi8(8000001)
 990 00ee 9E07      		cpc r25,r30
 991 00f0 EAE7      		ldi r30,hlo8(8000001)
 992 00f2 AE07      		cpc r26,r30
 993 00f4 E0E0      		ldi r30,hhi8(8000001)
 994 00f6 BE07      		cpc r27,r30
 995 00f8 00F0      		brlo .L211
 996               	.LVL72:
 997               	.LBB133:
 523:stk500boot.c  **** 			if (data != 0xffff)					//*	make sure its valid before jumping to it.
 998               		.loc 1 523 0
 999 00fa C15C      		subi r28,lo8(-319)
 1000 00fc DE4F      		sbci r29,hi8(-319)
 1001 00fe 8881      		ld r24,Y
 1002 0100 9981      		ldd r25,Y+1
 1003 0102 CF53      		subi r28,lo8(319)
 1004 0104 D140      		sbci r29,hi8(319)
 1005               	.LVL73:
 1006 0106 AFEF      		ldi r26,hi8(-1)
 1007 0108 8F3F      		cpi r24,lo8(-1)
 1008 010a 9A07      		cpc r25,r26
 1009 010c 01F0      		breq .L179
 525:stk500boot.c  **** 				asm volatile(
 1010               		.loc 1 525 0
 1011               	/* #APP */
 1012               	 ;  525 "stk500boot.c" 1
 1013 010e EE27      		clr	r30		
 1014 0110 FF27      		clr	r31		
 1015 0112 0994      		ijmp	
 1016               		
 1017               	 ;  0 "" 2
 1018               	.LVL74:
 1019               	/* #NOAPP */
 1020               	.L179:
 1021               	.LBE133:
 1022               	.LBE132:
 1023               	.LBE131:
 685:stk500boot.c  **** 				if (boot_state==1)
 1024               		.loc 1 685 0
 1025 0114 80E0      		ldi r24,lo8(0)
 1026 0116 90E0      		ldi r25,hi8(0)
 1027 0118 DC01      		movw r26,r24
 1028               	.L211:
 1029               	.LVL75:
 1030               	.LBB138:
 1031               	.LBB136:
 511:stk500boot.c  **** 	while (!(UART_STATUS_REG & (1 << UART_RECEIVE_COMPLETE)))
 1032               		.loc 1 511 0
 1033 011a 3091 C000 		lds r19,192
 1034 011e 37FF      		sbrs r19,7
 1035 0120 00C0      		rjmp .L55
 1036               	.LVL76:
 1037               	.L217:
 534:stk500boot.c  **** 	return UART_DATA_REG;
 1038               		.loc 1 534 0
 1039 0122 3091 C600 		lds r19,198
 1040               	.LVL77:
 1041               	.LBE136:
 1042               	.LBE138:
 698:stk500boot.c  **** 				rcvdCharCntr++;
 1043               		.loc 1 698 0
 1044 0126 0894      		sec
 1045 0128 E11C      		adc r14,__zero_reg__
 1046 012a F11C      		adc r15,__zero_reg__
 1047               	.LVL78:
 700:stk500boot.c  **** 				if ((c == '!')  && (rcvdCharCntr < 10))
 1048               		.loc 1 700 0
 1049 012c 3132      		cpi r19,lo8(33)
 1050 012e 01F0      		breq .+2
 1051 0130 00C0      		rjmp .L182
 700:stk500boot.c  **** 				if ((c == '!')  && (rcvdCharCntr < 10))
 1052               		.loc 1 700 0 is_stmt 0 discriminator 1
 1053 0132 BAE0      		ldi r27,lo8(10)
 1054 0134 EB16      		cp r14,r27
 1055 0136 F104      		cpc r15,__zero_reg__
 1056 0138 00F0      		brlo .+2
 1057 013a 00C0      		rjmp .L182
 702:stk500boot.c  **** 					exPointCntr++;
 1058               		.loc 1 702 0 is_stmt 1
 1059 013c 6F5F      		subi r22,lo8(-(1))
 1060 013e 7F4F      		sbci r23,hi8(-(1))
 1061               	.LVL79:
 703:stk500boot.c  **** 					if (exPointCntr == 3)
 1062               		.loc 1 703 0
 1063 0140 6330      		cpi r22,3
 1064 0142 7105      		cpc r23,__zero_reg__
 1065 0144 01F0      		breq .+2
 1066 0146 00C0      		rjmp .L56
 1067 0148 00C0      		rjmp .L229
 1068               	.LVL80:
 1069               	.L58:
 1070               	.LBB139:
 1071               	.LBB140:
1764:stk500boot.c  **** 
1765:stk500boot.c  **** //************************************************************************
1766:stk500boot.c  **** static void	ListAvailablePorts(void)
1767:stk500boot.c  **** {
1768:stk500boot.c  **** 
1769:stk500boot.c  **** #ifdef DDRA
1770:stk500boot.c  **** 	PrintAvailablePort('A');
1771:stk500boot.c  **** #endif
1772:stk500boot.c  **** 
1773:stk500boot.c  **** #ifdef DDRB
1774:stk500boot.c  **** 	PrintAvailablePort('B');
1775:stk500boot.c  **** #endif
1776:stk500boot.c  **** 
1777:stk500boot.c  **** #ifdef DDRC
1778:stk500boot.c  **** 	PrintAvailablePort('C');
1779:stk500boot.c  **** #endif
1780:stk500boot.c  **** 
1781:stk500boot.c  **** #ifdef DDRD
1782:stk500boot.c  **** 	PrintAvailablePort('D');
1783:stk500boot.c  **** #endif
1784:stk500boot.c  **** 
1785:stk500boot.c  **** #ifdef DDRE
1786:stk500boot.c  **** 	PrintAvailablePort('E');
1787:stk500boot.c  **** #endif
1788:stk500boot.c  **** 
1789:stk500boot.c  **** #ifdef DDRF
1790:stk500boot.c  **** 	PrintAvailablePort('F');
1791:stk500boot.c  **** #endif
1792:stk500boot.c  **** 
1793:stk500boot.c  **** #ifdef DDRG
1794:stk500boot.c  **** 	PrintAvailablePort('G');
1795:stk500boot.c  **** #endif
1796:stk500boot.c  **** 
1797:stk500boot.c  **** #ifdef DDRH
1798:stk500boot.c  **** 	PrintAvailablePort('H');
1799:stk500boot.c  **** #endif
1800:stk500boot.c  **** 
1801:stk500boot.c  **** #ifdef DDRI
1802:stk500boot.c  **** 	PrintAvailablePort('I');
1803:stk500boot.c  **** #endif
1804:stk500boot.c  **** 
1805:stk500boot.c  **** #ifdef DDRJ
1806:stk500boot.c  **** 	PrintAvailablePort('J');
1807:stk500boot.c  **** #endif
1808:stk500boot.c  **** 
1809:stk500boot.c  **** #ifdef DDRK
1810:stk500boot.c  **** 	PrintAvailablePort('K');
1811:stk500boot.c  **** #endif
1812:stk500boot.c  **** 
1813:stk500boot.c  **** #ifdef DDRL
1814:stk500boot.c  **** 	PrintAvailablePort('L');
1815:stk500boot.c  **** #endif
1816:stk500boot.c  **** 
1817:stk500boot.c  **** }
1818:stk500boot.c  **** 
1819:stk500boot.c  **** //************************************************************************
1820:stk500boot.c  **** static void	AVR_PortOutput(void)
1821:stk500boot.c  **** {
1822:stk500boot.c  **** char	portLetter;
1823:stk500boot.c  **** char	getCharFlag;
1824:stk500boot.c  **** 
1825:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_WHAT_PORT, 0);
1826:stk500boot.c  **** 
1827:stk500boot.c  **** 	portLetter	=	recchar();
1828:stk500boot.c  **** 	portLetter	=	portLetter & 0x5f;
1829:stk500boot.c  **** 	sendchar(portLetter);
1830:stk500boot.c  **** 	PrintNewLine();
1831:stk500boot.c  **** 
1832:stk500boot.c  **** 	if ((portLetter >= 'A') && (portLetter <= 'Z'))
1833:stk500boot.c  **** 	{
1834:stk500boot.c  **** 		getCharFlag	=	true;
1835:stk500boot.c  **** 		switch(portLetter)
1836:stk500boot.c  **** 		{
1837:stk500boot.c  **** 		#ifdef DDRA
1838:stk500boot.c  **** 			case 'A':
1839:stk500boot.c  **** 				DDRA	=	0xff;
1840:stk500boot.c  **** 				while (!Serial_Available())
1841:stk500boot.c  **** 				{
1842:stk500boot.c  **** 					PORTA	^=	0xff;
1843:stk500boot.c  **** 					delay_ms(200);
1844:stk500boot.c  **** 				}
1845:stk500boot.c  **** 				PORTA	=	0;
1846:stk500boot.c  **** 				break;
1847:stk500boot.c  **** 		#endif
1848:stk500boot.c  **** 
1849:stk500boot.c  **** 		#ifdef DDRB
1850:stk500boot.c  **** 			case 'B':
1851:stk500boot.c  **** 				DDRB	=	0xff;
1852:stk500boot.c  **** 				while (!Serial_Available())
1853:stk500boot.c  **** 				{
1854:stk500boot.c  **** 					PORTB	^=	0xff;
1855:stk500boot.c  **** 					delay_ms(200);
1856:stk500boot.c  **** 				}
1857:stk500boot.c  **** 				PORTB	=	0;
1858:stk500boot.c  **** 				break;
1859:stk500boot.c  **** 		#endif
1860:stk500boot.c  **** 
1861:stk500boot.c  **** 		#ifdef DDRC
1862:stk500boot.c  **** 			case 'C':
1863:stk500boot.c  **** 				DDRC	=	0xff;
1864:stk500boot.c  **** 				while (!Serial_Available())
1865:stk500boot.c  **** 				{
1866:stk500boot.c  **** 					PORTC	^=	0xff;
1867:stk500boot.c  **** 					delay_ms(200);
1868:stk500boot.c  **** 				}
1869:stk500boot.c  **** 				PORTC	=	0;
1870:stk500boot.c  **** 				break;
1871:stk500boot.c  **** 		#endif
1872:stk500boot.c  **** 
1873:stk500boot.c  **** 		#ifdef DDRD
1874:stk500boot.c  **** 			case 'D':
1875:stk500boot.c  **** 				DDRD	=	0xff;
1876:stk500boot.c  **** 				while (!Serial_Available())
1877:stk500boot.c  **** 				{
1878:stk500boot.c  **** 					PORTD	^=	0xff;
1879:stk500boot.c  **** 					delay_ms(200);
1880:stk500boot.c  **** 				}
1881:stk500boot.c  **** 				PORTD	=	0;
1882:stk500boot.c  **** 				break;
1883:stk500boot.c  **** 		#endif
1884:stk500boot.c  **** 
1885:stk500boot.c  **** 		#ifdef DDRE
1886:stk500boot.c  **** 			case 'E':
1887:stk500boot.c  **** 				DDRE	=	0xff;
1888:stk500boot.c  **** 				while (!Serial_Available())
1889:stk500boot.c  **** 				{
1890:stk500boot.c  **** 					PORTE	^=	0xff;
1891:stk500boot.c  **** 					delay_ms(200);
1892:stk500boot.c  **** 				}
1893:stk500boot.c  **** 				PORTE	=	0;
1894:stk500boot.c  **** 				break;
1895:stk500boot.c  **** 		#endif
1896:stk500boot.c  **** 
1897:stk500boot.c  **** 		#ifdef DDRF
1898:stk500boot.c  **** 			case 'F':
1899:stk500boot.c  **** 				DDRF	=	0xff;
1900:stk500boot.c  **** 				while (!Serial_Available())
1901:stk500boot.c  **** 				{
1902:stk500boot.c  **** 					PORTF	^=	0xff;
1903:stk500boot.c  **** 					delay_ms(200);
1904:stk500boot.c  **** 				}
1905:stk500boot.c  **** 				PORTF	=	0;
1906:stk500boot.c  **** 				break;
1907:stk500boot.c  **** 		#endif
1908:stk500boot.c  **** 
1909:stk500boot.c  **** 		#ifdef DDRG
1910:stk500boot.c  **** 			case 'G':
1911:stk500boot.c  **** 				DDRG	=	0xff;
1912:stk500boot.c  **** 				while (!Serial_Available())
1913:stk500boot.c  **** 				{
1914:stk500boot.c  **** 					PORTG	^=	0xff;
1915:stk500boot.c  **** 					delay_ms(200);
1916:stk500boot.c  **** 				}
1917:stk500boot.c  **** 				PORTG	=	0;
1918:stk500boot.c  **** 				break;
1919:stk500boot.c  **** 		#endif
1920:stk500boot.c  **** 
1921:stk500boot.c  **** 		#ifdef DDRH
1922:stk500boot.c  **** 			case 'H':
1923:stk500boot.c  **** 				DDRH	=	0xff;
1924:stk500boot.c  **** 				while (!Serial_Available())
1925:stk500boot.c  **** 				{
1926:stk500boot.c  **** 					PORTH	^=	0xff;
1927:stk500boot.c  **** 					delay_ms(200);
1928:stk500boot.c  **** 				}
1929:stk500boot.c  **** 				PORTH	=	0;
1930:stk500boot.c  **** 				break;
1931:stk500boot.c  **** 		#endif
1932:stk500boot.c  **** 
1933:stk500boot.c  **** 		#ifdef DDRI
1934:stk500boot.c  **** 			case 'I':
1935:stk500boot.c  **** 				DDRI	=	0xff;
1936:stk500boot.c  **** 				while (!Serial_Available())
1937:stk500boot.c  **** 				{
1938:stk500boot.c  **** 					PORTI	^=	0xff;
1939:stk500boot.c  **** 					delay_ms(200);
1940:stk500boot.c  **** 				}
1941:stk500boot.c  **** 				PORTI	=	0;
1942:stk500boot.c  **** 				break;
1943:stk500boot.c  **** 		#endif
1944:stk500boot.c  **** 
1945:stk500boot.c  **** 		#ifdef DDRJ
1946:stk500boot.c  **** 			case 'J':
1947:stk500boot.c  **** 				DDRJ	=	0xff;
1948:stk500boot.c  **** 				while (!Serial_Available())
1949:stk500boot.c  **** 				{
1950:stk500boot.c  **** 					PORTJ	^=	0xff;
1951:stk500boot.c  **** 					delay_ms(200);
1952:stk500boot.c  **** 				}
1953:stk500boot.c  **** 				PORTJ	=	0;
1954:stk500boot.c  **** 				break;
1955:stk500boot.c  **** 		#endif
1956:stk500boot.c  **** 
1957:stk500boot.c  **** 		#ifdef DDRK
1958:stk500boot.c  **** 			case 'K':
1959:stk500boot.c  **** 				DDRK	=	0xff;
1960:stk500boot.c  **** 				while (!Serial_Available())
1961:stk500boot.c  **** 				{
1962:stk500boot.c  **** 					PORTK	^=	0xff;
1963:stk500boot.c  **** 					delay_ms(200);
1964:stk500boot.c  **** 				}
1965:stk500boot.c  **** 				PORTK	=	0;
1966:stk500boot.c  **** 				break;
1967:stk500boot.c  **** 		#endif
1968:stk500boot.c  **** 
1969:stk500boot.c  **** 		#ifdef DDRL
1970:stk500boot.c  **** 			case 'L':
1971:stk500boot.c  **** 				DDRL	=	0xff;
1972:stk500boot.c  **** 				while (!Serial_Available())
1973:stk500boot.c  **** 				{
1974:stk500boot.c  **** 					PORTL	^=	0xff;
1975:stk500boot.c  **** 					delay_ms(200);
1976:stk500boot.c  **** 				}
1977:stk500boot.c  **** 				PORTL	=	0;
1978:stk500boot.c  **** 				break;
1979:stk500boot.c  **** 		#endif
1980:stk500boot.c  **** 
1981:stk500boot.c  **** 			default:
1982:stk500boot.c  **** 				PrintFromPROGMEMln(gTextMsg_PortNotSupported, 0);
1983:stk500boot.c  **** 				getCharFlag	=	false;
1984:stk500boot.c  **** 				break;
1985:stk500boot.c  **** 		}
1986:stk500boot.c  **** 		if (getCharFlag)
1987:stk500boot.c  **** 		{
1988:stk500boot.c  **** 			recchar();
1989:stk500boot.c  **** 		}
1990:stk500boot.c  **** 	}
1991:stk500boot.c  **** 	else
1992:stk500boot.c  **** 	{
1993:stk500boot.c  **** 		PrintFromPROGMEMln(gTextMsg_MustBeLetter, 0);
1994:stk500boot.c  **** 	}
1995:stk500boot.c  **** }
1996:stk500boot.c  **** 
1997:stk500boot.c  **** 
1998:stk500boot.c  **** //*******************************************************************
1999:stk500boot.c  **** static void PrintHelp(void)
2000:stk500boot.c  **** {
2001:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_0, 0);
2002:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_QM, 0);
2003:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_AT, 0);
2004:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_B, 0);
2005:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_E, 0);
2006:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_F, 0);
2007:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_H, 0);
2008:stk500boot.c  **** 
2009:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_L, 0);
2010:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_Q, 0);
2011:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_R, 0);
2012:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_V, 0);
2013:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_Y, 0);
2014:stk500boot.c  **** }
2015:stk500boot.c  **** 
2016:stk500boot.c  **** //************************************************************************
2017:stk500boot.c  **** static void	RunMonitor(void)
2018:stk500boot.c  **** {
2019:stk500boot.c  **** char			keepGoing;
2020:stk500boot.c  **** unsigned char	theChar;
2021:stk500boot.c  **** int				ii, jj;
2022:stk500boot.c  **** 
2023:stk500boot.c  **** 	for (ii=0; ii<5; ii++)
2024:stk500boot.c  **** 	{
2025:stk500boot.c  **** 		for (jj=0; jj<25; jj++)
2026:stk500boot.c  **** 		{
2027:stk500boot.c  **** 			sendchar('!');
 1072               		.loc 1 2027 0
 1073 014a 81E2      		ldi r24,lo8(33)
 1074 014c 0E94 0000 		call sendchar
 1075 0150 0150      		subi r16,lo8(-(-1))
 1076 0152 1040      		sbci r17,hi8(-(-1))
2025:stk500boot.c  **** 		for (jj=0; jj<25; jj++)
 1077               		.loc 1 2025 0
 1078 0154 01F4      		brne .L58
2028:stk500boot.c  **** 		}
2029:stk500boot.c  **** 		PrintNewLine();
 1079               		.loc 1 2029 0
 1080 0156 0E94 0000 		call PrintNewLine
 1081 015a 0894      		sec
 1082 015c E108      		sbc r14,__zero_reg__
 1083 015e F108      		sbc r15,__zero_reg__
2023:stk500boot.c  **** 	for (ii=0; ii<5; ii++)
 1084               		.loc 1 2023 0
 1085 0160 E114      		cp r14,__zero_reg__
 1086 0162 F104      		cpc r15,__zero_reg__
 1087 0164 01F4      		brne .L59
 1088 0166 00C0      		rjmp .L230
 1089               	.LVL81:
 1090               	.L229:
 1091 0168 C95D      		subi r28,lo8(-295)
 1092 016a DE4F      		sbci r29,hi8(-295)
 1093 016c 1983      		std Y+1,r17
 1094 016e 0883      		st Y,r16
 1095 0170 C752      		subi r28,lo8(295)
 1096 0172 D140      		sbci r29,hi8(295)
 1097 0174 C75D      		subi r28,lo8(-297)
 1098 0176 DE4F      		sbci r29,hi8(-297)
 1099 0178 F982      		std Y+1,r15
 1100 017a E882      		st Y,r14
 1101 017c C952      		subi r28,lo8(297)
 1102 017e D140      		sbci r29,hi8(297)
 1103               	.LBE140:
 1104               	.LBE139:
 703:stk500boot.c  **** 					if (exPointCntr == 3)
 1105               		.loc 1 703 0
 1106 0180 F5E0      		ldi r31,lo8(5)
 1107 0182 EF2E      		mov r14,r31
 1108 0184 F12C      		mov r15,__zero_reg__
 1109               	.LVL82:
 1110               	.L59:
 685:stk500boot.c  **** 				if (boot_state==1)
 1111               		.loc 1 685 0
 1112 0186 09E1      		ldi r16,lo8(25)
 1113 0188 10E0      		ldi r17,hi8(25)
 1114 018a 00C0      		rjmp .L58
 1115               	.LVL83:
 1116               	.L230:
 1117               	.LBB185:
 1118               	.LBB184:
2030:stk500boot.c  **** 	}
2031:stk500boot.c  **** 
2032:stk500boot.c  **** 	gRamIndex			=	0;
 1119               		.loc 1 2032 0
 1120 018c 1092 0000 		sts gRamIndex,__zero_reg__
 1121 0190 1092 0000 		sts gRamIndex+1,__zero_reg__
 1122 0194 1092 0000 		sts gRamIndex+2,__zero_reg__
 1123 0198 1092 0000 		sts gRamIndex+3,__zero_reg__
2033:stk500boot.c  **** 	gFlashIndex			=	0;
 1124               		.loc 1 2033 0
 1125 019c 1092 0000 		sts gFlashIndex,__zero_reg__
 1126 01a0 1092 0000 		sts gFlashIndex+1,__zero_reg__
 1127 01a4 1092 0000 		sts gFlashIndex+2,__zero_reg__
 1128 01a8 1092 0000 		sts gFlashIndex+3,__zero_reg__
2034:stk500boot.c  **** 	gEepromIndex		=	0;
 1129               		.loc 1 2034 0
 1130 01ac 1092 0000 		sts gEepromIndex,__zero_reg__
 1131 01b0 1092 0000 		sts gEepromIndex+1,__zero_reg__
 1132 01b4 1092 0000 		sts gEepromIndex+2,__zero_reg__
 1133 01b8 1092 0000 		sts gEepromIndex+3,__zero_reg__
2035:stk500boot.c  **** 
2036:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_Explorer, 0);
 1134               		.loc 1 2036 0
 1135 01bc 80E0      		ldi r24,lo8(gTextMsg_Explorer)
 1136 01be 90E0      		ldi r25,hi8(gTextMsg_Explorer)
 1137               	.L218:
 1138 01c0 60E0      		ldi r22,lo8(0)
 1139 01c2 0E94 0000 		call PrintFromPROGMEMln
 1140               	.LVL84:
 1141               	.L212:
2037:stk500boot.c  **** 
2038:stk500boot.c  **** 	keepGoing	=	1;
2039:stk500boot.c  **** 	while (keepGoing)
2040:stk500boot.c  **** 	{
2041:stk500boot.c  **** 		PrintFromPROGMEM(gTextMsg_Prompt, 0);
 1142               		.loc 1 2041 0
 1143 01c6 80E0      		ldi r24,lo8(gTextMsg_Prompt)
 1144 01c8 90E0      		ldi r25,hi8(gTextMsg_Prompt)
 1145 01ca 60E0      		ldi r22,lo8(0)
 1146 01cc 0E94 0000 		call PrintFromPROGMEM
2042:stk500boot.c  **** 		theChar	=	recchar();
 1147               		.loc 1 2042 0
 1148 01d0 0E94 0000 		call recchar
 1149 01d4 182F      		mov r17,r24
 1150               	.LVL85:
2043:stk500boot.c  **** 		if (theChar >= 0x60)
 1151               		.loc 1 2043 0
 1152 01d6 8036      		cpi r24,lo8(96)
 1153 01d8 00F0      		brlo .L61
2044:stk500boot.c  **** 		{
2045:stk500boot.c  **** 			theChar	=	theChar & 0x5F;
 1154               		.loc 1 2045 0
 1155 01da 1F75      		andi r17,lo8(95)
 1156               	.LVL86:
 1157               	.L61:
2046:stk500boot.c  **** 		}
2047:stk500boot.c  **** 
2048:stk500boot.c  **** 		if (theChar >= 0x20)
 1158               		.loc 1 2048 0
 1159 01dc 1032      		cpi r17,lo8(32)
 1160 01de 00F0      		brlo .L62
2049:stk500boot.c  **** 		{
2050:stk500boot.c  **** 			sendchar(theChar);
 1161               		.loc 1 2050 0
 1162 01e0 812F      		mov r24,r17
 1163 01e2 0E94 0000 		call sendchar
2051:stk500boot.c  **** 			sendchar(0x20);
 1164               		.loc 1 2051 0
 1165 01e6 80E2      		ldi r24,lo8(32)
 1166 01e8 0E94 0000 		call sendchar
 1167               	.L62:
2052:stk500boot.c  **** 		}
2053:stk500boot.c  **** 
2054:stk500boot.c  **** 		switch(theChar)
 1168               		.loc 1 2054 0
 1169 01ec 1834      		cpi r17,lo8(72)
 1170 01ee 01F4      		brne .+2
 1171 01f0 00C0      		rjmp .L70
 1172 01f2 1934      		cpi r17,lo8(73)
 1173 01f4 00F4      		brsh .L76
 1174 01f6 1234      		cpi r17,lo8(66)
 1175 01f8 01F4      		brne .+2
 1176 01fa 00C0      		rjmp .L67
 1177 01fc 1334      		cpi r17,lo8(67)
 1178 01fe 00F4      		brsh .L77
 1179 0200 1033      		cpi r17,lo8(48)
 1180 0202 01F0      		breq .L64
 1181 0204 1033      		cpi r17,lo8(48)
 1182 0206 00F4      		brsh .+2
 1183 0208 00C0      		rjmp .L63
 1184 020a 1F33      		cpi r17,lo8(63)
 1185 020c 01F0      		breq .L65
 1186 020e 1034      		cpi r17,lo8(64)
 1187 0210 01F0      		breq .+2
 1188 0212 00C0      		rjmp .L63
 1189 0214 00C0      		rjmp .L231
 1190               	.L77:
 1191 0216 1534      		cpi r17,lo8(69)
 1192 0218 01F4      		brne .+2
 1193 021a 00C0      		rjmp .L68
 1194 021c 1634      		cpi r17,lo8(70)
 1195 021e 01F0      		breq .+2
 1196 0220 00C0      		rjmp .L63
 1197 0222 00C0      		rjmp .L232
 1198               	.L76:
 1199 0224 1235      		cpi r17,lo8(82)
 1200 0226 01F4      		brne .+2
 1201 0228 00C0      		rjmp .L73
 1202 022a 1335      		cpi r17,lo8(83)
 1203 022c 00F4      		brsh .L78
 1204 022e 1C34      		cpi r17,lo8(76)
 1205 0230 01F4      		brne .+2
 1206 0232 00C0      		rjmp .L71
 1207 0234 1135      		cpi r17,lo8(81)
 1208 0236 01F0      		breq .+2
 1209 0238 00C0      		rjmp .L63
 1210 023a 00C0      		rjmp .L233
 1211               	.L78:
 1212 023c 1635      		cpi r17,lo8(86)
 1213 023e 01F4      		brne .+2
 1214 0240 00C0      		rjmp .L74
 1215 0242 1935      		cpi r17,lo8(89)
 1216 0244 01F0      		breq .+2
 1217 0246 00C0      		rjmp .L63
 1218 0248 00C0      		rjmp .L234
 1219               	.L64:
2055:stk500boot.c  **** 		{
2056:stk500boot.c  **** 			case '0':
2057:stk500boot.c  **** 				PrintFromPROGMEMln(gTextMsg_HELP_MSG_0, 2);
 1220               		.loc 1 2057 0
 1221 024a 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_0)
 1222 024c 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_0)
 1223 024e 62E0      		ldi r22,lo8(2)
 1224 0250 0E94 0000 		call PrintFromPROGMEMln
2058:stk500boot.c  **** 				gFlashIndex		=	0;
 1225               		.loc 1 2058 0
 1226 0254 1092 0000 		sts gFlashIndex,__zero_reg__
 1227 0258 1092 0000 		sts gFlashIndex+1,__zero_reg__
 1228 025c 1092 0000 		sts gFlashIndex+2,__zero_reg__
 1229 0260 1092 0000 		sts gFlashIndex+3,__zero_reg__
2059:stk500boot.c  **** 				gRamIndex		=	0;
 1230               		.loc 1 2059 0
 1231 0264 1092 0000 		sts gRamIndex,__zero_reg__
 1232 0268 1092 0000 		sts gRamIndex+1,__zero_reg__
 1233 026c 1092 0000 		sts gRamIndex+2,__zero_reg__
 1234 0270 1092 0000 		sts gRamIndex+3,__zero_reg__
 1235 0274 00C0      		rjmp .L219
 1236               	.L65:
2060:stk500boot.c  **** 				gEepromIndex	=	0;
2061:stk500boot.c  **** 				break;
2062:stk500boot.c  **** 
2063:stk500boot.c  **** 			case '?':
2064:stk500boot.c  **** 				PrintFromPROGMEMln(gTextMsg_HELP_MSG_QM, 2);
 1237               		.loc 1 2064 0
 1238 0276 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_QM)
 1239 0278 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_QM)
 1240 027a 62E0      		ldi r22,lo8(2)
 1241 027c 0E94 0000 		call PrintFromPROGMEMln
 1242               	.LBB141:
 1243               	.LBB142:
1406:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_Explorer, 0);
 1244               		.loc 1 1406 0
 1245 0280 80E0      		ldi r24,lo8(gTextMsg_Explorer)
 1246 0282 90E0      		ldi r25,hi8(gTextMsg_Explorer)
 1247 0284 60E0      		ldi r22,lo8(0)
 1248 0286 0E94 0000 		call PrintFromPROGMEMln
1408:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_COMPILED_ON, 0);
 1249               		.loc 1 1408 0
 1250 028a 80E0      		ldi r24,lo8(gTextMsg_COMPILED_ON)
 1251 028c 90E0      		ldi r25,hi8(gTextMsg_COMPILED_ON)
 1252 028e 60E0      		ldi r22,lo8(0)
 1253 0290 0E94 0000 		call PrintFromPROGMEM
1409:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_GCC_DATE_STR, 0);
 1254               		.loc 1 1409 0
 1255 0294 80E0      		ldi r24,lo8(gTextMsg_GCC_DATE_STR)
 1256 0296 90E0      		ldi r25,hi8(gTextMsg_GCC_DATE_STR)
 1257 0298 60E0      		ldi r22,lo8(0)
 1258 029a 0E94 0000 		call PrintFromPROGMEMln
1411:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_CPU_Type, 0);
 1259               		.loc 1 1411 0
 1260 029e 80E0      		ldi r24,lo8(gTextMsg_CPU_Type)
 1261 02a0 90E0      		ldi r25,hi8(gTextMsg_CPU_Type)
 1262 02a2 60E0      		ldi r22,lo8(0)
 1263 02a4 0E94 0000 		call PrintFromPROGMEM
1412:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_CPU_Name, 0);
 1264               		.loc 1 1412 0
 1265 02a8 80E0      		ldi r24,lo8(gTextMsg_CPU_Name)
 1266 02aa 90E0      		ldi r25,hi8(gTextMsg_CPU_Name)
 1267 02ac 60E0      		ldi r22,lo8(0)
 1268 02ae 0E94 0000 		call PrintFromPROGMEMln
1414:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_AVR_ARCH, 0);
 1269               		.loc 1 1414 0
 1270 02b2 80E0      		ldi r24,lo8(gTextMsg_AVR_ARCH)
 1271 02b4 90E0      		ldi r25,hi8(gTextMsg_AVR_ARCH)
 1272 02b6 60E0      		ldi r22,lo8(0)
 1273 02b8 0E94 0000 		call PrintFromPROGMEM
1415:stk500boot.c  **** 	PrintDecInt(__AVR_ARCH__, 1);
 1274               		.loc 1 1415 0
 1275 02bc 86E0      		ldi r24,lo8(6)
 1276 02be 90E0      		ldi r25,hi8(6)
 1277 02c0 61E0      		ldi r22,lo8(1)
 1278 02c2 70E0      		ldi r23,hi8(1)
 1279 02c4 0E94 0000 		call PrintDecInt
1416:stk500boot.c  **** 	PrintNewLine();
 1280               		.loc 1 1416 0
 1281 02c8 0E94 0000 		call PrintNewLine
1418:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_GCC_VERSION, 0);
 1282               		.loc 1 1418 0
 1283 02cc 80E0      		ldi r24,lo8(gTextMsg_GCC_VERSION)
 1284 02ce 90E0      		ldi r25,hi8(gTextMsg_GCC_VERSION)
 1285 02d0 60E0      		ldi r22,lo8(0)
 1286 02d2 0E94 0000 		call PrintFromPROGMEM
1419:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_GCC_VERSION_STR, 0);
 1287               		.loc 1 1419 0
 1288 02d6 80E0      		ldi r24,lo8(gTextMsg_GCC_VERSION_STR)
 1289 02d8 90E0      		ldi r25,hi8(gTextMsg_GCC_VERSION_STR)
 1290 02da 60E0      		ldi r22,lo8(0)
 1291 02dc 0E94 0000 		call PrintFromPROGMEMln
1422:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_AVR_LIBC, 0);
 1292               		.loc 1 1422 0
 1293 02e0 80E0      		ldi r24,lo8(gTextMsg_AVR_LIBC)
 1294 02e2 90E0      		ldi r25,hi8(gTextMsg_AVR_LIBC)
 1295 02e4 60E0      		ldi r22,lo8(0)
 1296 02e6 0E94 0000 		call PrintFromPROGMEM
1423:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_AVR_LIBC_VER_STR, 0);
 1297               		.loc 1 1423 0
 1298 02ea 80E0      		ldi r24,lo8(gTextMsg_AVR_LIBC_VER_STR)
 1299 02ec 90E0      		ldi r25,hi8(gTextMsg_AVR_LIBC_VER_STR)
 1300 02ee 60E0      		ldi r22,lo8(0)
 1301 02f0 0E94 0000 		call PrintFromPROGMEMln
1426:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_CPU_SIGNATURE, 0);
 1302               		.loc 1 1426 0
 1303 02f4 80E0      		ldi r24,lo8(gTextMsg_CPU_SIGNATURE)
 1304 02f6 90E0      		ldi r25,hi8(gTextMsg_CPU_SIGNATURE)
 1305 02f8 60E0      		ldi r22,lo8(0)
 1306 02fa 0E94 0000 		call PrintFromPROGMEM
1428:stk500boot.c  **** 	PrintHexByte(SIGNATURE_0);
 1307               		.loc 1 1428 0
 1308 02fe 8EE1      		ldi r24,lo8(30)
 1309 0300 0E94 0000 		call PrintHexByte
1429:stk500boot.c  **** 	PrintHexByte(SIGNATURE_1);
 1310               		.loc 1 1429 0
 1311 0304 88EA      		ldi r24,lo8(-88)
 1312 0306 0E94 0000 		call PrintHexByte
1430:stk500boot.c  **** 	PrintHexByte(SIGNATURE_2);
 1313               		.loc 1 1430 0
 1314 030a 82E0      		ldi r24,lo8(2)
 1315 030c 0E94 0000 		call PrintHexByte
1431:stk500boot.c  **** 	PrintNewLine();
 1316               		.loc 1 1431 0
 1317 0310 0E94 0000 		call PrintNewLine
1437:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_FUSE_BYTE_LOW, 0);
 1318               		.loc 1 1437 0
 1319 0314 80E0      		ldi r24,lo8(gTextMsg_FUSE_BYTE_LOW)
 1320 0316 90E0      		ldi r25,hi8(gTextMsg_FUSE_BYTE_LOW)
 1321 0318 60E0      		ldi r22,lo8(0)
 1322 031a 0E94 0000 		call PrintFromPROGMEM
 1323               	.LBB143:
1438:stk500boot.c  **** 	fuseByte	=	boot_lock_fuse_bits_get(GET_LOW_FUSE_BITS);
 1324               		.loc 1 1438 0
 1325 031e 19E0      		ldi r17,lo8(9)
 1326               	.LVL87:
 1327 0320 E0E0      		ldi r30,lo8(0)
 1328 0322 F0E0      		ldi r31,hi8(0)
 1329               	/* #APP */
 1330               	 ;  1438 "stk500boot.c" 1
 1331 0324 1093 5700 		sts 87, r17
 1332 0328 8491      		lpm r24, Z
 1333               		
 1334               	 ;  0 "" 2
 1335               	.LVL88:
 1336               	/* #NOAPP */
 1337               	.LBE143:
1439:stk500boot.c  **** 	PrintHexByte(fuseByte);
 1338               		.loc 1 1439 0
 1339 032a 0E94 0000 		call PrintHexByte
 1340               	.LVL89:
1440:stk500boot.c  **** 	PrintNewLine();
 1341               		.loc 1 1440 0
 1342 032e 0E94 0000 		call PrintNewLine
1442:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_FUSE_BYTE_HIGH, 0);
 1343               		.loc 1 1442 0
 1344 0332 80E0      		ldi r24,lo8(gTextMsg_FUSE_BYTE_HIGH)
 1345 0334 90E0      		ldi r25,hi8(gTextMsg_FUSE_BYTE_HIGH)
 1346 0336 60E0      		ldi r22,lo8(0)
 1347 0338 0E94 0000 		call PrintFromPROGMEM
 1348               	.LBB144:
1443:stk500boot.c  **** 	fuseByte	=	boot_lock_fuse_bits_get(GET_HIGH_FUSE_BITS);
 1349               		.loc 1 1443 0
 1350 033c E3E0      		ldi r30,lo8(3)
 1351 033e F0E0      		ldi r31,hi8(3)
 1352               	/* #APP */
 1353               	 ;  1443 "stk500boot.c" 1
 1354 0340 1093 5700 		sts 87, r17
 1355 0344 8491      		lpm r24, Z
 1356               		
 1357               	 ;  0 "" 2
 1358               	.LVL90:
 1359               	/* #NOAPP */
 1360               	.LBE144:
1444:stk500boot.c  **** 	PrintHexByte(fuseByte);
 1361               		.loc 1 1444 0
 1362 0346 0E94 0000 		call PrintHexByte
 1363               	.LVL91:
1445:stk500boot.c  **** 	PrintNewLine();
 1364               		.loc 1 1445 0
 1365 034a 0E94 0000 		call PrintNewLine
1447:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_FUSE_BYTE_EXT, 0);
 1366               		.loc 1 1447 0
 1367 034e 80E0      		ldi r24,lo8(gTextMsg_FUSE_BYTE_EXT)
 1368 0350 90E0      		ldi r25,hi8(gTextMsg_FUSE_BYTE_EXT)
 1369 0352 60E0      		ldi r22,lo8(0)
 1370 0354 0E94 0000 		call PrintFromPROGMEM
 1371               	.LBB145:
1448:stk500boot.c  **** 	fuseByte	=	boot_lock_fuse_bits_get(GET_EXTENDED_FUSE_BITS);
 1372               		.loc 1 1448 0
 1373 0358 E2E0      		ldi r30,lo8(2)
 1374 035a F0E0      		ldi r31,hi8(2)
 1375               	/* #APP */
 1376               	 ;  1448 "stk500boot.c" 1
 1377 035c 1093 5700 		sts 87, r17
 1378 0360 8491      		lpm r24, Z
 1379               		
 1380               	 ;  0 "" 2
 1381               	.LVL92:
 1382               	/* #NOAPP */
 1383               	.LBE145:
1449:stk500boot.c  **** 	PrintHexByte(fuseByte);
 1384               		.loc 1 1449 0
 1385 0362 0E94 0000 		call PrintHexByte
 1386               	.LVL93:
1450:stk500boot.c  **** 	PrintNewLine();
 1387               		.loc 1 1450 0
 1388 0366 0E94 0000 		call PrintNewLine
1452:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_FUSE_BYTE_LOCK, 0);
 1389               		.loc 1 1452 0
 1390 036a 80E0      		ldi r24,lo8(gTextMsg_FUSE_BYTE_LOCK)
 1391 036c 90E0      		ldi r25,hi8(gTextMsg_FUSE_BYTE_LOCK)
 1392 036e 60E0      		ldi r22,lo8(0)
 1393 0370 0E94 0000 		call PrintFromPROGMEM
 1394               	.LBB146:
1453:stk500boot.c  **** 	fuseByte	=	boot_lock_fuse_bits_get(GET_LOCK_BITS);
 1395               		.loc 1 1453 0
 1396 0374 E1E0      		ldi r30,lo8(1)
 1397 0376 F0E0      		ldi r31,hi8(1)
 1398               	/* #APP */
 1399               	 ;  1453 "stk500boot.c" 1
 1400 0378 1093 5700 		sts 87, r17
 1401 037c 8491      		lpm r24, Z
 1402               		
 1403               	 ;  0 "" 2
 1404               	.LVL94:
 1405               	/* #NOAPP */
 1406               	.LBE146:
1454:stk500boot.c  **** 	PrintHexByte(fuseByte);
 1407               		.loc 1 1454 0
 1408 037e 0E94 0000 		call PrintHexByte
 1409               	.LVL95:
1455:stk500boot.c  **** 	PrintNewLine();
 1410               		.loc 1 1455 0
 1411 0382 0E94 0000 		call PrintNewLine
 1412 0386 00C0      		rjmp .L212
 1413               	.LVL96:
 1414               	.L231:
 1415               	.LBE142:
 1416               	.LBE141:
2065:stk500boot.c  **** 				PrintCPUstats();
2066:stk500boot.c  **** 				break;
2067:stk500boot.c  **** 
2068:stk500boot.c  **** 			case '@':
2069:stk500boot.c  **** 				PrintFromPROGMEMln(gTextMsg_HELP_MSG_AT, 2);
 1417               		.loc 1 2069 0
 1418 0388 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_AT)
 1419 038a 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_AT)
 1420 038c 62E0      		ldi r22,lo8(2)
 1421 038e 0E94 0000 		call PrintFromPROGMEMln
 1422               	.LBB147:
 1423               	.LBB148:
1564:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_WriteToEEprom, 0);
 1424               		.loc 1 1564 0
 1425 0392 80E0      		ldi r24,lo8(gTextMsg_WriteToEEprom)
 1426 0394 90E0      		ldi r25,hi8(gTextMsg_WriteToEEprom)
 1427 0396 60E0      		ldi r22,lo8(0)
 1428 0398 0E94 0000 		call PrintFromPROGMEMln
1565:stk500boot.c  **** 	PrintNewLine();
 1429               		.loc 1 1565 0
 1430 039c 0E94 0000 		call PrintNewLine
 1431               	.LVL97:
1566:stk500boot.c  **** 	ii			=	0;
 1432               		.loc 1 1566 0
 1433 03a0 EE24      		clr r14
 1434 03a2 FF24      		clr r15
 1435 03a4 00C0      		rjmp .L80
 1436               	.LVL98:
 1437               	.L84:
1573:stk500boot.c  **** 		eeprom_write_byte((uint8_t *)ii, theChar);
 1438               		.loc 1 1573 0
 1439 03a6 C701      		movw r24,r14
 1440 03a8 612F      		mov r22,r17
 1441 03aa 0E94 0000 		call __eewr_byte_m256rfr2
1574:stk500boot.c  **** 		if (theChar == 0)
 1442               		.loc 1 1574 0
 1443 03ae 1123      		tst r17
 1444 03b0 01F4      		brne .L81
1576:stk500boot.c  **** 			PrintFromPROGMEM(gTextMsg_SPACE, 0);
 1445               		.loc 1 1576 0
 1446 03b2 80E0      		ldi r24,lo8(gTextMsg_SPACE)
 1447 03b4 90E0      		ldi r25,hi8(gTextMsg_SPACE)
 1448 03b6 60E0      		ldi r22,lo8(0)
 1449 03b8 0E94 0000 		call PrintFromPROGMEM
 1450 03bc 00C0      		rjmp .L82
 1451               	.L81:
1580:stk500boot.c  **** 			sendchar(theChar);
 1452               		.loc 1 1580 0
 1453 03be 812F      		mov r24,r17
 1454 03c0 0E94 0000 		call sendchar
 1455               	.L82:
1582:stk500boot.c  **** 		ii++;
 1456               		.loc 1 1582 0
 1457 03c4 0894      		sec
 1458 03c6 E11C      		adc r14,__zero_reg__
 1459 03c8 F11C      		adc r15,__zero_reg__
 1460               	.LVL99:
 1461               	.L80:
 1462               	.LBB149:
 542:stk500boot.c  **** int main(void)
 1463               		.loc 1 542 0
 1464 03ca C701      		movw r24,r14
 1465 03cc 8050      		subi r24,lo8(-(gTextMsg_Explorer))
 1466 03ce 9040      		sbci r25,hi8(-(gTextMsg_Explorer))
1568:stk500boot.c  **** 	while (((theChar = pgm_read_byte_far(((uint16_t)gTextMsg_Explorer) + ii)) != '*') && (ii < 512))
 1467               		.loc 1 1568 0
 1468 03d0 A0E0      		ldi r26,lo8(0)
 1469 03d2 B0E0      		ldi r27,hi8(0)
 1470               	/* #APP */
 1471               	 ;  1568 "stk500boot.c" 1
 1472 03d4 ABBF      		out 59, r26
 1473 03d6 FC01      		movw r30, r24
 1474 03d8 1791      		elpm r17, Z+
 1475               		
 1476               	 ;  0 "" 2
 1477               	.LVL100:
 1478               	/* #NOAPP */
 1479               	.LBE149:
 1480 03da 1A32      		cpi r17,lo8(42)
 1481 03dc 01F0      		breq .L83
 1482 03de E0E0      		ldi r30,lo8(512)
 1483 03e0 EE16      		cp r14,r30
 1484 03e2 E2E0      		ldi r30,hi8(512)
 1485 03e4 FE06      		cpc r15,r30
 1486 03e6 01F4      		brne .L84
 1487               	.L83:
1586:stk500boot.c  **** 	PrintNewLine();
 1488               		.loc 1 1586 0
 1489 03e8 0E94 0000 		call PrintNewLine
1587:stk500boot.c  **** 	PrintNewLine();
 1490               		.loc 1 1587 0
 1491 03ec 0E94 0000 		call PrintNewLine
1588:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_ReadingEEprom, 0);
 1492               		.loc 1 1588 0
 1493 03f0 80E0      		ldi r24,lo8(gTextMsg_ReadingEEprom)
 1494 03f2 90E0      		ldi r25,hi8(gTextMsg_ReadingEEprom)
 1495 03f4 60E0      		ldi r22,lo8(0)
 1496 03f6 0E94 0000 		call PrintFromPROGMEMln
1589:stk500boot.c  **** 	PrintNewLine();
 1497               		.loc 1 1589 0
 1498 03fa 0E94 0000 		call PrintNewLine
 1499               	.LVL101:
1590:stk500boot.c  **** 	errorCount	=	0;
 1500               		.loc 1 1590 0
 1501 03fe CC24      		clr r12
 1502 0400 DD24      		clr r13
1591:stk500boot.c  **** 	ii			=	0;
 1503               		.loc 1 1591 0
 1504 0402 EE24      		clr r14
 1505 0404 FF24      		clr r15
 1506               	.LVL102:
 1507 0406 00C0      		rjmp .L85
 1508               	.LVL103:
 1509               	.L90:
1598:stk500boot.c  **** 		theEEPROMchar	=	eeprom_read_byte((uint8_t *)ii);
 1510               		.loc 1 1598 0
 1511 0408 C701      		movw r24,r14
 1512 040a 0E94 0000 		call __eerd_byte_m256rfr2
 1513 040e 182F      		mov r17,r24
 1514               	.LVL104:
1599:stk500boot.c  **** 		if (theEEPROMchar == 0)
 1515               		.loc 1 1599 0
 1516 0410 8823      		tst r24
 1517 0412 01F4      		brne .L86
1601:stk500boot.c  **** 			PrintFromPROGMEM(gTextMsg_SPACE, 0);
 1518               		.loc 1 1601 0
 1519 0414 80E0      		ldi r24,lo8(gTextMsg_SPACE)
 1520 0416 90E0      		ldi r25,hi8(gTextMsg_SPACE)
 1521               	.LVL105:
 1522 0418 60E0      		ldi r22,lo8(0)
 1523 041a 0E94 0000 		call PrintFromPROGMEM
 1524 041e 00C0      		rjmp .L87
 1525               	.L86:
1605:stk500boot.c  **** 			sendchar(theEEPROMchar);
 1526               		.loc 1 1605 0
 1527 0420 0E94 0000 		call sendchar
 1528               	.L87:
1607:stk500boot.c  **** 		if (theEEPROMchar != theChar)
 1529               		.loc 1 1607 0
 1530 0424 1017      		cp r17,r16
 1531 0426 01F0      		breq .L88
1609:stk500boot.c  **** 			errorCount++;
 1532               		.loc 1 1609 0
 1533 0428 0894      		sec
 1534 042a C11C      		adc r12,__zero_reg__
 1535 042c D11C      		adc r13,__zero_reg__
 1536               	.LVL106:
 1537               	.L88:
1611:stk500boot.c  **** 		ii++;
 1538               		.loc 1 1611 0
 1539 042e 0894      		sec
 1540 0430 E11C      		adc r14,__zero_reg__
 1541 0432 F11C      		adc r15,__zero_reg__
 1542               	.LVL107:
 1543               	.L85:
 1544               	.LBB150:
 542:stk500boot.c  **** int main(void)
 1545               		.loc 1 542 0
 1546 0434 8701      		movw r16,r14
 1547 0436 0050      		subi r16,lo8(-(gTextMsg_Explorer))
 1548 0438 1040      		sbci r17,hi8(-(gTextMsg_Explorer))
1593:stk500boot.c  **** 	while (((theChar = pgm_read_byte_far((uint16_t)gTextMsg_Explorer + ii)) != '*') && (ii < 512))
 1549               		.loc 1 1593 0
 1550 043a 20E0      		ldi r18,lo8(0)
 1551 043c 30E0      		ldi r19,hi8(0)
 1552               	/* #APP */
 1553               	 ;  1593 "stk500boot.c" 1
 1554 043e 2BBF      		out 59, r18
 1555 0440 F801      		movw r30, r16
 1556 0442 0791      		elpm r16, Z+
 1557               		
 1558               	 ;  0 "" 2
 1559               	.LVL108:
 1560               	/* #NOAPP */
 1561               	.LBE150:
 1562 0444 0A32      		cpi r16,lo8(42)
 1563 0446 01F0      		breq .L89
 1564 0448 F0E0      		ldi r31,lo8(512)
 1565 044a EF16      		cp r14,r31
 1566 044c F2E0      		ldi r31,hi8(512)
 1567 044e FF06      		cpc r15,r31
 1568 0450 01F4      		brne .L90
 1569               	.L89:
1613:stk500boot.c  **** 	PrintNewLine();
 1570               		.loc 1 1613 0
 1571 0452 0E94 0000 		call PrintNewLine
1614:stk500boot.c  **** 	PrintNewLine();
 1572               		.loc 1 1614 0
 1573 0456 0E94 0000 		call PrintNewLine
1615:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_EEPROMerrorCnt, 0);
 1574               		.loc 1 1615 0
 1575 045a 80E0      		ldi r24,lo8(gTextMsg_EEPROMerrorCnt)
 1576 045c 90E0      		ldi r25,hi8(gTextMsg_EEPROMerrorCnt)
 1577 045e 60E0      		ldi r22,lo8(0)
 1578 0460 0E94 0000 		call PrintFromPROGMEM
1616:stk500boot.c  **** 	PrintDecInt(errorCount, 1);
 1579               		.loc 1 1616 0
 1580 0464 C601      		movw r24,r12
 1581 0466 61E0      		ldi r22,lo8(1)
 1582 0468 70E0      		ldi r23,hi8(1)
 1583 046a 0E94 0000 		call PrintDecInt
1617:stk500boot.c  **** 	PrintNewLine();
 1584               		.loc 1 1617 0
 1585 046e 0E94 0000 		call PrintNewLine
1618:stk500boot.c  **** 	PrintNewLine();
 1586               		.loc 1 1618 0
 1587 0472 0E94 0000 		call PrintNewLine
 1588               	.LVL109:
 1589               	.L219:
1620:stk500boot.c  **** 	gEepromIndex	=	0;	//*	set index back to zero for next eeprom dump
 1590               		.loc 1 1620 0
 1591 0476 1092 0000 		sts gEepromIndex,__zero_reg__
 1592 047a 1092 0000 		sts gEepromIndex+1,__zero_reg__
 1593 047e 1092 0000 		sts gEepromIndex+2,__zero_reg__
 1594 0482 1092 0000 		sts gEepromIndex+3,__zero_reg__
 1595 0486 00C0      		rjmp .L212
 1596               	.LVL110:
 1597               	.L67:
 1598               	.LBE148:
 1599               	.LBE147:
2070:stk500boot.c  **** 				EEPROMtest();
2071:stk500boot.c  **** 				break;
2072:stk500boot.c  **** 
2073:stk500boot.c  **** 			case 'B':
2074:stk500boot.c  **** 				PrintFromPROGMEMln(gTextMsg_HELP_MSG_B, 2);
 1600               		.loc 1 2074 0
 1601 0488 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_B)
 1602 048a 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_B)
 1603 048c 62E0      		ldi r22,lo8(2)
 1604 048e 0E94 0000 		call PrintFromPROGMEMln
 1605               	.LBB151:
 1606               	.LBB152:
1465:stk500boot.c  **** 	PROGLED_DDR		|=	(1<<PROGLED_PIN);
 1607               		.loc 1 1465 0
 1608 0492 579A      		sbi 42-32,7
1466:stk500boot.c  **** 	PROGLED_PORT	|=	(1<<PROGLED_PIN);	// active high LED ON
 1609               		.loc 1 1466 0
 1610 0494 5F9A      		sbi 43-32,7
 1611 0496 00C0      		rjmp .L91
 1612               	.L92:
1470:stk500boot.c  **** 		PROGLED_PORT	&=	~(1<<PROGLED_PIN);	// turn LED off
 1613               		.loc 1 1470 0
 1614 0498 5F98      		cbi 43-32,7
1471:stk500boot.c  **** 		delay_ms(100);
 1615               		.loc 1 1471 0
 1616 049a 84E6      		ldi r24,lo8(100)
 1617 049c 90E0      		ldi r25,hi8(100)
 1618 049e 0E94 0000 		call delay_ms
1472:stk500boot.c  **** 		PROGLED_PORT	|=	(1<<PROGLED_PIN);	// turn LED on
 1619               		.loc 1 1472 0
 1620 04a2 5F9A      		sbi 43-32,7
1473:stk500boot.c  **** 		delay_ms(100);
 1621               		.loc 1 1473 0
 1622 04a4 84E6      		ldi r24,lo8(100)
 1623 04a6 90E0      		ldi r25,hi8(100)
 1624 04a8 0E94 0000 		call delay_ms
 1625               	.L91:
 1626               	.LBB153:
 1627               	.LBB154:
 488:stk500boot.c  **** 	return(UART_STATUS_REG & (1 << UART_RECEIVE_COMPLETE));	// wait for data
 1628               		.loc 1 488 0
 1629 04ac 8091 C000 		lds r24,192
 1630               	.LBE154:
 1631               	.LBE153:
1468:stk500boot.c  **** 	while (!Serial_Available())
 1632               		.loc 1 1468 0
 1633 04b0 87FF      		sbrs r24,7
 1634 04b2 00C0      		rjmp .L92
 1635 04b4 00C0      		rjmp .L110
 1636               	.L68:
 1637               	.LBE152:
 1638               	.LBE151:
2075:stk500boot.c  **** 				BlinkLED();
2076:stk500boot.c  **** 				break;
2077:stk500boot.c  **** 
2078:stk500boot.c  **** 			case 'E':
2079:stk500boot.c  **** 				PrintFromPROGMEMln(gTextMsg_HELP_MSG_E, 2);
 1639               		.loc 1 2079 0
 1640 04b6 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_E)
 1641 04b8 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_E)
 1642 04ba 62E0      		ldi r22,lo8(2)
 1643 04bc 0E94 0000 		call PrintFromPROGMEMln
2080:stk500boot.c  **** 				DumpHex(kDUMP_EEPROM, gEepromIndex, 16);
 1644               		.loc 1 2080 0
 1645 04c0 4091 0000 		lds r20,gEepromIndex
 1646 04c4 5091 0000 		lds r21,gEepromIndex+1
 1647 04c8 6091 0000 		lds r22,gEepromIndex+2
 1648 04cc 7091 0000 		lds r23,gEepromIndex+3
 1649 04d0 81E0      		ldi r24,lo8(1)
 1650 04d2 0E94 0000 		call DumpHex.constprop.0
2081:stk500boot.c  **** 				gEepromIndex	+=	256;
 1651               		.loc 1 2081 0
 1652 04d6 8091 0000 		lds r24,gEepromIndex
 1653 04da 9091 0000 		lds r25,gEepromIndex+1
 1654 04de A091 0000 		lds r26,gEepromIndex+2
 1655 04e2 B091 0000 		lds r27,gEepromIndex+3
 1656 04e6 8050      		subi r24,lo8(-(256))
 1657 04e8 9F4F      		sbci r25,hi8(-(256))
 1658 04ea AF4F      		sbci r26,hlo8(-(256))
 1659 04ec BF4F      		sbci r27,hhi8(-(256))
 1660 04ee 8093 0000 		sts gEepromIndex,r24
 1661 04f2 9093 0000 		sts gEepromIndex+1,r25
 1662 04f6 A093 0000 		sts gEepromIndex+2,r26
 1663 04fa B093 0000 		sts gEepromIndex+3,r27
2082:stk500boot.c  **** 				if (gEepromIndex > E2END)
 1664               		.loc 1 2082 0
 1665 04fe 8030      		cpi r24,lo8(8192)
 1666 0500 20E2      		ldi r18,hi8(8192)
 1667 0502 9207      		cpc r25,r18
 1668 0504 20E0      		ldi r18,hlo8(8192)
 1669 0506 A207      		cpc r26,r18
 1670 0508 20E0      		ldi r18,hhi8(8192)
 1671 050a B207      		cpc r27,r18
 1672 050c 00F4      		brsh .+2
 1673 050e 00C0      		rjmp .L212
 1674 0510 00C0      		rjmp .L219
 1675               	.L232:
2083:stk500boot.c  **** 				{
2084:stk500boot.c  **** 					gEepromIndex	=	0;
2085:stk500boot.c  **** 				}
2086:stk500boot.c  **** 				break;
2087:stk500boot.c  **** 		
2088:stk500boot.c  **** 			case 'F':
2089:stk500boot.c  **** 				PrintFromPROGMEMln(gTextMsg_HELP_MSG_F, 2);
 1676               		.loc 1 2089 0
 1677 0512 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_F)
 1678 0514 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_F)
 1679 0516 62E0      		ldi r22,lo8(2)
 1680 0518 0E94 0000 		call PrintFromPROGMEMln
2090:stk500boot.c  **** 				DumpHex(kDUMP_FLASH, gFlashIndex, 16);
 1681               		.loc 1 2090 0
 1682 051c 4091 0000 		lds r20,gFlashIndex
 1683 0520 5091 0000 		lds r21,gFlashIndex+1
 1684 0524 6091 0000 		lds r22,gFlashIndex+2
 1685 0528 7091 0000 		lds r23,gFlashIndex+3
 1686 052c 80E0      		ldi r24,lo8(0)
 1687 052e 0E94 0000 		call DumpHex.constprop.0
2091:stk500boot.c  **** 				gFlashIndex	+=	256;
 1688               		.loc 1 2091 0
 1689 0532 8091 0000 		lds r24,gFlashIndex
 1690 0536 9091 0000 		lds r25,gFlashIndex+1
 1691 053a A091 0000 		lds r26,gFlashIndex+2
 1692 053e B091 0000 		lds r27,gFlashIndex+3
 1693 0542 8050      		subi r24,lo8(-(256))
 1694 0544 9F4F      		sbci r25,hi8(-(256))
 1695 0546 AF4F      		sbci r26,hlo8(-(256))
 1696 0548 BF4F      		sbci r27,hhi8(-(256))
 1697 054a 8093 0000 		sts gFlashIndex,r24
 1698 054e 9093 0000 		sts gFlashIndex+1,r25
 1699 0552 A093 0000 		sts gFlashIndex+2,r26
 1700 0556 B093 0000 		sts gFlashIndex+3,r27
 1701 055a 00C0      		rjmp .L212
 1702               	.L70:
2092:stk500boot.c  **** 				break;
2093:stk500boot.c  **** 
2094:stk500boot.c  **** 			case 'H':
2095:stk500boot.c  **** 				PrintFromPROGMEMln(gTextMsg_HELP_MSG_H, 2);
 1703               		.loc 1 2095 0
 1704 055c 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_H)
 1705 055e 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_H)
 1706 0560 62E0      		ldi r22,lo8(2)
 1707 0562 0E94 0000 		call PrintFromPROGMEMln
 1708               	.LBB155:
 1709               	.LBB156:
2001:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_0, 0);
 1710               		.loc 1 2001 0
 1711 0566 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_0)
 1712 0568 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_0)
 1713 056a 60E0      		ldi r22,lo8(0)
 1714 056c 0E94 0000 		call PrintFromPROGMEMln
2002:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_QM, 0);
 1715               		.loc 1 2002 0
 1716 0570 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_QM)
 1717 0572 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_QM)
 1718 0574 60E0      		ldi r22,lo8(0)
 1719 0576 0E94 0000 		call PrintFromPROGMEMln
2003:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_AT, 0);
 1720               		.loc 1 2003 0
 1721 057a 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_AT)
 1722 057c 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_AT)
 1723 057e 60E0      		ldi r22,lo8(0)
 1724 0580 0E94 0000 		call PrintFromPROGMEMln
2004:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_B, 0);
 1725               		.loc 1 2004 0
 1726 0584 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_B)
 1727 0586 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_B)
 1728 0588 60E0      		ldi r22,lo8(0)
 1729 058a 0E94 0000 		call PrintFromPROGMEMln
2005:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_E, 0);
 1730               		.loc 1 2005 0
 1731 058e 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_E)
 1732 0590 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_E)
 1733 0592 60E0      		ldi r22,lo8(0)
 1734 0594 0E94 0000 		call PrintFromPROGMEMln
2006:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_F, 0);
 1735               		.loc 1 2006 0
 1736 0598 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_F)
 1737 059a 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_F)
 1738 059c 60E0      		ldi r22,lo8(0)
 1739 059e 0E94 0000 		call PrintFromPROGMEMln
2007:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_H, 0);
 1740               		.loc 1 2007 0
 1741 05a2 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_H)
 1742 05a4 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_H)
 1743 05a6 60E0      		ldi r22,lo8(0)
 1744 05a8 0E94 0000 		call PrintFromPROGMEMln
2009:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_L, 0);
 1745               		.loc 1 2009 0
 1746 05ac 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_L)
 1747 05ae 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_L)
 1748 05b0 60E0      		ldi r22,lo8(0)
 1749 05b2 0E94 0000 		call PrintFromPROGMEMln
2010:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_Q, 0);
 1750               		.loc 1 2010 0
 1751 05b6 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_Q)
 1752 05b8 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_Q)
 1753 05ba 60E0      		ldi r22,lo8(0)
 1754 05bc 0E94 0000 		call PrintFromPROGMEMln
2011:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_R, 0);
 1755               		.loc 1 2011 0
 1756 05c0 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_R)
 1757 05c2 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_R)
 1758 05c4 60E0      		ldi r22,lo8(0)
 1759 05c6 0E94 0000 		call PrintFromPROGMEMln
2012:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_V, 0);
 1760               		.loc 1 2012 0
 1761 05ca 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_V)
 1762 05cc 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_V)
 1763 05ce 60E0      		ldi r22,lo8(0)
 1764 05d0 0E94 0000 		call PrintFromPROGMEMln
2013:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_Y, 0);
 1765               		.loc 1 2013 0
 1766 05d4 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_Y)
 1767 05d6 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_Y)
 1768 05d8 00C0      		rjmp .L218
 1769               	.L71:
 1770               	.LBE156:
 1771               	.LBE155:
2096:stk500boot.c  **** 				PrintHelp();
2097:stk500boot.c  **** 				break;
2098:stk500boot.c  **** 
2099:stk500boot.c  **** 			case 'L':
2100:stk500boot.c  **** 				PrintFromPROGMEMln(gTextMsg_HELP_MSG_L, 2);
 1772               		.loc 1 2100 0
 1773 05da 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_L)
 1774 05dc 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_L)
 1775 05de 62E0      		ldi r22,lo8(2)
 1776 05e0 0E94 0000 		call PrintFromPROGMEMln
 1777               	.LBB157:
 1778               	.LBB158:
1770:stk500boot.c  **** 	PrintAvailablePort('A');
 1779               		.loc 1 1770 0
 1780 05e4 81E4      		ldi r24,lo8(65)
 1781 05e6 0E94 0000 		call PrintAvailablePort
1774:stk500boot.c  **** 	PrintAvailablePort('B');
 1782               		.loc 1 1774 0
 1783 05ea 82E4      		ldi r24,lo8(66)
 1784 05ec 0E94 0000 		call PrintAvailablePort
1778:stk500boot.c  **** 	PrintAvailablePort('C');
 1785               		.loc 1 1778 0
 1786 05f0 83E4      		ldi r24,lo8(67)
 1787 05f2 0E94 0000 		call PrintAvailablePort
1782:stk500boot.c  **** 	PrintAvailablePort('D');
 1788               		.loc 1 1782 0
 1789 05f6 84E4      		ldi r24,lo8(68)
 1790 05f8 0E94 0000 		call PrintAvailablePort
1786:stk500boot.c  **** 	PrintAvailablePort('E');
 1791               		.loc 1 1786 0
 1792 05fc 85E4      		ldi r24,lo8(69)
 1793 05fe 0E94 0000 		call PrintAvailablePort
1790:stk500boot.c  **** 	PrintAvailablePort('F');
 1794               		.loc 1 1790 0
 1795 0602 86E4      		ldi r24,lo8(70)
 1796 0604 0E94 0000 		call PrintAvailablePort
1794:stk500boot.c  **** 	PrintAvailablePort('G');
 1797               		.loc 1 1794 0
 1798 0608 87E4      		ldi r24,lo8(71)
 1799 060a 0E94 0000 		call PrintAvailablePort
 1800 060e 00C0      		rjmp .L212
 1801               	.L233:
 1802               	.LBE158:
 1803               	.LBE157:
2101:stk500boot.c  **** 				ListAvailablePorts();
2102:stk500boot.c  **** 				break;
2103:stk500boot.c  **** 
2104:stk500boot.c  **** 			case 'Q':
2105:stk500boot.c  **** 				PrintFromPROGMEMln(gTextMsg_HELP_MSG_Q, 2);
 1804               		.loc 1 2105 0
 1805 0610 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_Q)
 1806 0612 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_Q)
 1807 0614 62E0      		ldi r22,lo8(2)
 1808 0616 0E94 0000 		call PrintFromPROGMEMln
 1809               	.LVL111:
 706:stk500boot.c  **** 						exPointCntr		=	0;	//	reset back to zero so we dont get in an endless loop
 1810               		.loc 1 706 0
 1811 061a 2224      		clr r2
 1812 061c 3324      		clr r3
 707:stk500boot.c  **** 						isLeave			=	1;
 1813               		.loc 1 707 0
 1814 061e 4424      		clr r4
 1815 0620 4394      		inc r4
 1816 0622 00C0      		rjmp .L93
 1817               	.LVL112:
 1818               	.L73:
2106:stk500boot.c  **** 				keepGoing	=	false;
2107:stk500boot.c  **** 				break;
2108:stk500boot.c  **** 
2109:stk500boot.c  **** 			case 'R':
2110:stk500boot.c  **** 				PrintFromPROGMEMln(gTextMsg_HELP_MSG_R, 2);
 1819               		.loc 1 2110 0
 1820 0624 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_R)
 1821 0626 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_R)
 1822 0628 62E0      		ldi r22,lo8(2)
 1823 062a 0E94 0000 		call PrintFromPROGMEMln
2111:stk500boot.c  **** 				DumpHex(kDUMP_RAM, gRamIndex, 16);
 1824               		.loc 1 2111 0
 1825 062e 4091 0000 		lds r20,gRamIndex
 1826 0632 5091 0000 		lds r21,gRamIndex+1
 1827 0636 6091 0000 		lds r22,gRamIndex+2
 1828 063a 7091 0000 		lds r23,gRamIndex+3
 1829 063e 82E0      		ldi r24,lo8(2)
 1830 0640 0E94 0000 		call DumpHex.constprop.0
2112:stk500boot.c  **** 				gRamIndex	+=	256;
 1831               		.loc 1 2112 0
 1832 0644 8091 0000 		lds r24,gRamIndex
 1833 0648 9091 0000 		lds r25,gRamIndex+1
 1834 064c A091 0000 		lds r26,gRamIndex+2
 1835 0650 B091 0000 		lds r27,gRamIndex+3
 1836 0654 8050      		subi r24,lo8(-(256))
 1837 0656 9F4F      		sbci r25,hi8(-(256))
 1838 0658 AF4F      		sbci r26,hlo8(-(256))
 1839 065a BF4F      		sbci r27,hhi8(-(256))
 1840 065c 8093 0000 		sts gRamIndex,r24
 1841 0660 9093 0000 		sts gRamIndex+1,r25
 1842 0664 A093 0000 		sts gRamIndex+2,r26
 1843 0668 B093 0000 		sts gRamIndex+3,r27
 1844 066c 00C0      		rjmp .L212
 1845               	.L74:
2113:stk500boot.c  **** 				break;
2114:stk500boot.c  **** 
2115:stk500boot.c  **** 			case 'V':
2116:stk500boot.c  **** 				PrintFromPROGMEMln(gTextMsg_HELP_MSG_V, 2);
 1846               		.loc 1 2116 0
 1847 066e 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_V)
 1848 0670 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_V)
 1849 0672 62E0      		ldi r22,lo8(2)
 1850 0674 0E94 0000 		call PrintFromPROGMEMln
 1851               	.LVL113:
 1852               	.LBB159:
 1853               	.LBB160:
1656:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_CPU_Name, 0);
 1854               		.loc 1 1656 0
 1855 0678 80E0      		ldi r24,lo8(gTextMsg_CPU_Name)
 1856 067a 90E0      		ldi r25,hi8(gTextMsg_CPU_Name)
 1857 067c 60E0      		ldi r22,lo8(0)
 1858 067e 0E94 0000 		call PrintFromPROGMEMln
1657:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_VECTOR_HEADER, 0);
 1859               		.loc 1 1657 0
 1860 0682 80E0      		ldi r24,lo8(gTextMsg_VECTOR_HEADER)
 1861 0684 90E0      		ldi r25,hi8(gTextMsg_VECTOR_HEADER)
 1862 0686 60E0      		ldi r22,lo8(0)
 1863 0688 0E94 0000 		call PrintFromPROGMEMln
1655:stk500boot.c  **** 	vectorIndex		=	0;
 1864               		.loc 1 1655 0
 1865 068c C55D      		subi r28,lo8(-299)
 1866 068e DE4F      		sbci r29,hi8(-299)
 1867 0690 1982      		std Y+1,__zero_reg__
 1868 0692 1882      		st Y,__zero_reg__
 1869 0694 CB52      		subi r28,lo8(299)
 1870 0696 D140      		sbci r29,hi8(299)
1654:stk500boot.c  **** 	myMemoryPtr		=	0;
 1871               		.loc 1 1654 0
 1872 0698 4424      		clr r4
 1873 069a 5524      		clr r5
 1874 069c 3201      		movw r6,r4
 1875               	.LVL114:
 1876               	.L97:
1662:stk500boot.c  **** 		wordMemoryAddress	=	myMemoryPtr / 2;
 1877               		.loc 1 1662 0
 1878 069e B301      		movw r22,r6
 1879 06a0 A201      		movw r20,r4
 1880 06a2 7695      		lsr r23
 1881 06a4 6795      		ror r22
 1882 06a6 5795      		ror r21
 1883 06a8 4795      		ror r20
 1884 06aa CF5C      		subi r28,lo8(-305)
 1885 06ac DE4F      		sbci r29,hi8(-305)
 1886 06ae 4883      		st Y,r20
 1887 06b0 5983      		std Y+1,r21
 1888 06b2 6A83      		std Y+2,r22
 1889 06b4 7B83      		std Y+3,r23
 1890 06b6 C153      		subi r28,lo8(305)
 1891 06b8 D140      		sbci r29,hi8(305)
 1892               	.LVL115:
1664:stk500boot.c  **** 		PrintDecInt(vectorIndex + 1, 2);
 1893               		.loc 1 1664 0
 1894 06ba C55D      		subi r28,lo8(-299)
 1895 06bc DE4F      		sbci r29,hi8(-299)
 1896 06be 2881      		ld r18,Y
 1897 06c0 3981      		ldd r19,Y+1
 1898 06c2 CB52      		subi r28,lo8(299)
 1899 06c4 D140      		sbci r29,hi8(299)
 1900 06c6 2F5F      		subi r18,lo8(-(1))
 1901 06c8 3F4F      		sbci r19,hi8(-(1))
 1902 06ca C55D      		subi r28,lo8(-299)
 1903 06cc DE4F      		sbci r29,hi8(-299)
 1904 06ce 3983      		std Y+1,r19
 1905 06d0 2883      		st Y,r18
 1906 06d2 CB52      		subi r28,lo8(299)
 1907 06d4 D140      		sbci r29,hi8(299)
 1908 06d6 C901      		movw r24,r18
 1909 06d8 62E0      		ldi r22,lo8(2)
 1910 06da 70E0      		ldi r23,hi8(2)
 1911 06dc 0E94 0000 		call PrintDecInt
 1912               	.LVL116:
1665:stk500boot.c  **** 		sendchar(0x20);
 1913               		.loc 1 1665 0
 1914 06e0 80E2      		ldi r24,lo8(32)
 1915 06e2 0E94 0000 		call sendchar
1666:stk500boot.c  **** 		sendchar('-');
 1916               		.loc 1 1666 0
 1917 06e6 8DE2      		ldi r24,lo8(45)
 1918 06e8 0E94 0000 		call sendchar
1667:stk500boot.c  **** 		sendchar(0x20);
 1919               		.loc 1 1667 0
 1920 06ec 80E2      		ldi r24,lo8(32)
 1921 06ee 0E94 0000 		call sendchar
1668:stk500boot.c  **** 		PrintHexByte((wordMemoryAddress >> 8) & 0x00ff);
 1922               		.loc 1 1668 0
 1923 06f2 80E0      		ldi r24,lo8(0)
 1924 06f4 0E94 0000 		call PrintHexByte
1669:stk500boot.c  **** 		PrintHexByte((wordMemoryAddress) & 0x00ff);
 1925               		.loc 1 1669 0
 1926 06f8 CF5C      		subi r28,lo8(-305)
 1927 06fa DE4F      		sbci r29,hi8(-305)
 1928 06fc 8881      		ld r24,Y
 1929 06fe C153      		subi r28,lo8(305)
 1930 0700 D140      		sbci r29,hi8(305)
 1931 0702 0E94 0000 		call PrintHexByte
1670:stk500boot.c  **** 		sendchar(0x20);
 1932               		.loc 1 1670 0
 1933 0706 80E2      		ldi r24,lo8(32)
 1934 0708 0E94 0000 		call sendchar
1671:stk500boot.c  **** 		sendchar('=');
 1935               		.loc 1 1671 0
 1936 070c 8DE3      		ldi r24,lo8(61)
 1937 070e 0E94 0000 		call sendchar
1672:stk500boot.c  **** 		sendchar(0x20);
 1938               		.loc 1 1672 0
 1939 0712 80E2      		ldi r24,lo8(32)
 1940 0714 0E94 0000 		call sendchar
 1941               	.LVL117:
 1942               	.LBB161:
1677:stk500boot.c  **** 		byte1	=	pgm_read_byte_far(myMemoryPtr++);
 1943               		.loc 1 1677 0
 1944               	/* #APP */
 1945               	 ;  1677 "stk500boot.c" 1
 1946 0718 6BBE      		out 59, r6
 1947 071a F201      		movw r30, r4
 1948 071c 8790      		elpm r8, Z+
 1949               		
 1950               	 ;  0 "" 2
 1951               	.LVL118:
 1952               	/* #NOAPP */
 1953               	.LBE161:
 1954 071e 482D      		mov r20,r8
 1955 0720 50E0      		ldi r21,lo8(0)
 1956 0722 60E0      		ldi r22,lo8(0)
 1957 0724 70E0      		ldi r23,hi8(0)
 1958 0726 C35D      		subi r28,lo8(-301)
 1959 0728 DE4F      		sbci r29,hi8(-301)
 1960 072a 4883      		st Y,r20
 1961 072c 5983      		std Y+1,r21
 1962 072e 6A83      		std Y+2,r22
 1963 0730 7B83      		std Y+3,r23
 1964 0732 CD52      		subi r28,lo8(301)
 1965 0734 D140      		sbci r29,hi8(301)
 1966               	.LVL119:
 1967               	.LBB162:
 1968 0736 D301      		movw r26,r6
 1969 0738 C201      		movw r24,r4
 1970 073a 0196      		adiw r24,1
 1971 073c A11D      		adc r26,__zero_reg__
 1972 073e B11D      		adc r27,__zero_reg__
 1973               	.LBE162:
 1974               	.LBB163:
1678:stk500boot.c  **** 		byte2	=	pgm_read_byte_far(myMemoryPtr++);
 1975               		.loc 1 1678 0
 1976               	/* #APP */
 1977               	 ;  1678 "stk500boot.c" 1
 1978 0740 ABBF      		out 59, r26
 1979 0742 FC01      		movw r30, r24
 1980 0744 8791      		elpm r24, Z+
 1981               		
 1982               	 ;  0 "" 2
 1983               	.LVL120:
 1984               	/* #NOAPP */
 1985               	.LBE163:
 1986 0746 282F      		mov r18,r24
 1987 0748 30E0      		ldi r19,lo8(0)
 1988 074a 40E0      		ldi r20,lo8(0)
 1989 074c 50E0      		ldi r21,hi8(0)
 1990               	.LVL121:
 1991 074e CB5C      		subi r28,lo8(-309)
 1992 0750 DE4F      		sbci r29,hi8(-309)
 1993 0752 2883      		st Y,r18
 1994 0754 3983      		std Y+1,r19
 1995 0756 4A83      		std Y+2,r20
 1996 0758 5B83      		std Y+3,r21
 1997 075a C553      		subi r28,lo8(309)
 1998 075c D140      		sbci r29,hi8(309)
 1999               	.LVL122:
 2000               	.LBB164:
1679:stk500boot.c  **** 		byte3	=	pgm_read_byte_far(myMemoryPtr++);
 2001               		.loc 1 1679 0
 2002 075e 9301      		movw r18,r6
 2003 0760 8201      		movw r16,r4
 2004 0762 0D5F      		subi r16,lo8(-(3))
 2005 0764 1F4F      		sbci r17,hi8(-(3))
 2006 0766 2F4F      		sbci r18,hlo8(-(3))
 2007 0768 3F4F      		sbci r19,hhi8(-(3))
 2008               	.LVL123:
 2009               	.LBE164:
 2010               	.LBB165:
1678:stk500boot.c  **** 		byte2	=	pgm_read_byte_far(myMemoryPtr++);
 2011               		.loc 1 1678 0
 2012 076a B301      		movw r22,r6
 2013 076c A201      		movw r20,r4
 2014 076e 4E5F      		subi r20,lo8(-(2))
 2015 0770 5F4F      		sbci r21,hi8(-(2))
 2016 0772 6F4F      		sbci r22,hlo8(-(2))
 2017 0774 7F4F      		sbci r23,hhi8(-(2))
 2018               	.LBE165:
 2019               	.LBB166:
1679:stk500boot.c  **** 		byte3	=	pgm_read_byte_far(myMemoryPtr++);
 2020               		.loc 1 1679 0
 2021               	/* #APP */
 2022               	 ;  1679 "stk500boot.c" 1
 2023 0776 6BBF      		out 59, r22
 2024 0778 FA01      		movw r30, r20
 2025 077a 3790      		elpm r3, Z+
 2026               		
 2027               	 ;  0 "" 2
 2028               	.LVL124:
 2029               	/* #NOAPP */
 2030               	.LBE166:
 2031               	.LBB167:
1680:stk500boot.c  **** 		byte4	=	pgm_read_byte_far(myMemoryPtr++);
 2032               		.loc 1 1680 0
 2033 077c 44E0      		ldi r20,lo8(4)
 2034 077e 50E0      		ldi r21,hi8(4)
 2035 0780 60E0      		ldi r22,hlo8(4)
 2036 0782 70E0      		ldi r23,hhi8(4)
 2037 0784 440E      		add r4,r20
 2038 0786 551E      		adc r5,r21
 2039 0788 661E      		adc r6,r22
 2040 078a 771E      		adc r7,r23
 2041               	.LVL125:
 2042               	/* #APP */
 2043               	 ;  1680 "stk500boot.c" 1
 2044 078c 2BBF      		out 59, r18
 2045 078e F801      		movw r30, r16
 2046 0790 1791      		elpm r17, Z+
 2047               		
 2048               	 ;  0 "" 2
 2049               	.LVL126:
 2050               	/* #NOAPP */
 2051               	.LBE167:
1687:stk500boot.c  **** 		word1	=	(byte2 << 8) + byte1;
 2052               		.loc 1 1687 0
 2053 0792 CB5C      		subi r28,lo8(-309)
 2054 0794 DE4F      		sbci r29,hi8(-309)
 2055 0796 2881      		ld r18,Y
 2056 0798 3981      		ldd r19,Y+1
 2057 079a 4A81      		ldd r20,Y+2
 2058 079c 5B81      		ldd r21,Y+3
 2059 079e C553      		subi r28,lo8(309)
 2060 07a0 D140      		sbci r29,hi8(309)
 2061 07a2 CC24      		clr r12
 2062 07a4 D22E      		mov r13,r18
 2063 07a6 E32E      		mov r14,r19
 2064 07a8 F42E      		mov r15,r20
 2065 07aa C35D      		subi r28,lo8(-301)
 2066 07ac DE4F      		sbci r29,hi8(-301)
 2067 07ae 4881      		ld r20,Y
 2068 07b0 5981      		ldd r21,Y+1
 2069 07b2 6A81      		ldd r22,Y+2
 2070 07b4 7B81      		ldd r23,Y+3
 2071 07b6 CD52      		subi r28,lo8(301)
 2072 07b8 D140      		sbci r29,hi8(301)
 2073 07ba C40E      		add r12,r20
 2074 07bc D51E      		adc r13,r21
 2075 07be E61E      		adc r14,r22
 2076 07c0 F71E      		adc r15,r23
 2077               	.LVL127:
1691:stk500boot.c  **** 		PrintHexByte(byte2);
 2078               		.loc 1 1691 0
 2079 07c2 0E94 0000 		call PrintHexByte
 2080               	.LVL128:
1692:stk500boot.c  **** 		sendchar(0x20);
 2081               		.loc 1 1692 0
 2082 07c6 80E2      		ldi r24,lo8(32)
 2083 07c8 0E94 0000 		call sendchar
1693:stk500boot.c  **** 		PrintHexByte(byte1);
 2084               		.loc 1 1693 0
 2085 07cc 882D      		mov r24,r8
 2086 07ce 0E94 0000 		call PrintHexByte
1694:stk500boot.c  **** 		sendchar(0x20);
 2087               		.loc 1 1694 0
 2088 07d2 80E2      		ldi r24,lo8(32)
 2089 07d4 0E94 0000 		call sendchar
1695:stk500boot.c  **** 		PrintHexByte(byte4);
 2090               		.loc 1 1695 0
 2091 07d8 812F      		mov r24,r17
 2092 07da 0E94 0000 		call PrintHexByte
1696:stk500boot.c  **** 		sendchar(0x20);
 2093               		.loc 1 1696 0
 2094 07de 80E2      		ldi r24,lo8(32)
 2095 07e0 0E94 0000 		call sendchar
1697:stk500boot.c  **** 		PrintHexByte(byte3);
 2096               		.loc 1 1697 0
 2097 07e4 832D      		mov r24,r3
 2098 07e6 0E94 0000 		call PrintHexByte
1698:stk500boot.c  **** 		sendchar(0x20);
 2099               		.loc 1 1698 0
 2100 07ea 80E2      		ldi r24,lo8(32)
 2101 07ec 0E94 0000 		call sendchar
1700:stk500boot.c  **** 		if (word1 == 0xffff)
 2102               		.loc 1 1700 0
 2103 07f0 5FEF      		ldi r21,lo8(65535)
 2104 07f2 C516      		cp r12,r21
 2105 07f4 5FEF      		ldi r21,hi8(65535)
 2106 07f6 D506      		cpc r13,r21
 2107 07f8 50E0      		ldi r21,hlo8(65535)
 2108 07fa E506      		cpc r14,r21
 2109 07fc 50E0      		ldi r21,hhi8(65535)
 2110 07fe F506      		cpc r15,r21
 2111 0800 01F4      		brne .L94
1702:stk500boot.c  **** 			PrintFromPROGMEM(gTextMsg_noVector, 0);
 2112               		.loc 1 1702 0
 2113 0802 80E0      		ldi r24,lo8(gTextMsg_noVector)
 2114 0804 90E0      		ldi r25,hi8(gTextMsg_noVector)
 2115 0806 60E0      		ldi r22,lo8(0)
 2116 0808 0E94 0000 		call PrintFromPROGMEM
 2117 080c 00C0      		rjmp .L95
 2118               	.L94:
1704:stk500boot.c  **** 		else if ((word1 & 0xc000) == 0xc000)
 2119               		.loc 1 1704 0
 2120 080e D701      		movw r26,r14
 2121 0810 C601      		movw r24,r12
 2122 0812 8070      		andi r24,lo8(49152)
 2123 0814 907C      		andi r25,hi8(49152)
 2124 0816 A070      		andi r26,hlo8(49152)
 2125 0818 B070      		andi r27,hhi8(49152)
 2126 081a 8030      		cpi r24,lo8(49152)
 2127 081c 60EC      		ldi r22,hi8(49152)
 2128 081e 9607      		cpc r25,r22
 2129 0820 60E0      		ldi r22,hlo8(49152)
 2130 0822 A607      		cpc r26,r22
 2131 0824 60E0      		ldi r22,hhi8(49152)
 2132 0826 B607      		cpc r27,r22
 2133 0828 01F4      		brne .L96
1707:stk500boot.c  **** 			realitiveAddr	=	word1 & 0x3FFF;
 2134               		.loc 1 1707 0
 2135 082a 7FEF      		ldi r23,lo8(16383)
 2136 082c 872E      		mov r8,r23
 2137 082e 7FE3      		ldi r23,hi8(16383)
 2138 0830 972E      		mov r9,r23
 2139 0832 A12C      		mov r10,__zero_reg__
 2140 0834 B12C      		mov r11,__zero_reg__
 2141               	.LVL129:
 2142 0836 8C20      		and r8,r12
 2143 0838 9D20      		and r9,r13
 2144 083a AE20      		and r10,r14
 2145 083c BF20      		and r11,r15
 2146               	.LVL130:
1708:stk500boot.c  **** 			absoluteAddr	=	wordMemoryAddress + realitiveAddr;	//*	add the offset to the current address
 2147               		.loc 1 1708 0
 2148 083e CF5C      		subi r28,lo8(-305)
 2149 0840 DE4F      		sbci r29,hi8(-305)
 2150 0842 C880      		ld r12,Y
 2151 0844 D980      		ldd r13,Y+1
 2152 0846 EA80      		ldd r14,Y+2
 2153 0848 FB80      		ldd r15,Y+3
 2154 084a C153      		subi r28,lo8(305)
 2155 084c D140      		sbci r29,hi8(305)
 2156               	.LVL131:
 2157 084e C80C      		add r12,r8
 2158 0850 D91C      		adc r13,r9
 2159 0852 EA1C      		adc r14,r10
 2160 0854 FB1C      		adc r15,r11
 2161               	.LVL132:
1709:stk500boot.c  **** 			absoluteAddr	=	absoluteAddr << 1;					//*	multiply by 2 for byte address
 2162               		.loc 1 1709 0
 2163 0856 CC0C      		lsl r12
 2164 0858 DD1C      		rol r13
 2165 085a EE1C      		rol r14
 2166 085c FF1C      		rol r15
 2167               	.LVL133:
1711:stk500boot.c  **** 			PrintFromPROGMEM(gTextMsg_rjmp, 0);
 2168               		.loc 1 1711 0
 2169 085e 80E0      		ldi r24,lo8(gTextMsg_rjmp)
 2170 0860 90E0      		ldi r25,hi8(gTextMsg_rjmp)
 2171 0862 60E0      		ldi r22,lo8(0)
 2172 0864 0E94 0000 		call PrintFromPROGMEM
 2173 0868 00C0      		rjmp .L220
 2174               	.LVL134:
 2175               	.L96:
1721:stk500boot.c  **** 		else if ((word1 & 0xfE0E) == 0x940c)
 2176               		.loc 1 1721 0
 2177 086a D701      		movw r26,r14
 2178 086c C601      		movw r24,r12
 2179 086e 8E70      		andi r24,lo8(65038)
 2180 0870 9E7F      		andi r25,hi8(65038)
 2181 0872 A070      		andi r26,hlo8(65038)
 2182 0874 B070      		andi r27,hhi8(65038)
 2183 0876 8C30      		cpi r24,lo8(37900)
 2184 0878 74E9      		ldi r23,hi8(37900)
 2185 087a 9707      		cpc r25,r23
 2186 087c 70E0      		ldi r23,hlo8(37900)
 2187 087e A707      		cpc r26,r23
 2188 0880 70E0      		ldi r23,hhi8(37900)
 2189 0882 B707      		cpc r27,r23
 2190 0884 01F0      		breq .+2
 2191 0886 00C0      		rjmp .L95
1680:stk500boot.c  **** 		byte4	=	pgm_read_byte_far(myMemoryPtr++);
 2192               		.loc 1 1680 0
 2193 0888 812F      		mov r24,r17
 2194 088a 90E0      		ldi r25,lo8(0)
 2195 088c A0E0      		ldi r26,lo8(0)
 2196 088e B0E0      		ldi r27,hi8(0)
1688:stk500boot.c  **** 		word2	=	(byte4 << 8) + byte3;
 2197               		.loc 1 1688 0
 2198 0890 8824      		clr r8
 2199 0892 982E      		mov r9,r24
 2200 0894 A92E      		mov r10,r25
 2201 0896 BA2E      		mov r11,r26
 2202               	.LVL135:
1724:stk500boot.c  **** 			myFullAddress	=	((byte1 & 0x01) << 16) +
 2203               		.loc 1 1724 0
 2204 0898 830C      		add r8,r3
 2205 089a 911C      		adc r9,__zero_reg__
 2206 089c A11C      		adc r10,__zero_reg__
 2207 089e B11C      		adc r11,__zero_reg__
 2208 08a0 C35D      		subi r28,lo8(-301)
 2209 08a2 DE4F      		sbci r29,hi8(-301)
 2210 08a4 8881      		ld r24,Y
 2211 08a6 9981      		ldd r25,Y+1
 2212 08a8 AA81      		ldd r26,Y+2
 2213 08aa BB81      		ldd r27,Y+3
 2214 08ac CD52      		subi r28,lo8(301)
 2215 08ae D140      		sbci r29,hi8(301)
 2216 08b0 8170      		andi r24,lo8(1)
 2217 08b2 9070      		andi r25,hi8(1)
 2218 08b4 A070      		andi r26,hlo8(1)
 2219 08b6 B070      		andi r27,hhi8(1)
 2220 08b8 DC01      		movw r26,r24
 2221 08ba 9927      		clr r25
 2222 08bc 8827      		clr r24
1725:stk500boot.c  **** 								((byte1 & 0xf0) << 17) +
 2223               		.loc 1 1725 0
 2224 08be 880E      		add r8,r24
 2225 08c0 991E      		adc r9,r25
 2226 08c2 AA1E      		adc r10,r26
 2227 08c4 BB1E      		adc r11,r27
 2228 08c6 C35D      		subi r28,lo8(-301)
 2229 08c8 DE4F      		sbci r29,hi8(-301)
 2230 08ca 8881      		ld r24,Y
 2231 08cc 9981      		ldd r25,Y+1
 2232 08ce AA81      		ldd r26,Y+2
 2233 08d0 BB81      		ldd r27,Y+3
 2234 08d2 CD52      		subi r28,lo8(301)
 2235 08d4 D140      		sbci r29,hi8(301)
 2236 08d6 807F      		andi r24,lo8(240)
 2237 08d8 9070      		andi r25,hi8(240)
 2238 08da A070      		andi r26,hlo8(240)
 2239 08dc B070      		andi r27,hhi8(240)
 2240 08de 41E1      		ldi r20,17
 2241 08e0 880F      	1:	lsl r24
 2242 08e2 991F      		rol r25
 2243 08e4 AA1F      		rol r26
 2244 08e6 BB1F      		rol r27
 2245 08e8 4A95      		dec r20
 2246 08ea 01F4      		brne 1b
1688:stk500boot.c  **** 		word2	=	(byte4 << 8) + byte3;
 2247               		.loc 1 1688 0
 2248 08ec 880E      		add r8,r24
 2249 08ee 991E      		adc r9,r25
 2250 08f0 AA1E      		adc r10,r26
 2251 08f2 BB1E      		adc r11,r27
1726:stk500boot.c  **** 								((byte2 & 0x01) << 21) +
 2252               		.loc 1 1726 0
 2253 08f4 CB5C      		subi r28,lo8(-309)
 2254 08f6 DE4F      		sbci r29,hi8(-309)
 2255 08f8 8881      		ld r24,Y
 2256 08fa 9981      		ldd r25,Y+1
 2257 08fc AA81      		ldd r26,Y+2
 2258 08fe BB81      		ldd r27,Y+3
 2259 0900 C553      		subi r28,lo8(309)
 2260 0902 D140      		sbci r29,hi8(309)
 2261 0904 8170      		andi r24,lo8(1)
 2262 0906 9070      		andi r25,hi8(1)
 2263 0908 A070      		andi r26,hlo8(1)
 2264 090a B070      		andi r27,hhi8(1)
 2265 090c 55E1      		ldi r21,21
 2266 090e 880F      	1:	lsl r24
 2267 0910 991F      		rol r25
 2268 0912 AA1F      		rol r26
 2269 0914 BB1F      		rol r27
 2270 0916 5A95      		dec r21
 2271 0918 01F4      		brne 1b
1724:stk500boot.c  **** 			myFullAddress	=	((byte1 & 0x01) << 16) +
 2272               		.loc 1 1724 0
 2273 091a 880E      		add r8,r24
 2274 091c 991E      		adc r9,r25
 2275 091e AA1E      		adc r10,r26
 2276 0920 BB1E      		adc r11,r27
 2277               	.LVL136:
1729:stk500boot.c  **** 			absoluteAddr	=	myFullAddress << 1;
 2278               		.loc 1 1729 0
 2279 0922 7501      		movw r14,r10
 2280 0924 6401      		movw r12,r8
 2281               	.LVL137:
 2282 0926 CC0C      		lsl r12
 2283 0928 DD1C      		rol r13
 2284 092a EE1C      		rol r14
 2285 092c FF1C      		rol r15
1731:stk500boot.c  **** 			PrintFromPROGMEM(gTextMsg_jmp, 0);
 2286               		.loc 1 1731 0
 2287 092e 80E0      		ldi r24,lo8(gTextMsg_jmp)
 2288 0930 90E0      		ldi r25,hi8(gTextMsg_jmp)
 2289 0932 60E0      		ldi r22,lo8(0)
 2290 0934 0E94 0000 		call PrintFromPROGMEM
1732:stk500boot.c  **** 			PrintHexByte((myFullAddress >> 16) & 0x00ff);
 2291               		.loc 1 1732 0
 2292 0938 8A2D      		mov r24,r10
 2293 093a 0E94 0000 		call PrintHexByte
 2294               	.LVL138:
 2295               	.L220:
1733:stk500boot.c  **** 			PrintHexByte((myFullAddress >> 8) & 0x00ff);
 2296               		.loc 1 1733 0
 2297 093e 892D      		mov r24,r9
 2298 0940 0E94 0000 		call PrintHexByte
1734:stk500boot.c  **** 			PrintHexByte((myFullAddress) & 0x00ff);
 2299               		.loc 1 1734 0
 2300 0944 882D      		mov r24,r8
 2301 0946 0E94 0000 		call PrintHexByte
1735:stk500boot.c  **** 			sendchar(0x20);
 2302               		.loc 1 1735 0
 2303 094a 80E2      		ldi r24,lo8(32)
 2304 094c 0E94 0000 		call sendchar
1736:stk500boot.c  **** 			sendchar('>');
 2305               		.loc 1 1736 0
 2306 0950 8EE3      		ldi r24,lo8(62)
 2307 0952 0E94 0000 		call sendchar
1737:stk500boot.c  **** 			PrintHexByte((absoluteAddr >> 16) & 0x00ff);
 2308               		.loc 1 1737 0
 2309 0956 8E2D      		mov r24,r14
 2310 0958 0E94 0000 		call PrintHexByte
1738:stk500boot.c  **** 			PrintHexByte((absoluteAddr >> 8) & 0x00ff);
 2311               		.loc 1 1738 0
 2312 095c 8D2D      		mov r24,r13
 2313 095e 0E94 0000 		call PrintHexByte
1739:stk500boot.c  **** 			PrintHexByte((absoluteAddr) & 0x00ff);
 2314               		.loc 1 1739 0
 2315 0962 8C2D      		mov r24,r12
 2316 0964 0E94 0000 		call PrintHexByte
 2317               	.L95:
1751:stk500boot.c  **** 		PrintNewLine();
 2318               		.loc 1 1751 0
 2319 0968 0E94 0000 		call PrintNewLine
 2320               	.LVL139:
1660:stk500boot.c  **** 	while (vectorIndex < kInterruptVectorCount)
 2321               		.loc 1 1660 0
 2322 096c C55D      		subi r28,lo8(-299)
 2323 096e DE4F      		sbci r29,hi8(-299)
 2324 0970 2881      		ld r18,Y
 2325 0972 3981      		ldd r19,Y+1
 2326 0974 CB52      		subi r28,lo8(299)
 2327 0976 D140      		sbci r29,hi8(299)
 2328 0978 2D34      		cpi r18,77
 2329 097a 3105      		cpc r19,__zero_reg__
 2330 097c 01F0      		breq .+2
 2331 097e 00C0      		rjmp .L97
 2332 0980 00C0      		rjmp .L212
 2333               	.LVL140:
 2334               	.L234:
 2335               	.LBE160:
 2336               	.LBE159:
2117:stk500boot.c  **** 				VectorDisplay();
2118:stk500boot.c  **** 				break;
2119:stk500boot.c  **** 
2120:stk500boot.c  **** 			case 'Y':
2121:stk500boot.c  **** 				PrintFromPROGMEMln(gTextMsg_HELP_MSG_Y, 2);
 2337               		.loc 1 2121 0
 2338 0982 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_Y)
 2339 0984 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_Y)
 2340 0986 62E0      		ldi r22,lo8(2)
 2341 0988 0E94 0000 		call PrintFromPROGMEMln
 2342               	.LBB168:
 2343               	.LBB169:
1825:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_WHAT_PORT, 0);
 2344               		.loc 1 1825 0
 2345 098c 80E0      		ldi r24,lo8(gTextMsg_WHAT_PORT)
 2346 098e 90E0      		ldi r25,hi8(gTextMsg_WHAT_PORT)
 2347 0990 60E0      		ldi r22,lo8(0)
 2348 0992 0E94 0000 		call PrintFromPROGMEM
1827:stk500boot.c  **** 	portLetter	=	recchar();
 2349               		.loc 1 1827 0
 2350 0996 0E94 0000 		call recchar
 2351               	.LVL141:
1828:stk500boot.c  **** 	portLetter	=	portLetter & 0x5f;
 2352               		.loc 1 1828 0
 2353 099a 182F      		mov r17,r24
 2354               	.LVL142:
 2355 099c 1F75      		andi r17,lo8(95)
 2356               	.LVL143:
1829:stk500boot.c  **** 	sendchar(portLetter);
 2357               		.loc 1 1829 0
 2358 099e 812F      		mov r24,r17
 2359 09a0 0E94 0000 		call sendchar
1830:stk500boot.c  **** 	PrintNewLine();
 2360               		.loc 1 1830 0
 2361 09a4 0E94 0000 		call PrintNewLine
1832:stk500boot.c  **** 	if ((portLetter >= 'A') && (portLetter <= 'Z'))
 2362               		.loc 1 1832 0
 2363 09a8 812F      		mov r24,r17
 2364 09aa 8154      		subi r24,lo8(-(-65))
 2365 09ac 8A31      		cpi r24,lo8(26)
 2366 09ae 00F0      		brlo .+2
 2367 09b0 00C0      		rjmp .L98
 2368               	.LVL144:
1835:stk500boot.c  **** 		switch(portLetter)
 2369               		.loc 1 1835 0
 2370 09b2 1434      		cpi r17,lo8(68)
 2371 09b4 01F4      		brne .+2
 2372 09b6 00C0      		rjmp .L103
 2373 09b8 1534      		cpi r17,lo8(69)
 2374 09ba 00F4      		brsh .L107
 2375 09bc 1234      		cpi r17,lo8(66)
 2376 09be 01F0      		breq .L101
 2377 09c0 1334      		cpi r17,lo8(67)
 2378 09c2 00F4      		brsh .L102
 2379 09c4 1134      		cpi r17,lo8(65)
 2380 09c6 01F0      		breq .+2
 2381 09c8 00C0      		rjmp .L99
 2382 09ca 00C0      		rjmp .L235
 2383               	.L107:
 2384 09cc 1634      		cpi r17,lo8(70)
 2385 09ce 01F4      		brne .+2
 2386 09d0 00C0      		rjmp .L105
 2387 09d2 1634      		cpi r17,lo8(70)
 2388 09d4 00F4      		brsh .+2
 2389 09d6 00C0      		rjmp .L104
 2390 09d8 1734      		cpi r17,lo8(71)
 2391 09da 01F0      		breq .+2
 2392 09dc 00C0      		rjmp .L99
 2393 09de 00C0      		rjmp .L236
 2394               	.L235:
1839:stk500boot.c  **** 				DDRA	=	0xff;
 2395               		.loc 1 1839 0
 2396 09e0 8FEF      		ldi r24,lo8(-1)
 2397 09e2 81B9      		out 33-32,r24
 2398 09e4 00C0      		rjmp .L108
 2399               	.L109:
1842:stk500boot.c  **** 					PORTA	^=	0xff;
 2400               		.loc 1 1842 0
 2401 09e6 82B1      		in r24,34-32
 2402 09e8 8095      		com r24
 2403 09ea 82B9      		out 34-32,r24
1843:stk500boot.c  **** 					delay_ms(200);
 2404               		.loc 1 1843 0
 2405 09ec 88EC      		ldi r24,lo8(200)
 2406 09ee 90E0      		ldi r25,hi8(200)
 2407 09f0 0E94 0000 		call delay_ms
 2408               	.L108:
 2409               	.LBB170:
 2410               	.LBB171:
 488:stk500boot.c  **** 	return(UART_STATUS_REG & (1 << UART_RECEIVE_COMPLETE));	// wait for data
 2411               		.loc 1 488 0
 2412 09f4 8091 C000 		lds r24,192
 2413               	.LBE171:
 2414               	.LBE170:
1840:stk500boot.c  **** 				while (!Serial_Available())
 2415               		.loc 1 1840 0
 2416 09f8 87FF      		sbrs r24,7
 2417 09fa 00C0      		rjmp .L109
1845:stk500boot.c  **** 				PORTA	=	0;
 2418               		.loc 1 1845 0
 2419 09fc 12B8      		out 34-32,__zero_reg__
 2420 09fe 00C0      		rjmp .L110
 2421               	.L101:
1851:stk500boot.c  **** 				DDRB	=	0xff;
 2422               		.loc 1 1851 0
 2423 0a00 8FEF      		ldi r24,lo8(-1)
 2424 0a02 84B9      		out 36-32,r24
 2425 0a04 00C0      		rjmp .L111
 2426               	.L112:
1854:stk500boot.c  **** 					PORTB	^=	0xff;
 2427               		.loc 1 1854 0
 2428 0a06 85B1      		in r24,37-32
 2429 0a08 8095      		com r24
 2430 0a0a 85B9      		out 37-32,r24
1855:stk500boot.c  **** 					delay_ms(200);
 2431               		.loc 1 1855 0
 2432 0a0c 88EC      		ldi r24,lo8(200)
 2433 0a0e 90E0      		ldi r25,hi8(200)
 2434 0a10 0E94 0000 		call delay_ms
 2435               	.L111:
 2436               	.LBB172:
 2437               	.LBB173:
 488:stk500boot.c  **** 	return(UART_STATUS_REG & (1 << UART_RECEIVE_COMPLETE));	// wait for data
 2438               		.loc 1 488 0
 2439 0a14 8091 C000 		lds r24,192
 2440               	.LBE173:
 2441               	.LBE172:
1852:stk500boot.c  **** 				while (!Serial_Available())
 2442               		.loc 1 1852 0
 2443 0a18 87FF      		sbrs r24,7
 2444 0a1a 00C0      		rjmp .L112
1857:stk500boot.c  **** 				PORTB	=	0;
 2445               		.loc 1 1857 0
 2446 0a1c 15B8      		out 37-32,__zero_reg__
 2447 0a1e 00C0      		rjmp .L110
 2448               	.L102:
1863:stk500boot.c  **** 				DDRC	=	0xff;
 2449               		.loc 1 1863 0
 2450 0a20 8FEF      		ldi r24,lo8(-1)
 2451 0a22 87B9      		out 39-32,r24
 2452 0a24 00C0      		rjmp .L113
 2453               	.L114:
1866:stk500boot.c  **** 					PORTC	^=	0xff;
 2454               		.loc 1 1866 0
 2455 0a26 88B1      		in r24,40-32
 2456 0a28 8095      		com r24
 2457 0a2a 88B9      		out 40-32,r24
1867:stk500boot.c  **** 					delay_ms(200);
 2458               		.loc 1 1867 0
 2459 0a2c 88EC      		ldi r24,lo8(200)
 2460 0a2e 90E0      		ldi r25,hi8(200)
 2461 0a30 0E94 0000 		call delay_ms
 2462               	.L113:
 2463               	.LBB174:
 2464               	.LBB175:
 488:stk500boot.c  **** 	return(UART_STATUS_REG & (1 << UART_RECEIVE_COMPLETE));	// wait for data
 2465               		.loc 1 488 0
 2466 0a34 8091 C000 		lds r24,192
 2467               	.LBE175:
 2468               	.LBE174:
1864:stk500boot.c  **** 				while (!Serial_Available())
 2469               		.loc 1 1864 0
 2470 0a38 87FF      		sbrs r24,7
 2471 0a3a 00C0      		rjmp .L114
1869:stk500boot.c  **** 				PORTC	=	0;
 2472               		.loc 1 1869 0
 2473 0a3c 18B8      		out 40-32,__zero_reg__
 2474 0a3e 00C0      		rjmp .L110
 2475               	.L103:
1875:stk500boot.c  **** 				DDRD	=	0xff;
 2476               		.loc 1 1875 0
 2477 0a40 8FEF      		ldi r24,lo8(-1)
 2478 0a42 8AB9      		out 42-32,r24
 2479 0a44 00C0      		rjmp .L115
 2480               	.L116:
1878:stk500boot.c  **** 					PORTD	^=	0xff;
 2481               		.loc 1 1878 0
 2482 0a46 8BB1      		in r24,43-32
 2483 0a48 8095      		com r24
 2484 0a4a 8BB9      		out 43-32,r24
1879:stk500boot.c  **** 					delay_ms(200);
 2485               		.loc 1 1879 0
 2486 0a4c 88EC      		ldi r24,lo8(200)
 2487 0a4e 90E0      		ldi r25,hi8(200)
 2488 0a50 0E94 0000 		call delay_ms
 2489               	.L115:
 2490               	.LBB176:
 2491               	.LBB177:
 488:stk500boot.c  **** 	return(UART_STATUS_REG & (1 << UART_RECEIVE_COMPLETE));	// wait for data
 2492               		.loc 1 488 0
 2493 0a54 8091 C000 		lds r24,192
 2494               	.LBE177:
 2495               	.LBE176:
1876:stk500boot.c  **** 				while (!Serial_Available())
 2496               		.loc 1 1876 0
 2497 0a58 87FF      		sbrs r24,7
 2498 0a5a 00C0      		rjmp .L116
1881:stk500boot.c  **** 				PORTD	=	0;
 2499               		.loc 1 1881 0
 2500 0a5c 1BB8      		out 43-32,__zero_reg__
 2501 0a5e 00C0      		rjmp .L110
 2502               	.L104:
1887:stk500boot.c  **** 				DDRE	=	0xff;
 2503               		.loc 1 1887 0
 2504 0a60 8FEF      		ldi r24,lo8(-1)
 2505 0a62 8DB9      		out 45-32,r24
 2506 0a64 00C0      		rjmp .L117
 2507               	.L118:
1890:stk500boot.c  **** 					PORTE	^=	0xff;
 2508               		.loc 1 1890 0
 2509 0a66 8EB1      		in r24,46-32
 2510 0a68 8095      		com r24
 2511 0a6a 8EB9      		out 46-32,r24
1891:stk500boot.c  **** 					delay_ms(200);
 2512               		.loc 1 1891 0
 2513 0a6c 88EC      		ldi r24,lo8(200)
 2514 0a6e 90E0      		ldi r25,hi8(200)
 2515 0a70 0E94 0000 		call delay_ms
 2516               	.L117:
 2517               	.LBB178:
 2518               	.LBB179:
 488:stk500boot.c  **** 	return(UART_STATUS_REG & (1 << UART_RECEIVE_COMPLETE));	// wait for data
 2519               		.loc 1 488 0
 2520 0a74 8091 C000 		lds r24,192
 2521               	.LBE179:
 2522               	.LBE178:
1888:stk500boot.c  **** 				while (!Serial_Available())
 2523               		.loc 1 1888 0
 2524 0a78 87FF      		sbrs r24,7
 2525 0a7a 00C0      		rjmp .L118
1893:stk500boot.c  **** 				PORTE	=	0;
 2526               		.loc 1 1893 0
 2527 0a7c 1EB8      		out 46-32,__zero_reg__
 2528 0a7e 00C0      		rjmp .L110
 2529               	.L105:
1899:stk500boot.c  **** 				DDRF	=	0xff;
 2530               		.loc 1 1899 0
 2531 0a80 8FEF      		ldi r24,lo8(-1)
 2532 0a82 80BB      		out 48-32,r24
 2533 0a84 00C0      		rjmp .L119
 2534               	.L120:
1902:stk500boot.c  **** 					PORTF	^=	0xff;
 2535               		.loc 1 1902 0
 2536 0a86 81B3      		in r24,49-32
 2537 0a88 8095      		com r24
 2538 0a8a 81BB      		out 49-32,r24
1903:stk500boot.c  **** 					delay_ms(200);
 2539               		.loc 1 1903 0
 2540 0a8c 88EC      		ldi r24,lo8(200)
 2541 0a8e 90E0      		ldi r25,hi8(200)
 2542 0a90 0E94 0000 		call delay_ms
 2543               	.L119:
 2544               	.LBB180:
 2545               	.LBB181:
 488:stk500boot.c  **** 	return(UART_STATUS_REG & (1 << UART_RECEIVE_COMPLETE));	// wait for data
 2546               		.loc 1 488 0
 2547 0a94 8091 C000 		lds r24,192
 2548               	.LBE181:
 2549               	.LBE180:
1900:stk500boot.c  **** 				while (!Serial_Available())
 2550               		.loc 1 1900 0
 2551 0a98 87FF      		sbrs r24,7
 2552 0a9a 00C0      		rjmp .L120
1905:stk500boot.c  **** 				PORTF	=	0;
 2553               		.loc 1 1905 0
 2554 0a9c 11BA      		out 49-32,__zero_reg__
 2555 0a9e 00C0      		rjmp .L110
 2556               	.L236:
1911:stk500boot.c  **** 				DDRG	=	0xff;
 2557               		.loc 1 1911 0
 2558 0aa0 8FEF      		ldi r24,lo8(-1)
 2559 0aa2 83BB      		out 51-32,r24
 2560 0aa4 00C0      		rjmp .L121
 2561               	.L122:
1914:stk500boot.c  **** 					PORTG	^=	0xff;
 2562               		.loc 1 1914 0
 2563 0aa6 84B3      		in r24,52-32
 2564 0aa8 8095      		com r24
 2565 0aaa 84BB      		out 52-32,r24
1915:stk500boot.c  **** 					delay_ms(200);
 2566               		.loc 1 1915 0
 2567 0aac 88EC      		ldi r24,lo8(200)
 2568 0aae 90E0      		ldi r25,hi8(200)
 2569 0ab0 0E94 0000 		call delay_ms
 2570               	.L121:
 2571               	.LBB182:
 2572               	.LBB183:
 488:stk500boot.c  **** 	return(UART_STATUS_REG & (1 << UART_RECEIVE_COMPLETE));	// wait for data
 2573               		.loc 1 488 0
 2574 0ab4 8091 C000 		lds r24,192
 2575               	.LBE183:
 2576               	.LBE182:
1912:stk500boot.c  **** 				while (!Serial_Available())
 2577               		.loc 1 1912 0
 2578 0ab8 87FF      		sbrs r24,7
 2579 0aba 00C0      		rjmp .L122
1917:stk500boot.c  **** 				PORTG	=	0;
 2580               		.loc 1 1917 0
 2581 0abc 14BA      		out 52-32,__zero_reg__
 2582 0abe 00C0      		rjmp .L110
 2583               	.L99:
1982:stk500boot.c  **** 				PrintFromPROGMEMln(gTextMsg_PortNotSupported, 0);
 2584               		.loc 1 1982 0
 2585 0ac0 80E0      		ldi r24,lo8(gTextMsg_PortNotSupported)
 2586 0ac2 90E0      		ldi r25,hi8(gTextMsg_PortNotSupported)
 2587 0ac4 00C0      		rjmp .L218
 2588               	.LVL145:
 2589               	.L110:
1988:stk500boot.c  **** 			recchar();
 2590               		.loc 1 1988 0
 2591 0ac6 0E94 0000 		call recchar
 2592 0aca 00C0      		rjmp .L212
 2593               	.LVL146:
 2594               	.L98:
1993:stk500boot.c  **** 		PrintFromPROGMEMln(gTextMsg_MustBeLetter, 0);
 2595               		.loc 1 1993 0
 2596 0acc 80E0      		ldi r24,lo8(gTextMsg_MustBeLetter)
 2597 0ace 90E0      		ldi r25,hi8(gTextMsg_MustBeLetter)
 2598 0ad0 00C0      		rjmp .L218
 2599               	.LVL147:
 2600               	.L63:
 2601               	.LBE169:
 2602               	.LBE168:
2122:stk500boot.c  **** 				AVR_PortOutput();
2123:stk500boot.c  **** 				break;
2124:stk500boot.c  **** 			
2125:stk500boot.c  **** 			default:
2126:stk500boot.c  **** 				PrintFromPROGMEMln(gTextMsg_HUH, 0);
 2603               		.loc 1 2126 0
 2604 0ad2 80E0      		ldi r24,lo8(gTextMsg_HUH)
 2605 0ad4 90E0      		ldi r25,hi8(gTextMsg_HUH)
 2606 0ad6 00C0      		rjmp .L218
 2607               	.LVL148:
 2608               	.L182:
 2609               	.LBE184:
 2610               	.LBE185:
 714:stk500boot.c  **** 					exPointCntr	=	0;
 2611               		.loc 1 714 0
 2612 0ad8 60E0      		ldi r22,lo8(0)
 2613 0ada 70E0      		ldi r23,hi8(0)
 2614               	.LVL149:
 2615               	.L56:
 718:stk500boot.c  **** 				switch (msgParseState)
 2616               		.loc 1 718 0
 2617 0adc 2330      		cpi r18,lo8(3)
 2618 0ade 01F0      		breq .L128
 2619 0ae0 2430      		cpi r18,lo8(4)
 2620 0ae2 00F4      		brsh .L132
 2621 0ae4 2130      		cpi r18,lo8(1)
 2622 0ae6 01F0      		breq .L126
 2623 0ae8 2230      		cpi r18,lo8(2)
 2624 0aea 00F4      		brsh .L127
 2625 0aec 00C0      		rjmp .L237
 2626               	.L132:
 2627 0aee 2530      		cpi r18,lo8(5)
 2628 0af0 01F0      		breq .L130
 2629 0af2 2530      		cpi r18,lo8(5)
 2630 0af4 00F0      		brlo .L129
 2631 0af6 2630      		cpi r18,lo8(6)
 2632 0af8 01F4      		brne .L215
 2633 0afa 00C0      		rjmp .L238
 2634               	.L237:
 721:stk500boot.c  **** 						if ( c == MESSAGE_START )
 2635               		.loc 1 721 0
 2636 0afc 3B31      		cpi r19,lo8(27)
 2637 0afe 01F0      		breq .+2
 2638 0b00 00C0      		rjmp .L134
 2639 0b02 00C0      		rjmp .L239
 2640               	.L126:
 2641               	.LVL150:
 732:stk500boot.c  **** 						checksum		^=	c;
 2642               		.loc 1 732 0
 2643 0b04 C326      		eor r12,r19
 2644               	.LVL151:
 745:stk500boot.c  **** 						break;
 2645               		.loc 1 745 0
 2646 0b06 CA5D      		subi r28,lo8(-294)
 2647 0b08 DE4F      		sbci r29,hi8(-294)
 2648 0b0a 3883      		st Y,r19
 2649 0b0c C652      		subi r28,lo8(294)
 2650 0b0e D140      		sbci r29,hi8(294)
 731:stk500boot.c  **** 						msgParseState	=	ST_MSG_SIZE_1;
 2651               		.loc 1 731 0
 2652 0b10 22E0      		ldi r18,lo8(2)
 745:stk500boot.c  **** 						break;
 2653               		.loc 1 745 0
 2654 0b12 00C0      		rjmp .L134
 2655               	.LVL152:
 2656               	.L127:
 748:stk500boot.c  **** 						msgLength		=	c<<8;
 2657               		.loc 1 748 0
 2658 0b14 532F      		mov r21,r19
 2659 0b16 40E0      		ldi r20,lo8(0)
 2660               	.LVL153:
 750:stk500boot.c  **** 						checksum		^=	c;
 2661               		.loc 1 750 0
 2662 0b18 C326      		eor r12,r19
 2663               	.LVL154:
 749:stk500boot.c  **** 						msgParseState	=	ST_MSG_SIZE_2;
 2664               		.loc 1 749 0
 2665 0b1a 23E0      		ldi r18,lo8(3)
 751:stk500boot.c  **** 						break;
 2666               		.loc 1 751 0
 2667 0b1c 00C0      		rjmp .L134
 2668               	.LVL155:
 2669               	.L128:
 754:stk500boot.c  **** 						msgLength		|=	c;
 2670               		.loc 1 754 0
 2671 0b1e 832F      		mov r24,r19
 2672 0b20 90E0      		ldi r25,lo8(0)
 2673 0b22 482B      		or r20,r24
 2674 0b24 592B      		or r21,r25
 2675               	.LVL156:
 756:stk500boot.c  **** 						checksum		^=	c;
 2676               		.loc 1 756 0
 2677 0b26 C326      		eor r12,r19
 2678               	.LVL157:
 755:stk500boot.c  **** 						msgParseState	=	ST_GET_TOKEN;
 2679               		.loc 1 755 0
 2680 0b28 24E0      		ldi r18,lo8(4)
 757:stk500boot.c  **** 						break;
 2681               		.loc 1 757 0
 2682 0b2a 00C0      		rjmp .L134
 2683               	.LVL158:
 2684               	.L129:
 760:stk500boot.c  **** 						if ( c == TOKEN )
 2685               		.loc 1 760 0
 2686 0b2c 3E30      		cpi r19,lo8(14)
 2687 0b2e 01F0      		breq .+2
 2688 0b30 00C0      		rjmp .L184
 2689               	.LVL159:
 763:stk500boot.c  **** 							checksum		^=	c;
 2690               		.loc 1 763 0
 2691 0b32 C326      		eor r12,r19
 2692               	.LVL160:
 764:stk500boot.c  **** 							ii				=	0;
 2693               		.loc 1 764 0
 2694 0b34 00E0      		ldi r16,lo8(0)
 2695 0b36 10E0      		ldi r17,hi8(0)
 762:stk500boot.c  **** 							msgParseState	=	ST_GET_DATA;
 2696               		.loc 1 762 0
 2697 0b38 25E0      		ldi r18,lo8(5)
 2698 0b3a 00C0      		rjmp .L134
 2699               	.LVL161:
 2700               	.L130:
 773:stk500boot.c  **** 						msgBuffer[ii++]	=	c;
 2701               		.loc 1 773 0
 2702 0b3c E1E0      		ldi r30,lo8(1)
 2703 0b3e F0E0      		ldi r31,hi8(1)
 2704 0b40 EC0F      		add r30,r28
 2705 0b42 FD1F      		adc r31,r29
 2706 0b44 E00F      		add r30,r16
 2707 0b46 F11F      		adc r31,r17
 2708 0b48 3083      		st Z,r19
 2709 0b4a 0F5F      		subi r16,lo8(-(1))
 2710 0b4c 1F4F      		sbci r17,hi8(-(1))
 2711               	.LVL162:
 774:stk500boot.c  **** 						checksum		^=	c;
 2712               		.loc 1 774 0
 2713 0b4e C326      		eor r12,r19
 2714               	.LVL163:
 775:stk500boot.c  **** 						if (ii == msgLength )
 2715               		.loc 1 775 0
 2716 0b50 0417      		cp r16,r20
 2717 0b52 1507      		cpc r17,r21
 2718 0b54 01F0      		breq .+2
 2719 0b56 00C0      		rjmp .L134
 2720 0b58 00C0      		rjmp .L240
 2721               	.LVL164:
 2722               	.L238:
 782:stk500boot.c  **** 						if ( c == checksum )
 2723               		.loc 1 782 0
 2724 0b5a 3C15      		cp r19,r12
 2725 0b5c 01F0      		breq .+2
 2726 0b5e 00C0      		rjmp .L184
 2727 0b60 00C0      		rjmp .L186
 2728               	.L215:
 2729               	.LVL165:
 683:stk500boot.c  **** 			while ( msgParseState != ST_PROCESS )
 2730               		.loc 1 683 0 discriminator 1
 2731 0b62 2730      		cpi r18,lo8(7)
 2732 0b64 01F0      		breq .+2
 2733 0b66 00C0      		rjmp .L134
 2734               	.LVL166:
 2735               	.L186:
 2736 0b68 C95D      		subi r28,lo8(-295)
 2737 0b6a DE4F      		sbci r29,hi8(-295)
 2738 0b6c 1983      		std Y+1,r17
 2739 0b6e 0883      		st Y,r16
 2740 0b70 C752      		subi r28,lo8(295)
 2741 0b72 D140      		sbci r29,hi8(295)
 2742 0b74 C75D      		subi r28,lo8(-297)
 2743 0b76 DE4F      		sbci r29,hi8(-297)
 2744 0b78 F982      		std Y+1,r15
 2745 0b7a E882      		st Y,r14
 2746 0b7c C952      		subi r28,lo8(297)
 2747 0b7e D140      		sbci r29,hi8(297)
 2748 0b80 1B01      		movw r2,r22
 782:stk500boot.c  **** 						if ( c == checksum )
 2749               		.loc 1 782 0
 2750 0b82 4424      		clr r4
 2751               	.LVL167:
 2752               	.L93:
 798:stk500boot.c  **** 			switch (msgBuffer[0])
 2753               		.loc 1 798 0
 2754 0b84 8981      		ldd r24,Y+1
 2755 0b86 8331      		cpi r24,lo8(19)
 2756 0b88 01F4      		brne .+2
 2757 0b8a 00C0      		rjmp .L142
 2758 0b8c 8431      		cpi r24,lo8(20)
 2759 0b8e 00F4      		brsh .L149
 2760 0b90 8630      		cpi r24,lo8(6)
 2761 0b92 01F4      		brne .+2
 2762 0b94 00C0      		rjmp .L139
 2763 0b96 8730      		cpi r24,lo8(7)
 2764 0b98 00F4      		brsh .L150
 2765 0b9a 8230      		cpi r24,lo8(2)
 2766 0b9c 01F4      		brne .+2
 2767 0b9e 00C0      		rjmp .L227
 2768 0ba0 8330      		cpi r24,lo8(3)
 2769 0ba2 01F4      		brne .+2
 2770 0ba4 00C0      		rjmp .L138
 2771 0ba6 8130      		cpi r24,lo8(1)
 2772 0ba8 01F0      		breq .+2
 2773 0baa 00C0      		rjmp .L135
 2774 0bac 00C0      		rjmp .L241
 2775               	.L150:
 2776 0bae 8131      		cpi r24,lo8(17)
 2777 0bb0 01F4      		brne .+2
 2778 0bb2 00C0      		rjmp .L187
 2779 0bb4 8231      		cpi r24,lo8(18)
 2780 0bb6 00F0      		brlo .+2
 2781 0bb8 00C0      		rjmp .L141
 2782 0bba 8031      		cpi r24,lo8(16)
 2783 0bbc 01F0      		breq .+2
 2784 0bbe 00C0      		rjmp .L135
 2785 0bc0 00C0      		rjmp .L227
 2786               	.L149:
 2787 0bc2 8831      		cpi r24,lo8(24)
 2788 0bc4 01F4      		brne .+2
 2789 0bc6 00C0      		rjmp .L144
 2790 0bc8 8931      		cpi r24,lo8(25)
 2791 0bca 00F4      		brsh .L151
 2792 0bcc 8531      		cpi r24,lo8(21)
 2793 0bce 01F4      		brne .+2
 2794 0bd0 00C0      		rjmp .L142
 2795 0bd2 8531      		cpi r24,lo8(21)
 2796 0bd4 00F4      		brsh .+2
 2797 0bd6 00C0      		rjmp .L143
 2798 0bd8 8631      		cpi r24,lo8(22)
 2799 0bda 01F0      		breq .+2
 2800 0bdc 00C0      		rjmp .L135
 2801 0bde 00C0      		rjmp .L143
 2802               	.L151:
 2803 0be0 8A31      		cpi r24,lo8(26)
 2804 0be2 01F4      		brne .+2
 2805 0be4 00C0      		rjmp .L146
 2806 0be6 8A31      		cpi r24,lo8(26)
 2807 0be8 00F4      		brsh .+2
 2808 0bea 00C0      		rjmp .L145
 2809 0bec 8B31      		cpi r24,lo8(27)
 2810 0bee 01F4      		brne .+2
 2811 0bf0 00C0      		rjmp .L147
 2812 0bf2 8D31      		cpi r24,lo8(29)
 2813 0bf4 01F0      		breq .+2
 2814 0bf6 00C0      		rjmp .L135
 2815               	.LVL168:
 2816               	.LBB186:
 806:stk500boot.c  **** 						if ( msgBuffer[4]== 0x30 )
 2817               		.loc 1 806 0
 2818 0bf8 8D81      		ldd r24,Y+5
 2819 0bfa 8033      		cpi r24,lo8(48)
 2820 0bfc 01F4      		brne .L152
 2821               	.LBB187:
 808:stk500boot.c  **** 							unsigned char signatureIndex	=	msgBuffer[6];
 2822               		.loc 1 808 0
 2823 0bfe 9F81      		ldd r25,Y+7
 2824               	.LVL169:
 810:stk500boot.c  **** 							if ( signatureIndex == 0 )
 2825               		.loc 1 810 0
 2826 0c00 9923      		tst r25
 2827 0c02 01F0      		breq .L188
 814:stk500boot.c  **** 							else if ( signatureIndex == 1 )
 2828               		.loc 1 814 0
 2829 0c04 9130      		cpi r25,lo8(1)
 2830 0c06 01F4      		brne .L189
 816:stk500boot.c  **** 								answerByte	=	(SIGNATURE_BYTES >> 8) & 0x000000FF;
 2831               		.loc 1 816 0
 2832 0c08 E8EA      		ldi r30,lo8(-88)
 2833 0c0a 00C0      		rjmp .L153
 2834               	.LVL170:
 2835               	.L152:
 2836               	.LBE187:
 823:stk500boot.c  **** 						else if ( msgBuffer[4] & 0x50 )
 2837               		.loc 1 823 0
 2838 0c0c 982F      		mov r25,r24
 2839 0c0e 9075      		andi r25,lo8(80)
 2840 0c10 01F0      		breq .L191
 830:stk500boot.c  **** 							if (msgBuffer[4] == 0x50)
 2841               		.loc 1 830 0
 2842 0c12 8035      		cpi r24,lo8(80)
 2843 0c14 01F4      		brne .L154
 2844               	.LBB188:
 832:stk500boot.c  **** 								answerByte	=	boot_lock_fuse_bits_get(GET_LOW_FUSE_BITS);
 2845               		.loc 1 832 0
 2846 0c16 E0E0      		ldi r30,lo8(0)
 2847 0c18 F0E0      		ldi r31,hi8(0)
 2848 0c1a 00C0      		rjmp .L221
 2849               	.L154:
 2850               	.LBE188:
 834:stk500boot.c  **** 							else if (msgBuffer[4] == 0x58)
 2851               		.loc 1 834 0
 2852 0c1c 8835      		cpi r24,lo8(88)
 2853 0c1e 01F4      		brne .L191
 2854               	.LBB189:
 836:stk500boot.c  **** 								answerByte	=	boot_lock_fuse_bits_get(GET_HIGH_FUSE_BITS);
 2855               		.loc 1 836 0
 2856 0c20 E3E0      		ldi r30,lo8(3)
 2857 0c22 F0E0      		ldi r31,hi8(3)
 2858               	.L221:
 2859 0c24 99E0      		ldi r25,lo8(9)
 2860               	/* #APP */
 2861               	 ;  836 "stk500boot.c" 1
 2862 0c26 9093 5700 		sts 87, r25
 2863 0c2a E491      		lpm r30, Z
 2864               		
 2865               	 ;  0 "" 2
 2866               	.LVL171:
 2867               	/* #NOAPP */
 2868 0c2c 00C0      		rjmp .L153
 2869               	.LVL172:
 2870               	.L188:
 2871               	.LBE189:
 2872               	.LBB190:
 812:stk500boot.c  **** 								answerByte	=	(SIGNATURE_BYTES >> 16) & 0x000000FF;
 2873               		.loc 1 812 0
 2874 0c2e EEE1      		ldi r30,lo8(30)
 2875 0c30 00C0      		rjmp .L153
 2876               	.L189:
 820:stk500boot.c  **** 								answerByte	=	SIGNATURE_BYTES & 0x000000FF;
 2877               		.loc 1 820 0
 2878 0c32 E2E0      		ldi r30,lo8(2)
 2879 0c34 00C0      		rjmp .L153
 2880               	.LVL173:
 2881               	.L191:
 2882               	.LBE190:
 840:stk500boot.c  **** 								answerByte	=	0;
 2883               		.loc 1 840 0
 2884 0c36 E0E0      		ldi r30,lo8(0)
 2885               	.L153:
 2886               	.LVL174:
 850:stk500boot.c  **** 							msgBuffer[1]	=	STATUS_CMD_OK;
 2887               		.loc 1 850 0
 2888 0c38 1A82      		std Y+2,__zero_reg__
 851:stk500boot.c  **** 							msgBuffer[2]	=	0;
 2889               		.loc 1 851 0
 2890 0c3a 1B82      		std Y+3,__zero_reg__
 852:stk500boot.c  **** 							msgBuffer[3]	=	msgBuffer[4];
 2891               		.loc 1 852 0
 2892 0c3c 8C83      		std Y+4,r24
 853:stk500boot.c  **** 							msgBuffer[4]	=	0;
 2893               		.loc 1 853 0
 2894 0c3e 1D82      		std Y+5,__zero_reg__
 854:stk500boot.c  **** 							msgBuffer[5]	=	answerByte;
 2895               		.loc 1 854 0
 2896 0c40 EE83      		std Y+6,r30
 855:stk500boot.c  **** 							msgBuffer[6]	=	STATUS_CMD_OK;
 2897               		.loc 1 855 0
 2898 0c42 1F82      		std Y+7,__zero_reg__
 849:stk500boot.c  **** 							msgLength		=	7;
 2899               		.loc 1 849 0
 2900 0c44 07E0      		ldi r16,lo8(7)
 2901 0c46 E02E      		mov r14,r16
 2902 0c48 F12C      		mov r15,__zero_reg__
 2903 0c4a 00C0      		rjmp .L155
 2904               	.LVL175:
 2905               	.L241:
 2906               	.LBE186:
 862:stk500boot.c  **** 					msgBuffer[1] 	=	STATUS_CMD_OK;
 2907               		.loc 1 862 0
 2908 0c4c 1A82      		std Y+2,__zero_reg__
 863:stk500boot.c  **** 					msgBuffer[2] 	=	8;
 2909               		.loc 1 863 0
 2910 0c4e 88E0      		ldi r24,lo8(8)
 2911 0c50 8B83      		std Y+3,r24
 864:stk500boot.c  **** 					msgBuffer[3] 	=	'A';
 2912               		.loc 1 864 0
 2913 0c52 81E4      		ldi r24,lo8(65)
 2914 0c54 8C83      		std Y+4,r24
 865:stk500boot.c  **** 					msgBuffer[4] 	=	'V';
 2915               		.loc 1 865 0
 2916 0c56 86E5      		ldi r24,lo8(86)
 2917 0c58 8D83      		std Y+5,r24
 866:stk500boot.c  **** 					msgBuffer[5] 	=	'R';
 2918               		.loc 1 866 0
 2919 0c5a 82E5      		ldi r24,lo8(82)
 2920 0c5c 8E83      		std Y+6,r24
 867:stk500boot.c  **** 					msgBuffer[6] 	=	'I';
 2921               		.loc 1 867 0
 2922 0c5e 89E4      		ldi r24,lo8(73)
 2923 0c60 8F83      		std Y+7,r24
 868:stk500boot.c  **** 					msgBuffer[7] 	=	'S';
 2924               		.loc 1 868 0
 2925 0c62 83E5      		ldi r24,lo8(83)
 2926 0c64 8887      		std Y+8,r24
 869:stk500boot.c  **** 					msgBuffer[8] 	=	'P';
 2927               		.loc 1 869 0
 2928 0c66 80E5      		ldi r24,lo8(80)
 2929 0c68 8987      		std Y+9,r24
 870:stk500boot.c  **** 					msgBuffer[9] 	=	'_';
 2930               		.loc 1 870 0
 2931 0c6a 8FE5      		ldi r24,lo8(95)
 2932 0c6c 8A87      		std Y+10,r24
 871:stk500boot.c  **** 					msgBuffer[10]	=	'2';
 2933               		.loc 1 871 0
 2934 0c6e 82E3      		ldi r24,lo8(50)
 2935 0c70 8B87      		std Y+11,r24
 861:stk500boot.c  **** 					msgLength		=	11;
 2936               		.loc 1 861 0
 2937 0c72 1BE0      		ldi r17,lo8(11)
 2938 0c74 E12E      		mov r14,r17
 2939 0c76 F12C      		mov r15,__zero_reg__
 872:stk500boot.c  **** 					break;
 2940               		.loc 1 872 0
 2941 0c78 00C0      		rjmp .L155
 2942               	.LVL176:
 2943               	.L138:
 2944 0c7a EA81      		ldd r30,Y+2
 2945 0c7c E059      		subi r30,lo8(-(112))
 2946 0c7e E330      		cpi r30,lo8(3)
 2947 0c80 00F4      		brsh .L192
 2948 0c82 F0E0      		ldi r31,lo8(0)
 2949 0c84 E050      		subi r30,lo8(-(CSWTCH.30))
 2950 0c86 F040      		sbci r31,hi8(-(CSWTCH.30))
 2951 0c88 8081      		ld r24,Z
 2952 0c8a 00C0      		rjmp .L156
 2953               	.L192:
 2954               	.LBB191:
 878:stk500boot.c  **** 						switch(msgBuffer[1])
 2955               		.loc 1 878 0
 2956 0c8c 80E0      		ldi r24,lo8(0)
 2957               	.L156:
 2958               	.LVL177:
 900:stk500boot.c  **** 						msgBuffer[1]	=	STATUS_CMD_OK;
 2959               		.loc 1 900 0
 2960 0c8e 1A82      		std Y+2,__zero_reg__
 901:stk500boot.c  **** 						msgBuffer[2]	=	value;
 2961               		.loc 1 901 0
 2962 0c90 8B83      		std Y+3,r24
 2963 0c92 00C0      		rjmp .L223
 2964               	.LVL178:
 2965               	.L187:
 2966               	.LBE191:
 906:stk500boot.c  **** 					isLeave	=	1;
 2967               		.loc 1 906 0
 2968 0c94 4424      		clr r4
 2969 0c96 4394      		inc r4
 2970               	.LVL179:
 2971 0c98 00C0      		rjmp .L227
 2972               	.LVL180:
 2973               	.L147:
 2974               	.LBB192:
 917:stk500boot.c  **** 						unsigned char signatureIndex	=	msgBuffer[4];
 2975               		.loc 1 917 0
 2976 0c9a 8D81      		ldd r24,Y+5
 2977               	.LVL181:
 920:stk500boot.c  **** 						if ( signatureIndex == 0 )
 2978               		.loc 1 920 0
 2979 0c9c 8823      		tst r24
 2980 0c9e 01F0      		breq .L193
 922:stk500boot.c  **** 						else if ( signatureIndex == 1 )
 2981               		.loc 1 922 0
 2982 0ca0 8130      		cpi r24,lo8(1)
 2983 0ca2 01F4      		brne .L194
 923:stk500boot.c  **** 							signature	=	(SIGNATURE_BYTES >> 8) & 0x000000FF;
 2984               		.loc 1 923 0
 2985 0ca4 88EA      		ldi r24,lo8(-88)
 2986 0ca6 00C0      		rjmp .L157
 2987               	.L193:
 921:stk500boot.c  **** 							signature	=	(SIGNATURE_BYTES >>16) & 0x000000FF;
 2988               		.loc 1 921 0
 2989 0ca8 8EE1      		ldi r24,lo8(30)
 2990 0caa 00C0      		rjmp .L157
 2991               	.L194:
 925:stk500boot.c  **** 							signature	=	SIGNATURE_BYTES & 0x000000FF;
 2992               		.loc 1 925 0
 2993 0cac 82E0      		ldi r24,lo8(2)
 2994               	.L157:
 2995               	.LVL182:
 928:stk500boot.c  **** 						msgBuffer[1]	=	STATUS_CMD_OK;
 2996               		.loc 1 928 0
 2997 0cae 1A82      		std Y+2,__zero_reg__
 929:stk500boot.c  **** 						msgBuffer[2]	=	signature;
 2998               		.loc 1 929 0
 2999 0cb0 8B83      		std Y+3,r24
 3000 0cb2 00C0      		rjmp .L225
 3001               	.LVL183:
 3002               	.L146:
 3003               	.LBE192:
 936:stk500boot.c  **** 					msgBuffer[1]	=	STATUS_CMD_OK;
 3004               		.loc 1 936 0
 3005 0cb4 1A82      		std Y+2,__zero_reg__
 3006               	.LBB193:
 937:stk500boot.c  **** 					msgBuffer[2]	=	boot_lock_fuse_bits_get( GET_LOCK_BITS );
 3007               		.loc 1 937 0
 3008 0cb6 E1E0      		ldi r30,lo8(1)
 3009 0cb8 F0E0      		ldi r31,hi8(1)
 3010 0cba 89E0      		ldi r24,lo8(9)
 3011               	/* #APP */
 3012               	 ;  937 "stk500boot.c" 1
 3013 0cbc 8093 5700 		sts 87, r24
 3014 0cc0 E491      		lpm r30, Z
 3015               		
 3016               	 ;  0 "" 2
 3017               	/* #NOAPP */
 3018               	.L226:
 3019               	.LVL184:
 3020               	.LBE193:
 3021 0cc2 EB83      		std Y+3,r30
 3022               	.LVL185:
 3023               	.L225:
 938:stk500boot.c  **** 					msgBuffer[3]	=	STATUS_CMD_OK;
 3024               		.loc 1 938 0
 3025 0cc4 1C82      		std Y+4,__zero_reg__
 935:stk500boot.c  **** 					msgLength		=	4;
 3026               		.loc 1 935 0
 3027 0cc6 B4E0      		ldi r27,lo8(4)
 3028 0cc8 EB2E      		mov r14,r27
 3029 0cca F12C      		mov r15,__zero_reg__
 939:stk500boot.c  **** 					break;
 3030               		.loc 1 939 0
 3031 0ccc 00C0      		rjmp .L155
 3032               	.LVL186:
 3033               	.L144:
 3034               	.LBB194:
 945:stk500boot.c  **** 						if ( msgBuffer[2] == 0x50 )
 3035               		.loc 1 945 0
 3036 0cce 8B81      		ldd r24,Y+3
 3037 0cd0 8035      		cpi r24,lo8(80)
 3038 0cd2 01F4      		brne .L158
 947:stk500boot.c  **** 							if ( msgBuffer[3] == 0x08 )
 3039               		.loc 1 947 0
 3040 0cd4 8C81      		ldd r24,Y+4
 3041 0cd6 8830      		cpi r24,lo8(8)
 3042 0cd8 01F4      		brne .L159
 3043               	.LBB195:
 948:stk500boot.c  **** 								fuseBits	=	boot_lock_fuse_bits_get( GET_EXTENDED_FUSE_BITS );
 3044               		.loc 1 948 0
 3045 0cda E2E0      		ldi r30,lo8(2)
 3046 0cdc F0E0      		ldi r31,hi8(2)
 3047 0cde 00C0      		rjmp .L222
 3048               	.L159:
 3049               	.LBE195:
 3050               	.LBB196:
 950:stk500boot.c  **** 								fuseBits	=	boot_lock_fuse_bits_get( GET_LOW_FUSE_BITS );
 3051               		.loc 1 950 0
 3052 0ce0 E0E0      		ldi r30,lo8(0)
 3053 0ce2 F0E0      		ldi r31,hi8(0)
 3054 0ce4 00C0      		rjmp .L222
 3055               	.L158:
 3056               	.LBE196:
 3057               	.LBB197:
 954:stk500boot.c  **** 							fuseBits	=	boot_lock_fuse_bits_get( GET_HIGH_FUSE_BITS );
 3058               		.loc 1 954 0
 3059 0ce6 E3E0      		ldi r30,lo8(3)
 3060 0ce8 F0E0      		ldi r31,hi8(3)
 3061               	.L222:
 3062 0cea 89E0      		ldi r24,lo8(9)
 3063               	/* #APP */
 3064               	 ;  954 "stk500boot.c" 1
 3065 0cec 8093 5700 		sts 87, r24
 3066 0cf0 E491      		lpm r30, Z
 3067               		
 3068               	 ;  0 "" 2
 3069               	.LVL187:
 3070               	/* #NOAPP */
 3071               	.LBE197:
 957:stk500boot.c  **** 						msgBuffer[1]	=	STATUS_CMD_OK;
 3072               		.loc 1 957 0
 3073 0cf2 1A82      		std Y+2,__zero_reg__
 3074 0cf4 00C0      		rjmp .L226
 3075               	.LVL188:
 3076               	.L145:
 3077               	.LBE194:
 3078               	.LBB199:
 968:stk500boot.c  **** 						lockBits	=	(~lockBits) & 0x3C;	// mask BLBxx bits
 3079               		.loc 1 968 0
 3080 0cf6 8D81      		ldd r24,Y+5
 3081               	.LVL189:
 3082               	.LBB200:
 969:stk500boot.c  **** 						boot_lock_bits_set(lockBits);		// and program it
 3083               		.loc 1 969 0
 3084 0cf8 836C      		ori r24,lo8(-61)
 3085 0cfa 99E0      		ldi r25,lo8(9)
 3086               	/* #APP */
 3087               	 ;  969 "stk500boot.c" 1
 3088 0cfc E1E0      		ldi r30, 1
 3089 0cfe F0E0      		ldi r31, 0
 3090 0d00 082E      		mov r0, r24
 3091 0d02 9093 5700 		sts 87, r25
 3092 0d06 E895      		spm
 3093               		
 3094               	 ;  0 "" 2
 3095               	/* #NOAPP */
 3096               	.L161:
 3097               	.LBE200:
 970:stk500boot.c  **** 						boot_spm_busy_wait();
 3098               		.loc 1 970 0 discriminator 1
 3099 0d08 07B6      		in __tmp_reg__,87-32
 3100 0d0a 00FC      		sbrc __tmp_reg__,0
 3101 0d0c 00C0      		rjmp .L161
 3102               	.LVL190:
 973:stk500boot.c  **** 						msgBuffer[1]	=	STATUS_CMD_OK;
 3103               		.loc 1 973 0
 3104 0d0e 1A82      		std Y+2,__zero_reg__
 974:stk500boot.c  **** 						msgBuffer[2]	=	STATUS_CMD_OK;
 3105               		.loc 1 974 0
 3106 0d10 1B82      		std Y+3,__zero_reg__
 3107               	.LVL191:
 3108               	.L223:
 3109               	.LBE199:
 972:stk500boot.c  **** 						msgLength		=	3;
 3110               		.loc 1 972 0
 3111 0d12 A3E0      		ldi r26,lo8(3)
 3112 0d14 EA2E      		mov r14,r26
 3113 0d16 F12C      		mov r15,__zero_reg__
 976:stk500boot.c  **** 					break;
 3114               		.loc 1 976 0
 3115 0d18 00C0      		rjmp .L155
 3116               	.LVL192:
 3117               	.L141:
 981:stk500boot.c  **** 					msgBuffer[1]	=	STATUS_CMD_OK;
 3118               		.loc 1 981 0
 3119 0d1a 1A82      		std Y+2,__zero_reg__
 980:stk500boot.c  **** 					msgLength		=	2;
 3120               		.loc 1 980 0
 3121 0d1c F2E0      		ldi r31,lo8(2)
 3122 0d1e EF2E      		mov r14,r31
 3123 0d20 F12C      		mov r15,__zero_reg__
 979:stk500boot.c  **** 					eraseAddress	=	0;
 3124               		.loc 1 979 0
 3125 0d22 CE5D      		subi r28,lo8(-290)
 3126 0d24 DE4F      		sbci r29,hi8(-290)
 3127 0d26 1882      		st Y,__zero_reg__
 3128 0d28 1982      		std Y+1,__zero_reg__
 3129 0d2a 1A82      		std Y+2,__zero_reg__
 3130 0d2c 1B82      		std Y+3,__zero_reg__
 3131 0d2e C252      		subi r28,lo8(290)
 3132 0d30 D140      		sbci r29,hi8(290)
 983:stk500boot.c  **** 					break;
 3133               		.loc 1 983 0
 3134 0d32 00C0      		rjmp .L155
 3135               	.LVL193:
 3136               	.L139:
 987:stk500boot.c  **** 					address	=	( ((address_t)(msgBuffer[1])<<24)|((address_t)(msgBuffer[2])<<16)|((address_t)(msgBu
 3137               		.loc 1 987 0
 3138 0d34 8A81      		ldd r24,Y+2
 3139 0d36 90E0      		ldi r25,lo8(0)
 3140 0d38 A0E0      		ldi r26,lo8(0)
 3141 0d3a B0E0      		ldi r27,hi8(0)
 3142 0d3c 582F      		mov r21,r24
 3143 0d3e 4427      		clr r20
 3144 0d40 3327      		clr r19
 3145 0d42 2227      		clr r18
 3146 0d44 8B81      		ldd r24,Y+3
 3147 0d46 90E0      		ldi r25,lo8(0)
 3148 0d48 A0E0      		ldi r26,lo8(0)
 3149 0d4a B0E0      		ldi r27,hi8(0)
 3150 0d4c DC01      		movw r26,r24
 3151 0d4e 9927      		clr r25
 3152 0d50 8827      		clr r24
 3153 0d52 282B      		or r18,r24
 3154 0d54 392B      		or r19,r25
 3155 0d56 4A2B      		or r20,r26
 3156 0d58 5B2B      		or r21,r27
 3157 0d5a 8D81      		ldd r24,Y+5
 3158 0d5c 90E0      		ldi r25,lo8(0)
 3159 0d5e A0E0      		ldi r26,lo8(0)
 3160 0d60 B0E0      		ldi r27,hi8(0)
 3161 0d62 282B      		or r18,r24
 3162 0d64 392B      		or r19,r25
 3163 0d66 4A2B      		or r20,r26
 3164 0d68 5B2B      		or r21,r27
 3165 0d6a 8C81      		ldd r24,Y+4
 3166 0d6c 90E0      		ldi r25,lo8(0)
 3167 0d6e A0E0      		ldi r26,lo8(0)
 3168 0d70 B0E0      		ldi r27,hi8(0)
 3169 0d72 BA2F      		mov r27,r26
 3170 0d74 A92F      		mov r26,r25
 3171 0d76 982F      		mov r25,r24
 3172 0d78 8827      		clr r24
 3173 0d7a 282B      		or r18,r24
 3174 0d7c 392B      		or r19,r25
 3175 0d7e 4A2B      		or r20,r26
 3176 0d80 5B2B      		or r21,r27
 3177 0d82 220F      		lsl r18
 3178 0d84 331F      		rol r19
 3179 0d86 441F      		rol r20
 3180 0d88 551F      		rol r21
 3181 0d8a C25E      		subi r28,lo8(-286)
 3182 0d8c DE4F      		sbci r29,hi8(-286)
 3183 0d8e 2883      		st Y,r18
 3184 0d90 3983      		std Y+1,r19
 3185 0d92 4A83      		std Y+2,r20
 3186 0d94 5B83      		std Y+3,r21
 3187 0d96 CE51      		subi r28,lo8(286)
 3188 0d98 D140      		sbci r29,hi8(286)
 3189               	.L227:
 3190               	.LVL194:
 992:stk500boot.c  **** 					msgBuffer[1]	=	STATUS_CMD_OK;
 3191               		.loc 1 992 0
 3192 0d9a 1A82      		std Y+2,__zero_reg__
 3193 0d9c 00C0      		rjmp .L224
 3194               	.LVL195:
 3195               	.L142:
 3196               	.LBB201:
 998:stk500boot.c  **** 						unsigned int	size	=	((msgBuffer[1])<<8) | msgBuffer[2];
 3197               		.loc 1 998 0
 3198 0d9e 3A81      		ldd r19,Y+2
 3199 0da0 C65C      		subi r28,lo8(-314)
 3200 0da2 DE4F      		sbci r29,hi8(-314)
 3201 0da4 3883      		st Y,r19
 3202 0da6 CA53      		subi r28,lo8(314)
 3203 0da8 D140      		sbci r29,hi8(314)
 3204 0daa C75C      		subi r28,lo8(-313)
 3205 0dac DE4F      		sbci r29,hi8(-313)
 3206 0dae 1882      		st Y,__zero_reg__
 3207 0db0 C953      		subi r28,lo8(313)
 3208 0db2 D140      		sbci r29,hi8(313)
 3209 0db4 CB80      		ldd r12,Y+3
 3210 0db6 DD24      		clr r13
 3211 0db8 C75C      		subi r28,lo8(-313)
 3212 0dba DE4F      		sbci r29,hi8(-313)
 3213 0dbc 4881      		ld r20,Y
 3214 0dbe 5981      		ldd r21,Y+1
 3215 0dc0 C953      		subi r28,lo8(313)
 3216 0dc2 D140      		sbci r29,hi8(313)
 3217 0dc4 C42A      		or r12,r20
 3218 0dc6 D52A      		or r13,r21
 3219               	.LVL196:
1005:stk500boot.c  **** 						if ( msgBuffer[0] == CMD_PROGRAM_FLASH_ISP )
 3220               		.loc 1 1005 0
 3221 0dc8 8331      		cpi r24,lo8(19)
 3222 0dca 01F0      		breq .+2
 3223 0dcc 00C0      		rjmp .L162
1008:stk500boot.c  **** 							if (eraseAddress < APP_END )
 3224               		.loc 1 1008 0
 3225 0dce CE5D      		subi r28,lo8(-290)
 3226 0dd0 DE4F      		sbci r29,hi8(-290)
 3227 0dd2 2881      		ld r18,Y
 3228 0dd4 3981      		ldd r19,Y+1
 3229 0dd6 4A81      		ldd r20,Y+2
 3230 0dd8 5B81      		ldd r21,Y+3
 3231 0dda C252      		subi r28,lo8(290)
 3232 0ddc D140      		sbci r29,hi8(290)
 3233 0dde 2030      		cpi r18,lo8(245760)
 3234 0de0 60EC      		ldi r22,hi8(245760)
 3235 0de2 3607      		cpc r19,r22
 3236 0de4 63E0      		ldi r22,hlo8(245760)
 3237 0de6 4607      		cpc r20,r22
 3238 0de8 60E0      		ldi r22,hhi8(245760)
 3239 0dea 5607      		cpc r21,r22
 3240 0dec 00F4      		brsh .L163
1010:stk500boot.c  **** 								boot_page_erase(eraseAddress);	// Perform page erase
 3241               		.loc 1 1010 0
 3242 0dee 83E0      		ldi r24,lo8(3)
 3243               	/* #APP */
 3244               	 ;  1010 "stk500boot.c" 1
 3245 0df0 F901      		movw r30, r18
 3246 0df2 4093 5B00 		sts  91, r20
 3247 0df6 8093 5700 		sts 87, r24
 3248 0dfa E895      		spm
 3249               		
 3250               	 ;  0 "" 2
 3251               	/* #NOAPP */
 3252               	.L164:
1011:stk500boot.c  **** 								boot_spm_busy_wait();		// Wait until the memory is erased.
 3253               		.loc 1 1011 0 discriminator 1
 3254 0dfc 07B6      		in __tmp_reg__,87-32
 3255 0dfe 00FC      		sbrc __tmp_reg__,0
 3256 0e00 00C0      		rjmp .L164
1012:stk500boot.c  **** 								eraseAddress += SPM_PAGESIZE;	// point to next page to be erase
 3257               		.loc 1 1012 0
 3258 0e02 CE5D      		subi r28,lo8(-290)
 3259 0e04 DE4F      		sbci r29,hi8(-290)
 3260 0e06 2881      		ld r18,Y
 3261 0e08 3981      		ldd r19,Y+1
 3262 0e0a 4A81      		ldd r20,Y+2
 3263 0e0c 5B81      		ldd r21,Y+3
 3264 0e0e C252      		subi r28,lo8(290)
 3265 0e10 D140      		sbci r29,hi8(290)
 3266 0e12 2050      		subi r18,lo8(-(256))
 3267 0e14 3F4F      		sbci r19,hi8(-(256))
 3268 0e16 4F4F      		sbci r20,hlo8(-(256))
 3269 0e18 5F4F      		sbci r21,hhi8(-(256))
 3270 0e1a CE5D      		subi r28,lo8(-290)
 3271 0e1c DE4F      		sbci r29,hi8(-290)
 3272 0e1e 2883      		st Y,r18
 3273 0e20 3983      		std Y+1,r19
 3274 0e22 4A83      		std Y+2,r20
 3275 0e24 5B83      		std Y+3,r21
 3276 0e26 C252      		subi r28,lo8(290)
 3277 0e28 D140      		sbci r29,hi8(290)
 3278               	.LVL197:
 3279               	.L163:
1012:stk500boot.c  **** 								eraseAddress += SPM_PAGESIZE;	// point to next page to be erase
 3280               		.loc 1 1012 0 is_stmt 0 discriminator 1
 3281 0e2a 8B85      		ldd r24,Y+11
 3282 0e2c DE01      		movw r26,r28
 3283 0e2e 1D96      		adiw r26,13
 3284               	.LBE201:
 3285               	.LBB203:
 3286               	.LBB198:
 948:stk500boot.c  **** 								fuseBits	=	boot_lock_fuse_bits_get( GET_EXTENDED_FUSE_BITS );
 3287               		.loc 1 948 0 is_stmt 1 discriminator 1
 3288 0e30 C25E      		subi r28,lo8(-286)
 3289 0e32 DE4F      		sbci r29,hi8(-286)
 3290 0e34 0881      		ld r16,Y
 3291 0e36 1981      		ldd r17,Y+1
 3292 0e38 2A81      		ldd r18,Y+2
 3293 0e3a 3B81      		ldd r19,Y+3
 3294 0e3c CE51      		subi r28,lo8(286)
 3295 0e3e D140      		sbci r29,hi8(286)
 3296               	.LBE198:
 3297               	.LBE203:
 3298               	.LBB204:
1021:stk500boot.c  **** 								boot_page_fill(address,data);
 3299               		.loc 1 1021 0 discriminator 1
 3300 0e40 41E0      		ldi r20,lo8(1)
 3301 0e42 B601      		movw r22,r12
 3302               	.LVL198:
 3303               	.L166:
 542:stk500boot.c  **** int main(void)
 3304               		.loc 1 542 0 discriminator 1
 3305 0e44 FD01      		movw r30,r26
 3306 0e46 3197      		sbiw r30,1
1020:stk500boot.c  **** 								data		=	(highByte << 8) | lowByte;
 3307               		.loc 1 1020 0 discriminator 1
 3308 0e48 5081      		ld r21,Z
 3309 0e4a C45C      		subi r28,lo8(-316)
 3310 0e4c DE4F      		sbci r29,hi8(-316)
 3311 0e4e 5883      		st Y,r21
 3312 0e50 CC53      		subi r28,lo8(316)
 3313 0e52 D140      		sbci r29,hi8(316)
 3314 0e54 C55C      		subi r28,lo8(-315)
 3315 0e56 DE4F      		sbci r29,hi8(-315)
 3316 0e58 1882      		st Y,__zero_reg__
 3317 0e5a CB53      		subi r28,lo8(315)
 3318 0e5c D140      		sbci r29,hi8(315)
 3319 0e5e 90E0      		ldi r25,lo8(0)
 3320 0e60 C55C      		subi r28,lo8(-315)
 3321 0e62 DE4F      		sbci r29,hi8(-315)
 3322 0e64 E881      		ld r30,Y
 3323 0e66 F981      		ldd r31,Y+1
 3324 0e68 CB53      		subi r28,lo8(315)
 3325 0e6a D140      		sbci r29,hi8(315)
 3326 0e6c 8E2B      		or r24,r30
 3327 0e6e 9F2B      		or r25,r31
 3328               	.LVL199:
1021:stk500boot.c  **** 								boot_page_fill(address,data);
 3329               		.loc 1 1021 0 discriminator 1
 3330               	/* #APP */
 3331               	 ;  1021 "stk500boot.c" 1
 3332 0e70 0C01      		movw  r0, r24
 3333 0e72 F801      		movw r30, r16
 3334 0e74 2093 5B00 		sts 91, r18
 3335 0e78 4093 5700 		sts 87, r20
 3336 0e7c E895      		spm
 3337 0e7e 1124      		clr  r1
 3338               		
 3339               	 ;  0 "" 2
1023:stk500boot.c  **** 								address	=	address + 2;	// Select next word in memory
 3340               		.loc 1 1023 0 discriminator 1
 3341               	/* #NOAPP */
 3342 0e80 0E5F      		subi r16,lo8(-(2))
 3343 0e82 1F4F      		sbci r17,hi8(-(2))
 3344 0e84 2F4F      		sbci r18,hlo8(-(2))
 3345 0e86 3F4F      		sbci r19,hhi8(-(2))
 3346               	.LVL200:
1024:stk500boot.c  **** 								size	-=	2;				// Reduce number of bytes to write by two
 3347               		.loc 1 1024 0 discriminator 1
 3348 0e88 6250      		subi r22,lo8(-(-2))
 3349 0e8a 7040      		sbci r23,hi8(-(-2))
 3350               	.LVL201:
1025:stk500boot.c  **** 							} while (size);					// Loop until all bytes written
 3351               		.loc 1 1025 0 discriminator 1
 3352 0e8c 01F0      		breq .L165
1018:stk500boot.c  **** 								highByte 	=	*p++;
 3353               		.loc 1 1018 0
 3354 0e8e 8C91      		ld r24,X
 3355 0e90 1296      		adiw r26,2
 3356               	.LVL202:
 3357 0e92 00C0      		rjmp .L166
 3358               	.LVL203:
 3359               	.L165:
1027:stk500boot.c  **** 							boot_page_write(tempaddress);
 3360               		.loc 1 1027 0
 3361 0e94 85E0      		ldi r24,lo8(5)
 3362 0e96 C25E      		subi r28,lo8(-286)
 3363 0e98 DE4F      		sbci r29,hi8(-286)
 3364 0e9a 4881      		ld r20,Y
 3365 0e9c 5981      		ldd r21,Y+1
 3366 0e9e 6A81      		ldd r22,Y+2
 3367 0ea0 7B81      		ldd r23,Y+3
 3368 0ea2 CE51      		subi r28,lo8(286)
 3369 0ea4 D140      		sbci r29,hi8(286)
 3370               	/* #APP */
 3371               	 ;  1027 "stk500boot.c" 1
 3372 0ea6 FA01      		movw r30, r20
 3373 0ea8 6093 5B00 		sts 91, r22
 3374 0eac 8093 5700 		sts 87, r24
 3375 0eb0 E895      		spm
 3376               		
 3377               	 ;  0 "" 2
 3378               	/* #NOAPP */
 3379               	.L167:
1028:stk500boot.c  **** 							boot_spm_busy_wait();
 3380               		.loc 1 1028 0 discriminator 1
 3381 0eb2 07B6      		in __tmp_reg__,87-32
 3382 0eb4 00FC      		sbrc __tmp_reg__,0
 3383 0eb6 00C0      		rjmp .L167
1029:stk500boot.c  **** 							boot_rww_enable();				// Re-enable the RWW section
 3384               		.loc 1 1029 0
 3385 0eb8 81E1      		ldi r24,lo8(17)
 3386               	/* #APP */
 3387               	 ;  1029 "stk500boot.c" 1
 3388 0eba 8093 5700 		sts 87, r24
 3389 0ebe E895      		spm
 3390               		
 3391               	 ;  0 "" 2
 3392               	/* #NOAPP */
 3393 0ec0 00C0      		rjmp .L168
 3394               	.LVL204:
 3395               	.L162:
 3396               	.LBB202:
1034:stk500boot.c  **** 							uint16_t ii = address >> 1;
 3397               		.loc 1 1034 0
 3398 0ec2 C25E      		subi r28,lo8(-286)
 3399 0ec4 DE4F      		sbci r29,hi8(-286)
 3400 0ec6 8880      		ld r8,Y
 3401 0ec8 9980      		ldd r9,Y+1
 3402 0eca AA80      		ldd r10,Y+2
 3403 0ecc BB80      		ldd r11,Y+3
 3404 0ece CE51      		subi r28,lo8(286)
 3405 0ed0 D140      		sbci r29,hi8(286)
 3406 0ed2 B694      		lsr r11
 3407 0ed4 A794      		ror r10
 3408 0ed6 9794      		ror r9
 3409 0ed8 8794      		ror r8
 3410               	.LVL205:
1036:stk500boot.c  **** 							while (size) {
 3411               		.loc 1 1036 0
 3412 0eda 00E0      		ldi r16,lo8(0)
 3413 0edc 10E0      		ldi r17,hi8(0)
 999:stk500boot.c  **** 						unsigned char	*p	=	msgBuffer+10;
 3414               		.loc 1 999 0
 3415 0ede 2BE0      		ldi r18,lo8(11)
 3416 0ee0 E22E      		mov r14,r18
 3417 0ee2 F12C      		mov r15,__zero_reg__
 3418 0ee4 EC0E      		add r14,r28
 3419 0ee6 FD1E      		adc r15,r29
1036:stk500boot.c  **** 							while (size) {
 3420               		.loc 1 1036 0
 3421 0ee8 00C0      		rjmp .L169
 3422               	.LVL206:
 3423               	.L170:
1037:stk500boot.c  **** 								eeprom_write_byte((uint8_t*)ii, *p++);
 3424               		.loc 1 1037 0
 3425 0eea D701      		movw r26,r14
 3426 0eec 6D91      		ld r22,X+
 3427 0eee 7D01      		movw r14,r26
 3428               	.LVL207:
 542:stk500boot.c  **** int main(void)
 3429               		.loc 1 542 0
 3430 0ef0 C801      		movw r24,r16
 3431 0ef2 880D      		add r24,r8
 3432 0ef4 991D      		adc r25,r9
1037:stk500boot.c  **** 								eeprom_write_byte((uint8_t*)ii, *p++);
 3433               		.loc 1 1037 0
 3434 0ef6 0E94 0000 		call __eewr_byte_m256rfr2
 3435               	.LVL208:
 3436 0efa 0F5F      		subi r16,lo8(-(1))
 3437 0efc 1F4F      		sbci r17,hi8(-(1))
 3438               	.LVL209:
 3439               	.L169:
1036:stk500boot.c  **** 							while (size) {
 3440               		.loc 1 1036 0 discriminator 1
 3441 0efe 0C15      		cp r16,r12
 3442 0f00 1D05      		cpc r17,r13
 3443 0f02 01F4      		brne .L170
 542:stk500boot.c  **** int main(void)
 3444               		.loc 1 542 0
 3445 0f04 20E0      		ldi r18,lo8(0)
 3446 0f06 30E0      		ldi r19,hi8(0)
 3447 0f08 000F      		lsl r16
 3448 0f0a 111F      		rol r17
 3449 0f0c 221F      		rol r18
 3450 0f0e 331F      		rol r19
1036:stk500boot.c  **** 							while (size) {
 3451               		.loc 1 1036 0
 3452 0f10 C25E      		subi r28,lo8(-286)
 3453 0f12 DE4F      		sbci r29,hi8(-286)
 3454 0f14 4881      		ld r20,Y
 3455 0f16 5981      		ldd r21,Y+1
 3456 0f18 6A81      		ldd r22,Y+2
 3457 0f1a 7B81      		ldd r23,Y+3
 3458 0f1c CE51      		subi r28,lo8(286)
 3459 0f1e D140      		sbci r29,hi8(286)
 3460 0f20 040F      		add r16,r20
 3461 0f22 151F      		adc r17,r21
 3462 0f24 261F      		adc r18,r22
 3463 0f26 371F      		adc r19,r23
 3464               	.LVL210:
 3465               	.L168:
 3466               	.LBE202:
1044:stk500boot.c  **** 						msgBuffer[1]	=	STATUS_CMD_OK;
 3467               		.loc 1 1044 0
 3468 0f28 1A82      		std Y+2,__zero_reg__
 3469               	.LBE204:
1046:stk500boot.c  **** 					break;
 3470               		.loc 1 1046 0
 3471 0f2a C25E      		subi r28,lo8(-286)
 3472 0f2c DE4F      		sbci r29,hi8(-286)
 3473 0f2e 0883      		st Y,r16
 3474 0f30 1983      		std Y+1,r17
 3475 0f32 2A83      		std Y+2,r18
 3476 0f34 3B83      		std Y+3,r19
 3477 0f36 CE51      		subi r28,lo8(286)
 3478 0f38 D140      		sbci r29,hi8(286)
 3479 0f3a 00C0      		rjmp .L224
 3480               	.LVL211:
 3481               	.L143:
 3482               	.LBB205:
1051:stk500boot.c  **** 						unsigned int	size	=	((msgBuffer[1])<<8) | msgBuffer[2];
 3483               		.loc 1 1051 0
 3484 0f3c 5A81      		ldd r21,Y+2
 3485 0f3e C25C      		subi r28,lo8(-318)
 3486 0f40 DE4F      		sbci r29,hi8(-318)
 3487 0f42 5883      		st Y,r21
 3488 0f44 CE53      		subi r28,lo8(318)
 3489 0f46 D140      		sbci r29,hi8(318)
 3490 0f48 C35C      		subi r28,lo8(-317)
 3491 0f4a DE4F      		sbci r29,hi8(-317)
 3492 0f4c 1882      		st Y,__zero_reg__
 3493 0f4e CD53      		subi r28,lo8(317)
 3494 0f50 D140      		sbci r29,hi8(317)
 3495 0f52 2B81      		ldd r18,Y+3
 3496 0f54 30E0      		ldi r19,lo8(0)
 3497 0f56 C35C      		subi r28,lo8(-317)
 3498 0f58 DE4F      		sbci r29,hi8(-317)
 3499 0f5a 6881      		ld r22,Y
 3500 0f5c 7981      		ldd r23,Y+1
 3501 0f5e CD53      		subi r28,lo8(317)
 3502 0f60 D140      		sbci r29,hi8(317)
 3503 0f62 262B      		or r18,r22
 3504 0f64 372B      		or r19,r23
 3505               	.LVL212:
1053:stk500boot.c  **** 						msgLength				=	size+3;
 3506               		.loc 1 1053 0
 3507 0f66 B3E0      		ldi r27,lo8(3)
 3508 0f68 EB2E      		mov r14,r27
 3509 0f6a F12C      		mov r15,__zero_reg__
 3510 0f6c E20E      		add r14,r18
 3511 0f6e F31E      		adc r15,r19
 3512               	.LVL213:
1055:stk500boot.c  **** 						*p++	=	STATUS_CMD_OK;
 3513               		.loc 1 1055 0
 3514 0f70 1A82      		std Y+2,__zero_reg__
 3515               	.LVL214:
1056:stk500boot.c  **** 						if (msgBuffer[0] == CMD_READ_FLASH_ISP )
 3516               		.loc 1 1056 0
 3517 0f72 8431      		cpi r24,lo8(20)
 3518 0f74 01F4      		brne .L195
 3519 0f76 DE01      		movw r26,r28
 3520               	.LVL215:
 3521 0f78 1396      		adiw r26,3
 3522               	.LVL216:
 3523 0f7a C25E      		subi r28,lo8(-286)
 3524 0f7c DE4F      		sbci r29,hi8(-286)
 3525 0f7e 4881      		ld r20,Y
 3526 0f80 5981      		ldd r21,Y+1
 3527 0f82 6A81      		ldd r22,Y+2
 3528 0f84 7B81      		ldd r23,Y+3
 3529 0f86 CE51      		subi r28,lo8(286)
 3530 0f88 D140      		sbci r29,hi8(286)
 3531               	.LVL217:
 3532               	.L172:
 3533               	.LBB206:
 3534               	.LBB207:
1064:stk500boot.c  **** 								data	=	pgm_read_word_far(address);
 3535               		.loc 1 1064 0 discriminator 1
 3536               	/* #APP */
 3537               	 ;  1064 "stk500boot.c" 1
 3538 0f8a 6BBF      		out 59, r22
 3539 0f8c FA01      		movw r30, r20
 3540 0f8e 8791      		elpm r24, Z+
 3541 0f90 9691      		elpm r25, Z
 3542               		
 3543               	 ;  0 "" 2
 3544               	/* #NOAPP */
 3545               	.LBE207:
1068:stk500boot.c  **** 								*p++	=	(unsigned char)data;		//LSB
 3546               		.loc 1 1068 0 discriminator 1
 3547 0f92 8C93      		st X,r24
 3548               	.LVL218:
1069:stk500boot.c  **** 								*p++	=	(unsigned char)(data >> 8);	//MSB
 3549               		.loc 1 1069 0 discriminator 1
 3550 0f94 1196      		adiw r26,1
 3551 0f96 9C93      		st X,r25
 3552 0f98 1197      		sbiw r26,1
 542:stk500boot.c  **** int main(void)
 3553               		.loc 1 542 0 discriminator 1
 3554 0f9a 1296      		adiw r26,2
 3555               	.LVL219:
1070:stk500boot.c  **** 								address	+=	2;							// Select next word in memory
 3556               		.loc 1 1070 0 discriminator 1
 3557 0f9c 4E5F      		subi r20,lo8(-(2))
 3558 0f9e 5F4F      		sbci r21,hi8(-(2))
 3559 0fa0 6F4F      		sbci r22,hlo8(-(2))
 3560 0fa2 7F4F      		sbci r23,hhi8(-(2))
 3561               	.LVL220:
1071:stk500boot.c  **** 								size	-=	2;
 3562               		.loc 1 1071 0 discriminator 1
 3563 0fa4 2250      		subi r18,lo8(-(-2))
 3564 0fa6 3040      		sbci r19,hi8(-(-2))
 3565               	.LVL221:
1072:stk500boot.c  **** 							}while (size);
 3566               		.loc 1 1072 0 discriminator 1
 3567 0fa8 01F4      		brne .L172
 3568 0faa C25E      		subi r28,lo8(-286)
 3569 0fac DE4F      		sbci r29,hi8(-286)
 3570 0fae 4883      		st Y,r20
 3571 0fb0 5983      		std Y+1,r21
 3572 0fb2 6A83      		std Y+2,r22
 3573 0fb4 7B83      		std Y+3,r23
 3574 0fb6 CE51      		subi r28,lo8(286)
 3575 0fb8 D140      		sbci r29,hi8(286)
 3576 0fba 00C0      		rjmp .L173
 3577               	.LVL222:
 3578               	.L195:
 3579               	.LBE206:
1056:stk500boot.c  **** 						if (msgBuffer[0] == CMD_READ_FLASH_ISP )
 3580               		.loc 1 1056 0
 3581 0fbc F901      		movw r30,r18
 3582 0fbe C25E      		subi r28,lo8(-286)
 3583 0fc0 DE4F      		sbci r29,hi8(-286)
 3584 0fc2 4881      		ld r20,Y
 3585 0fc4 5981      		ldd r21,Y+1
 3586 0fc6 6A81      		ldd r22,Y+2
 3587 0fc8 7B81      		ldd r23,Y+3
 3588 0fca CE51      		subi r28,lo8(286)
 3589 0fcc D140      		sbci r29,hi8(286)
 3590 0fce 8E01      		movw r16,r28
 3591               	.LVL223:
 3592 0fd0 0D5F      		subi r16,lo8(-(3))
 3593 0fd2 1F4F      		sbci r17,hi8(-(3))
 3594               	.LVL224:
 3595               	.L171:
1078:stk500boot.c  **** 								EEARL	=	address;			// Setup EEPROM address
 3596               		.loc 1 1078 0 discriminator 1
 3597 0fd4 41BD      		out 65-32,r20
1079:stk500boot.c  **** 								EEARH	=	((address >> 8));
 3598               		.loc 1 1079 0 discriminator 1
 3599 0fd6 BB27      		clr r27
 3600 0fd8 A72F      		mov r26,r23
 3601 0fda 962F      		mov r25,r22
 3602 0fdc 852F      		mov r24,r21
 3603 0fde 82BD      		out 66-32,r24
1080:stk500boot.c  **** 								address++;					// Select next EEPROM byte
 3604               		.loc 1 1080 0 discriminator 1
 3605 0fe0 4F5F      		subi r20,lo8(-(1))
 3606 0fe2 5F4F      		sbci r21,hi8(-(1))
 3607 0fe4 6F4F      		sbci r22,hlo8(-(1))
 3608 0fe6 7F4F      		sbci r23,hhi8(-(1))
 3609               	.LVL225:
1081:stk500boot.c  **** 								EECR	|=	(1<<EERE);			// Read EEPROM
 3610               		.loc 1 1081 0 discriminator 1
 3611 0fe8 F89A      		sbi 63-32,0
1082:stk500boot.c  **** 								*p++	=	EEDR;				// Send EEPROM data
 3612               		.loc 1 1082 0 discriminator 1
 3613 0fea 80B5      		in r24,64-32
 3614 0fec D801      		movw r26,r16
 3615 0fee 8D93      		st X+,r24
 3616 0ff0 8D01      		movw r16,r26
 3617               	.LVL226:
1083:stk500boot.c  **** 								size--;
 3618               		.loc 1 1083 0 discriminator 1
 3619 0ff2 3197      		sbiw r30,1
 3620               	.LVL227:
1084:stk500boot.c  **** 							} while (size);
 3621               		.loc 1 1084 0 discriminator 1
 3622 0ff4 01F4      		brne .L171
 542:stk500boot.c  **** int main(void)
 3623               		.loc 1 542 0
 3624 0ff6 C901      		movw r24,r18
 3625 0ff8 0197      		sbiw r24,1
 3626 0ffa A0E0      		ldi r26,lo8(0)
 3627 0ffc B0E0      		ldi r27,hi8(0)
 3628               	.LVL228:
 3629 0ffe 0196      		adiw r24,1
 3630 1000 A11D      		adc r26,__zero_reg__
 3631 1002 B11D      		adc r27,__zero_reg__
1084:stk500boot.c  **** 							} while (size);
 3632               		.loc 1 1084 0
 3633 1004 C25E      		subi r28,lo8(-286)
 3634 1006 DE4F      		sbci r29,hi8(-286)
 3635 1008 4881      		ld r20,Y
 3636 100a 5981      		ldd r21,Y+1
 3637 100c 6A81      		ldd r22,Y+2
 3638 100e 7B81      		ldd r23,Y+3
 3639 1010 CE51      		subi r28,lo8(286)
 3640 1012 D140      		sbci r29,hi8(286)
 3641               	.LVL229:
 3642 1014 480F      		add r20,r24
 3643 1016 591F      		adc r21,r25
 3644 1018 6A1F      		adc r22,r26
 3645 101a 7B1F      		adc r23,r27
 3646 101c C25E      		subi r28,lo8(-286)
 3647 101e DE4F      		sbci r29,hi8(-286)
 3648 1020 4883      		st Y,r20
 3649 1022 5983      		std Y+1,r21
 3650 1024 6A83      		std Y+2,r22
 3651 1026 7B83      		std Y+3,r23
 3652 1028 CE51      		subi r28,lo8(286)
 3653 102a D140      		sbci r29,hi8(286)
 3654 102c DE01      		movw r26,r28
 3655 102e 1396      		adiw r26,3
 3656 1030 A20F      		add r26,r18
 3657 1032 B31F      		adc r27,r19
 3658               	.LVL230:
 3659               	.L173:
1086:stk500boot.c  **** 						*p++	=	STATUS_CMD_OK;
 3660               		.loc 1 1086 0
 3661 1034 1C92      		st X,__zero_reg__
 3662               	.LVL231:
 3663               	.LBE205:
1088:stk500boot.c  **** 					break;
 3664               		.loc 1 1088 0
 3665 1036 00C0      		rjmp .L155
 3666               	.LVL232:
 3667               	.L135:
1092:stk500boot.c  **** 					msgBuffer[1]	=	STATUS_CMD_FAILED;
 3668               		.loc 1 1092 0
 3669 1038 80EC      		ldi r24,lo8(-64)
 3670 103a 8A83      		std Y+2,r24
 3671               	.L224:
1091:stk500boot.c  **** 					msgLength		=	2;
 3672               		.loc 1 1091 0
 3673 103c 32E0      		ldi r19,lo8(2)
 3674 103e E32E      		mov r14,r19
 3675 1040 F12C      		mov r15,__zero_reg__
 3676               	.LVL233:
 3677               	.L155:
1099:stk500boot.c  **** 			sendchar(MESSAGE_START);
 3678               		.loc 1 1099 0
 3679 1042 8BE1      		ldi r24,lo8(27)
 3680 1044 0E94 0000 		call sendchar
 3681               	.LVL234:
1102:stk500boot.c  **** 			sendchar(seqNum);
 3682               		.loc 1 1102 0
 3683 1048 CA5D      		subi r28,lo8(-294)
 3684 104a DE4F      		sbci r29,hi8(-294)
 3685 104c 8881      		ld r24,Y
 3686 104e C652      		subi r28,lo8(294)
 3687 1050 D140      		sbci r29,hi8(294)
 3688 1052 0E94 0000 		call sendchar
 3689               	.LVL235:
1106:stk500boot.c  **** 			sendchar(c);
 3690               		.loc 1 1106 0
 3691 1056 8F2D      		mov r24,r15
 3692 1058 0E94 0000 		call sendchar
 3693               	.LVL236:
1110:stk500boot.c  **** 			sendchar(c);
 3694               		.loc 1 1110 0
 3695 105c 8E2D      		mov r24,r14
 3696 105e 0E94 0000 		call sendchar
 3697               	.LVL237:
1113:stk500boot.c  **** 			sendchar(TOKEN);
 3698               		.loc 1 1113 0
 3699 1062 8EE0      		ldi r24,lo8(14)
 3700 1064 0E94 0000 		call sendchar
1107:stk500boot.c  **** 			checksum	^=	c;
 3701               		.loc 1 1107 0
 3702 1068 25E1      		ldi r18,lo8(21)
 3703 106a C22E      		mov r12,r18
 3704 106c CA5D      		subi r28,lo8(-294)
 3705 106e DE4F      		sbci r29,hi8(-294)
 3706 1070 2881      		ld r18,Y
 3707 1072 C652      		subi r28,lo8(294)
 3708 1074 D140      		sbci r29,hi8(294)
 3709 1076 C226      		eor r12,r18
1111:stk500boot.c  **** 			checksum ^= c;
 3710               		.loc 1 1111 0
 3711 1078 CE24      		eor r12,r14
1114:stk500boot.c  **** 			checksum ^= TOKEN;
 3712               		.loc 1 1114 0
 3713 107a CF24      		eor r12,r15
 3714               	.LVL238:
1116:stk500boot.c  **** 			p	=	msgBuffer;
 3715               		.loc 1 1116 0
 3716 107c 4E01      		movw r8,r28
 3717 107e 0894      		sec
 3718 1080 811C      		adc r8,__zero_reg__
 3719 1082 911C      		adc r9,__zero_reg__
1117:stk500boot.c  **** 			while ( msgLength )
 3720               		.loc 1 1117 0
 3721 1084 00C0      		rjmp .L174
 3722               	.LVL239:
 3723               	.L175:
1119:stk500boot.c  **** 				c	=	*p++;
 3724               		.loc 1 1119 0
 3725 1086 D401      		movw r26,r8
 3726 1088 1D91      		ld r17,X+
 3727 108a 4D01      		movw r8,r26
 3728               	.LVL240:
1120:stk500boot.c  **** 				sendchar(c);
 3729               		.loc 1 1120 0
 3730 108c 812F      		mov r24,r17
 3731 108e 0E94 0000 		call sendchar
 3732               	.LVL241:
1121:stk500boot.c  **** 				checksum ^=c;
 3733               		.loc 1 1121 0
 3734 1092 C126      		eor r12,r17
 3735               	.LVL242:
1122:stk500boot.c  **** 				msgLength--;
 3736               		.loc 1 1122 0
 3737 1094 0894      		sec
 3738 1096 E108      		sbc r14,__zero_reg__
 3739 1098 F108      		sbc r15,__zero_reg__
 3740               	.LVL243:
 3741               	.L174:
1117:stk500boot.c  **** 			while ( msgLength )
 3742               		.loc 1 1117 0 discriminator 1
 3743 109a E114      		cp r14,__zero_reg__
 3744 109c F104      		cpc r15,__zero_reg__
 3745 109e 01F4      		brne .L175
1124:stk500boot.c  **** 			sendchar(checksum);
 3746               		.loc 1 1124 0
 3747 10a0 8C2D      		mov r24,r12
 3748 10a2 0E94 0000 		call sendchar
1125:stk500boot.c  **** 			seqNum++;
 3749               		.loc 1 1125 0
 3750 10a6 CA5D      		subi r28,lo8(-294)
 3751 10a8 DE4F      		sbci r29,hi8(-294)
 3752 10aa 2881      		ld r18,Y
 3753 10ac C652      		subi r28,lo8(294)
 3754 10ae D140      		sbci r29,hi8(294)
 3755 10b0 2F5F      		subi r18,lo8(-(1))
 3756 10b2 CA5D      		subi r28,lo8(-294)
 3757 10b4 DE4F      		sbci r29,hi8(-294)
 3758 10b6 2883      		st Y,r18
 3759 10b8 C652      		subi r28,lo8(294)
 3760 10ba D140      		sbci r29,hi8(294)
 3761               	.LVL244:
1129:stk500boot.c  **** 			PROGLED_PORT	^=	(1<<PROGLED_PIN);	// active high LED ON
 3762               		.loc 1 1129 0
 3763 10bc 8BB1      		in r24,43-32
 3764 10be 8058      		subi r24,lo8(-(-128))
 3765 10c0 8BB9      		out 43-32,r24
 3766               	.LVL245:
 677:stk500boot.c  **** 		while (!isLeave)
 3767               		.loc 1 677 0
 3768 10c2 4420      		tst r4
 3769 10c4 01F0      		breq .+2
 3770 10c6 00C0      		rjmp .L51
 3771 10c8 80E0      		ldi r24,lo8(0)
 3772 10ca 90E0      		ldi r25,hi8(0)
 3773 10cc 00C0      		rjmp .L50
 3774               	.LVL246:
 3775               	.L228:
 674:stk500boot.c  **** 	if (boot_state==1)
 3776               		.loc 1 674 0
 3777 10ce C75D      		subi r28,lo8(-297)
 3778 10d0 DE4F      		sbci r29,hi8(-297)
 3779 10d2 1982      		std Y+1,__zero_reg__
 3780 10d4 1882      		st Y,__zero_reg__
 3781 10d6 C952      		subi r28,lo8(297)
 3782 10d8 D140      		sbci r29,hi8(297)
 3783 10da EE24      		clr r14
 3784 10dc FF24      		clr r15
 3785 10de 2224      		clr r2
 3786 10e0 CC24      		clr r12
 3787 10e2 C95D      		subi r28,lo8(-295)
 3788 10e4 DE4F      		sbci r29,hi8(-295)
 3789 10e6 1982      		std Y+1,__zero_reg__
 3790 10e8 1882      		st Y,__zero_reg__
 3791 10ea C752      		subi r28,lo8(295)
 3792 10ec D140      		sbci r29,hi8(295)
 3793 10ee CE5D      		subi r28,lo8(-290)
 3794 10f0 DE4F      		sbci r29,hi8(-290)
 3795 10f2 1882      		st Y,__zero_reg__
 3796 10f4 1982      		std Y+1,__zero_reg__
 3797 10f6 1A82      		std Y+2,__zero_reg__
 3798 10f8 1B82      		std Y+3,__zero_reg__
 3799 10fa C252      		subi r28,lo8(290)
 3800 10fc D140      		sbci r29,hi8(290)
 3801 10fe C25E      		subi r28,lo8(-286)
 3802 1100 DE4F      		sbci r29,hi8(-286)
 3803 1102 1882      		st Y,__zero_reg__
 3804 1104 1982      		std Y+1,__zero_reg__
 3805 1106 1A82      		std Y+2,__zero_reg__
 3806 1108 1B82      		std Y+3,__zero_reg__
 3807 110a CE51      		subi r28,lo8(286)
 3808 110c D140      		sbci r29,hi8(286)
 3809               	.LBB208:
 3810               	.LBB137:
 3811               	.LBB135:
 3812               	.LBB134:
 519:stk500boot.c  **** 			data	=	pgm_read_word_far(0);	//*	get the first word of the user program
 3813               		.loc 1 519 0
 3814 110e 20E0      		ldi r18,lo8(0)
 3815 1110 30E0      		ldi r19,hi8(0)
 3816 1112 A901      		movw r20,r18
 3817               	/* #APP */
 3818               	 ;  519 "stk500boot.c" 1
 3819 1114 4BBF      		out 59, r20
 3820 1116 F901      		movw r30, r18
 3821 1118 4791      		elpm r20, Z+
 3822 111a 5691      		elpm r21, Z
 3823               		
 3824               	 ;  0 "" 2
 3825               	/* #NOAPP */
 3826 111c C15C      		subi r28,lo8(-319)
 3827 111e DE4F      		sbci r29,hi8(-319)
 3828 1120 5983      		std Y+1,r21
 3829 1122 4883      		st Y,r20
 3830 1124 CF53      		subi r28,lo8(319)
 3831 1126 D140      		sbci r29,hi8(319)
 3832               	.LBE134:
 3833               	.LBE135:
 3834               	.LBE137:
 3835               	.LBE208:
 773:stk500boot.c  **** 						msgBuffer[ii++]	=	c;
 3836               		.loc 1 773 0
 3837 1128 CA5D      		subi r28,lo8(-294)
 3838 112a DE4F      		sbci r29,hi8(-294)
 3839 112c 2882      		st Y,r2
 3840 112e C652      		subi r28,lo8(294)
 3841 1130 D140      		sbci r29,hi8(294)
 3842 1132 1701      		movw r2,r14
 3843               	.LVL247:
 3844               	.L50:
 592:stk500boot.c  **** 	boot_timer	=	0;
 3845               		.loc 1 592 0 discriminator 1
 3846 1134 40E0      		ldi r20,lo8(0)
 3847 1136 50E0      		ldi r21,hi8(0)
 3848 1138 20E0      		ldi r18,lo8(0)
 3849 113a C95D      		subi r28,lo8(-295)
 3850 113c DE4F      		sbci r29,hi8(-295)
 3851 113e 0881      		ld r16,Y
 3852 1140 1981      		ldd r17,Y+1
 3853 1142 C752      		subi r28,lo8(295)
 3854 1144 D140      		sbci r29,hi8(295)
 3855 1146 C75D      		subi r28,lo8(-297)
 3856 1148 DE4F      		sbci r29,hi8(-297)
 3857 114a E880      		ld r14,Y
 3858 114c F980      		ldd r15,Y+1
 3859 114e C952      		subi r28,lo8(297)
 3860 1150 D140      		sbci r29,hi8(297)
 3861 1152 B101      		movw r22,r2
 3862 1154 0C94 0000 		jmp .L176
 3863               	.LVL248:
 3864               	.L51:
1164:stk500boot.c  **** 	PROGLED_DDR		&=	~(1<<PROGLED_PIN);	// set to default
 3865               		.loc 1 1164 0
 3866 1158 5798      		cbi 42-32,7
1165:stk500boot.c  **** 	PROGLED_PORT	&=	~(1<<PROGLED_PIN);	// active low LED OFF
 3867               		.loc 1 1165 0
 3868 115a 5F98      		cbi 43-32,7
1167:stk500boot.c  **** 	delay_ms(100);							// delay after exit
 3869               		.loc 1 1167 0
 3870 115c 84E6      		ldi r24,lo8(100)
 3871 115e 90E0      		ldi r25,hi8(100)
 3872 1160 0E94 0000 		call delay_ms
1171:stk500boot.c  **** 	asm volatile ("nop");			// wait until port has changed
 3873               		.loc 1 1171 0
 3874               	/* #APP */
 3875               	 ;  1171 "stk500boot.c" 1
 3876 1164 0000      		nop
 3877               	 ;  0 "" 2
1177:stk500boot.c  **** 	UART_STATUS_REG	&=	0xfd;
 3878               		.loc 1 1177 0
 3879               	/* #NOAPP */
 3880 1166 8091 C000 		lds r24,192
 3881 116a 8D7F      		andi r24,lo8(-3)
 3882 116c 8093 C000 		sts 192,r24
1178:stk500boot.c  **** 	boot_rww_enable();				// enable application section
 3883               		.loc 1 1178 0
 3884 1170 81E1      		ldi r24,lo8(17)
 3885               	/* #APP */
 3886               	 ;  1178 "stk500boot.c" 1
 3887 1172 8093 5700 		sts 87, r24
 3888 1176 E895      		spm
 3889               		
 3890               	 ;  0 "" 2
1181:stk500boot.c  **** 	asm volatile(
 3891               		.loc 1 1181 0
 3892               	 ;  1181 "stk500boot.c" 1
 3893 1178 EE27      		clr	r30		
 3894 117a FF27      		clr	r31		
 3895 117c 0994      		ijmp	
 3896               		
 3897               	 ;  0 "" 2
 3898               	/* #NOAPP */
 3899               	.L177:
 3900 117e 00C0      		rjmp .L177
 3901               	.LVL249:
 3902               	.L239:
 724:stk500boot.c  **** 							checksum		=	MESSAGE_START^0;
 3903               		.loc 1 724 0
 3904 1180 9BE1      		ldi r25,lo8(27)
 3905 1182 C92E      		mov r12,r25
 723:stk500boot.c  **** 							msgParseState	=	ST_GET_SEQ_NUM;
 3906               		.loc 1 723 0
 3907 1184 21E0      		ldi r18,lo8(1)
 3908 1186 0C94 0000 		jmp .L134
 3909               	.L184:
 768:stk500boot.c  **** 							msgParseState	=	ST_START;
 3910               		.loc 1 768 0
 3911 118a 20E0      		ldi r18,lo8(0)
 3912 118c 0C94 0000 		jmp .L134
 3913               	.LVL250:
 3914               	.L240:
 777:stk500boot.c  **** 							msgParseState	=	ST_GET_CHECK;
 3915               		.loc 1 777 0
 3916 1190 26E0      		ldi r18,lo8(6)
 3917               	.LVL251:
 3918 1192 0C94 0000 		jmp .L134
 3919               		.cfi_endproc
 3920               	.LFE13:
 3922               	.global	gTextMsg_END
 3923               		.section	.progmem.data,"a",@progbits
 3926               	gTextMsg_END:
 3927 0000 2A00      		.string	"*"
 3928               	.global	gTextMsg_HELP_MSG_Y
 3931               	gTextMsg_HELP_MSG_Y:
 3932 0002 593D 506F 		.string	"Y=Port blink"
 3932      7274 2062 
 3932      6C69 6E6B 
 3932      00
 3933               	.global	gTextMsg_HELP_MSG_V
 3936               	gTextMsg_HELP_MSG_V:
 3937 000f 563D 7368 		.string	"V=show interrupt Vectors"
 3937      6F77 2069 
 3937      6E74 6572 
 3937      7275 7074 
 3937      2056 6563 
 3938               	.global	gTextMsg_HELP_MSG_R
 3941               	gTextMsg_HELP_MSG_R:
 3942 0028 523D 4475 		.string	"R=Dump RAM"
 3942      6D70 2052 
 3942      414D 00
 3943               	.global	gTextMsg_HELP_MSG_Q
 3946               	gTextMsg_HELP_MSG_Q:
 3947 0033 513D 5175 		.string	"Q=Quit"
 3947      6974 00
 3948               	.global	gTextMsg_HELP_MSG_L
 3951               	gTextMsg_HELP_MSG_L:
 3952 003a 4C3D 4C69 		.string	"L=List I/O Ports"
 3952      7374 2049 
 3952      2F4F 2050 
 3952      6F72 7473 
 3952      00
 3953               	.global	gTextMsg_HELP_MSG_H
 3956               	gTextMsg_HELP_MSG_H:
 3957 004b 483D 4865 		.string	"H=Help"
 3957      6C70 00
 3958               	.global	gTextMsg_HELP_MSG_F
 3961               	gTextMsg_HELP_MSG_F:
 3962 0052 463D 4475 		.string	"F=Dump FLASH"
 3962      6D70 2046 
 3962      4C41 5348 
 3962      00
 3963               	.global	gTextMsg_HELP_MSG_E
 3966               	gTextMsg_HELP_MSG_E:
 3967 005f 453D 4475 		.string	"E=Dump EEPROM"
 3967      6D70 2045 
 3967      4550 524F 
 3967      4D00 
 3968               	.global	gTextMsg_HELP_MSG_B
 3971               	gTextMsg_HELP_MSG_B:
 3972 006d 423D 426C 		.string	"B=Blink LED"
 3972      696E 6B20 
 3972      4C45 4400 
 3973               	.global	gTextMsg_HELP_MSG_AT
 3976               	gTextMsg_HELP_MSG_AT:
 3977 0079 403D 4545 		.string	"@=EEPROM test"
 3977      5052 4F4D 
 3977      2074 6573 
 3977      7400 
 3978               	.global	gTextMsg_HELP_MSG_QM
 3981               	gTextMsg_HELP_MSG_QM:
 3982 0087 3F3D 4350 		.string	"?=CPU stats"
 3982      5520 7374 
 3982      6174 7300 
 3983               	.global	gTextMsg_HELP_MSG_0
 3986               	gTextMsg_HELP_MSG_0:
 3987 0093 303D 5A65 		.string	"0=Zero addr"
 3987      726F 2061 
 3987      6464 7200 
 3988               	.global	gTextMsg_PORT
 3991               	gTextMsg_PORT:
 3992 009f 504F 5254 		.string	"PORT"
 3992      00
 3993               	.global	gTextMsg_EEPROMerrorCnt
 3996               	gTextMsg_EEPROMerrorCnt:
 3997 00a4 4545 2065 		.string	"EE err cnt="
 3997      7272 2063 
 3997      6E74 3D00 
 3998               	.global	gTextMsg_ReadingEEprom
 4001               	gTextMsg_ReadingEEprom:
 4002 00b0 5265 6164 		.string	"Reading EE"
 4002      696E 6720 
 4002      4545 00
 4003               	.global	gTextMsg_WriteToEEprom
 4006               	gTextMsg_WriteToEEprom:
 4007 00bb 5772 6974 		.string	"Writting EE"
 4007      7469 6E67 
 4007      2045 4500 
 4008               	.global	gTextMsg_SPACE
 4011               	gTextMsg_SPACE:
 4012 00c7 2000      		.string	" "
 4013               	.global	gTextMsg_MustBeLetter
 4016               	gTextMsg_MustBeLetter:
 4017 00c9 4D75 7374 		.string	"Must be a letter"
 4017      2062 6520 
 4017      6120 6C65 
 4017      7474 6572 
 4017      00
 4018               	.global	gTextMsg_PortNotSupported
 4021               	gTextMsg_PortNotSupported:
 4022 00da 506F 7274 		.string	"Port not supported"
 4022      206E 6F74 
 4022      2073 7570 
 4022      706F 7274 
 4022      6564 00
 4023               	.global	gTextMsg_WHAT_PORT
 4026               	gTextMsg_WHAT_PORT:
 4027 00ed 5768 6174 		.string	"What port:"
 4027      2070 6F72 
 4027      743A 00
 4028               	.global	gTextMsg_jmp
 4031               	gTextMsg_jmp:
 4032 00f8 6A6D 7020 		.string	"jmp "
 4032      00
 4033               	.global	gTextMsg_rjmp
 4036               	gTextMsg_rjmp:
 4037 00fd 726A 6D70 		.string	"rjmp  "
 4037      2020 00
 4038               	.global	gTextMsg_noVector
 4041               	gTextMsg_noVector:
 4042 0104 6E6F 2076 		.string	"no vector"
 4042      6563 746F 
 4042      7200 
 4043               	.global	gTextMsg_VECTOR_HEADER
 4046               	gTextMsg_VECTOR_HEADER:
 4047 010e 5623 2020 		.string	"V#   ADDR   op code     instruction addr   Interrupt"
 4047      2041 4444 
 4047      5220 2020 
 4047      6F70 2063 
 4047      6F64 6520 
 4048               	.global	gTextMsg_GCC_VERSION_STR
 4051               	gTextMsg_GCC_VERSION_STR:
 4052 0143 342E 362E 		.string	"4.6.2"
 4052      3200 
 4053               	.global	gTextMsg_AVR_LIBC_VER_STR
 4056               	gTextMsg_AVR_LIBC_VER_STR:
 4057 0149 312E 382E 		.string	"1.8.0"
 4057      3000 
 4058               	.global	gTextMsg_GCC_DATE_STR
 4061               	gTextMsg_GCC_DATE_STR:
 4062 014f 4170 7220 		.string	"Apr 19 2013"
 4062      3139 2032 
 4062      3031 3300 
 4063               	.global	gTextMsg_FUSE_BYTE_LOCK
 4066               	gTextMsg_FUSE_BYTE_LOCK:
 4067 015b 4C6F 636B 		.string	"Lock fuse   = "
 4067      2066 7573 
 4067      6520 2020 
 4067      3D20 00
 4068               	.global	gTextMsg_FUSE_BYTE_EXT
 4071               	gTextMsg_FUSE_BYTE_EXT:
 4072 016a 4578 7420 		.string	"Ext fuse    = "
 4072      6675 7365 
 4072      2020 2020 
 4072      3D20 00
 4073               	.global	gTextMsg_FUSE_BYTE_HIGH
 4076               	gTextMsg_FUSE_BYTE_HIGH:
 4077 0179 4869 6768 		.string	"High fuse   = "
 4077      2066 7573 
 4077      6520 2020 
 4077      3D20 00
 4078               	.global	gTextMsg_FUSE_BYTE_LOW
 4081               	gTextMsg_FUSE_BYTE_LOW:
 4082 0188 4C6F 7720 		.string	"Low fuse    = "
 4082      6675 7365 
 4082      2020 2020 
 4082      3D20 00
 4083               	.global	gTextMsg_CPU_SIGNATURE
 4086               	gTextMsg_CPU_SIGNATURE:
 4087 0197 4350 5520 		.string	"CPU ID      = "
 4087      4944 2020 
 4087      2020 2020 
 4087      3D20 00
 4088               	.global	gTextMsg_GCC_VERSION
 4091               	gTextMsg_GCC_VERSION:
 4092 01a6 4743 4320 		.string	"GCC Version = "
 4092      5665 7273 
 4092      696F 6E20 
 4092      3D20 00
 4093               	.global	gTextMsg_AVR_LIBC
 4096               	gTextMsg_AVR_LIBC:
 4097 01b5 4156 5220 		.string	"AVR LibC Ver= "
 4097      4C69 6243 
 4097      2056 6572 
 4097      3D20 00
 4098               	.global	gTextMsg_AVR_ARCH
 4101               	gTextMsg_AVR_ARCH:
 4102 01c4 5F5F 4156 		.string	"__AVR_ARCH__= "
 4102      525F 4152 
 4102      4348 5F5F 
 4102      3D20 00
 4103               	.global	gTextMsg_CPU_Type
 4106               	gTextMsg_CPU_Type:
 4107 01d3 4350 5520 		.string	"CPU Type    = "
 4107      5479 7065 
 4107      2020 2020 
 4107      3D20 00
 4108               	.global	gTextMsg_COMPILED_ON
 4111               	gTextMsg_COMPILED_ON:
 4112 01e2 436F 6D70 		.string	"Compiled on = "
 4112      696C 6564 
 4112      206F 6E20 
 4112      3D20 00
 4113               	.global	gTextMsg_HUH
 4116               	gTextMsg_HUH:
 4117 01f1 4875 683F 		.string	"Huh?"
 4117      00
 4118               	.global	gTextMsg_Prompt
 4121               	gTextMsg_Prompt:
 4122 01f6 426F 6F74 		.string	"Bootloader>"
 4122      6C6F 6164 
 4122      6572 3E00 
 4123               	.global	gTextMsg_Explorer
 4126               	gTextMsg_Explorer:
 4127 0202 4172 6475 		.string	"Arduino explorer stk500V2 by MLS"
 4127      696E 6F20 
 4127      6578 706C 
 4127      6F72 6572 
 4127      2073 746B 
 4128               	.global	gTextMsg_CPU_Name
 4131               	gTextMsg_CPU_Name:
 4132 0223 4154 6D65 		.string	"ATmega25RFR2"
 4132      6761 3235 
 4132      5246 5232 
 4132      00
 4133               		.comm gEepromIndex,4,1
 4134               		.comm gFlashIndex,4,1
 4135               		.comm gRamIndex,4,1
 4136               	.global	app_start
 4137               	.global	app_start
 4138               		.section .bss
 4141               	app_start:
 4142 0000 0000      		.skip 2,0
 4143               		.data
 4146               	CSWTCH.30:
 4147 0000 0F        		.byte	15
 4148 0001 02        		.byte	2
 4149 0002 0A        		.byte	10
 4150               		.text
 4151               	.Letext0:
 4152               		.file 3 "c:\\winavr-20100110\\bin\\../lib/gcc/avr/4.6.2/../../../../avr/include/stdint.h"
DEFINED SYMBOLS
                            *ABS*:00000000 stk500boot.c
C:\Users\fu\AppData\Local\Temp\ccy7HTne.s:2      *ABS*:0000003f __SREG__
C:\Users\fu\AppData\Local\Temp\ccy7HTne.s:3      *ABS*:0000003e __SP_H__
C:\Users\fu\AppData\Local\Temp\ccy7HTne.s:4      *ABS*:0000003d __SP_L__
C:\Users\fu\AppData\Local\Temp\ccy7HTne.s:5      *ABS*:00000034 __CCP__
C:\Users\fu\AppData\Local\Temp\ccy7HTne.s:6      *ABS*:00000000 __tmp_reg__
C:\Users\fu\AppData\Local\Temp\ccy7HTne.s:7      *ABS*:00000001 __zero_reg__
C:\Users\fu\AppData\Local\Temp\ccy7HTne.s:14     .text:00000000 sendchar
C:\Users\fu\AppData\Local\Temp\ccy7HTne.s:44     .text.unlikely:00000000 recchar
C:\Users\fu\AppData\Local\Temp\ccy7HTne.s:68     .init9:00000000 __jumpMain
C:\Users\fu\AppData\Local\Temp\ccy7HTne.s:79     *ABS*:ffff81ff __stack
C:\Users\fu\AppData\Local\Temp\ccy7HTne.s:773    .text.startup:00000000 main
C:\Users\fu\AppData\Local\Temp\ccy7HTne.s:118    .text:00000018 delay_ms
C:\Users\fu\AppData\Local\Temp\ccy7HTne.s:162    .text:00000036 PrintFromPROGMEM
C:\Users\fu\AppData\Local\Temp\ccy7HTne.s:223    .text:0000005e PrintNewLine
C:\Users\fu\AppData\Local\Temp\ccy7HTne.s:245    .text.unlikely:0000000e PrintAvailablePort
C:\Users\fu\AppData\Local\Temp\ccy7HTne.s:3991   .progmem.data:0000009f gTextMsg_PORT
C:\Users\fu\AppData\Local\Temp\ccy7HTne.s:281    .text:0000006c PrintFromPROGMEMln
C:\Users\fu\AppData\Local\Temp\ccy7HTne.s:303    .text:00000076 PrintString
C:\Users\fu\AppData\Local\Temp\ccy7HTne.s:347    .text:0000008e PrintHexByte
C:\Users\fu\AppData\Local\Temp\ccy7HTne.s:404    .text.unlikely:0000002a DumpHex.constprop.0
C:\Users\fu\AppData\Local\Temp\ccy7HTne.s:675    .text:000000ba PrintDecInt
C:\Users\fu\AppData\Local\Temp\ccy7HTne.s:4141   .bss:00000000 app_start
                            *COM*:00000004 gRamIndex
                            *COM*:00000004 gFlashIndex
                            *COM*:00000004 gEepromIndex
C:\Users\fu\AppData\Local\Temp\ccy7HTne.s:4126   .progmem.data:00000202 gTextMsg_Explorer
C:\Users\fu\AppData\Local\Temp\ccy7HTne.s:4121   .progmem.data:000001f6 gTextMsg_Prompt
C:\Users\fu\AppData\Local\Temp\ccy7HTne.s:3986   .progmem.data:00000093 gTextMsg_HELP_MSG_0
C:\Users\fu\AppData\Local\Temp\ccy7HTne.s:3981   .progmem.data:00000087 gTextMsg_HELP_MSG_QM
C:\Users\fu\AppData\Local\Temp\ccy7HTne.s:4111   .progmem.data:000001e2 gTextMsg_COMPILED_ON
C:\Users\fu\AppData\Local\Temp\ccy7HTne.s:4061   .progmem.data:0000014f gTextMsg_GCC_DATE_STR
C:\Users\fu\AppData\Local\Temp\ccy7HTne.s:4106   .progmem.data:000001d3 gTextMsg_CPU_Type
C:\Users\fu\AppData\Local\Temp\ccy7HTne.s:4131   .progmem.data:00000223 gTextMsg_CPU_Name
C:\Users\fu\AppData\Local\Temp\ccy7HTne.s:4101   .progmem.data:000001c4 gTextMsg_AVR_ARCH
C:\Users\fu\AppData\Local\Temp\ccy7HTne.s:4091   .progmem.data:000001a6 gTextMsg_GCC_VERSION
C:\Users\fu\AppData\Local\Temp\ccy7HTne.s:4051   .progmem.data:00000143 gTextMsg_GCC_VERSION_STR
C:\Users\fu\AppData\Local\Temp\ccy7HTne.s:4096   .progmem.data:000001b5 gTextMsg_AVR_LIBC
C:\Users\fu\AppData\Local\Temp\ccy7HTne.s:4056   .progmem.data:00000149 gTextMsg_AVR_LIBC_VER_STR
C:\Users\fu\AppData\Local\Temp\ccy7HTne.s:4086   .progmem.data:00000197 gTextMsg_CPU_SIGNATURE
C:\Users\fu\AppData\Local\Temp\ccy7HTne.s:4081   .progmem.data:00000188 gTextMsg_FUSE_BYTE_LOW
C:\Users\fu\AppData\Local\Temp\ccy7HTne.s:4076   .progmem.data:00000179 gTextMsg_FUSE_BYTE_HIGH
C:\Users\fu\AppData\Local\Temp\ccy7HTne.s:4071   .progmem.data:0000016a gTextMsg_FUSE_BYTE_EXT
C:\Users\fu\AppData\Local\Temp\ccy7HTne.s:4066   .progmem.data:0000015b gTextMsg_FUSE_BYTE_LOCK
C:\Users\fu\AppData\Local\Temp\ccy7HTne.s:3976   .progmem.data:00000079 gTextMsg_HELP_MSG_AT
C:\Users\fu\AppData\Local\Temp\ccy7HTne.s:4006   .progmem.data:000000bb gTextMsg_WriteToEEprom
C:\Users\fu\AppData\Local\Temp\ccy7HTne.s:4011   .progmem.data:000000c7 gTextMsg_SPACE
C:\Users\fu\AppData\Local\Temp\ccy7HTne.s:4001   .progmem.data:000000b0 gTextMsg_ReadingEEprom
C:\Users\fu\AppData\Local\Temp\ccy7HTne.s:3996   .progmem.data:000000a4 gTextMsg_EEPROMerrorCnt
C:\Users\fu\AppData\Local\Temp\ccy7HTne.s:3971   .progmem.data:0000006d gTextMsg_HELP_MSG_B
C:\Users\fu\AppData\Local\Temp\ccy7HTne.s:3966   .progmem.data:0000005f gTextMsg_HELP_MSG_E
C:\Users\fu\AppData\Local\Temp\ccy7HTne.s:3961   .progmem.data:00000052 gTextMsg_HELP_MSG_F
C:\Users\fu\AppData\Local\Temp\ccy7HTne.s:3956   .progmem.data:0000004b gTextMsg_HELP_MSG_H
C:\Users\fu\AppData\Local\Temp\ccy7HTne.s:3951   .progmem.data:0000003a gTextMsg_HELP_MSG_L
C:\Users\fu\AppData\Local\Temp\ccy7HTne.s:3946   .progmem.data:00000033 gTextMsg_HELP_MSG_Q
C:\Users\fu\AppData\Local\Temp\ccy7HTne.s:3941   .progmem.data:00000028 gTextMsg_HELP_MSG_R
C:\Users\fu\AppData\Local\Temp\ccy7HTne.s:3936   .progmem.data:0000000f gTextMsg_HELP_MSG_V
C:\Users\fu\AppData\Local\Temp\ccy7HTne.s:3931   .progmem.data:00000002 gTextMsg_HELP_MSG_Y
C:\Users\fu\AppData\Local\Temp\ccy7HTne.s:4046   .progmem.data:0000010e gTextMsg_VECTOR_HEADER
C:\Users\fu\AppData\Local\Temp\ccy7HTne.s:4041   .progmem.data:00000104 gTextMsg_noVector
C:\Users\fu\AppData\Local\Temp\ccy7HTne.s:4036   .progmem.data:000000fd gTextMsg_rjmp
C:\Users\fu\AppData\Local\Temp\ccy7HTne.s:4031   .progmem.data:000000f8 gTextMsg_jmp
C:\Users\fu\AppData\Local\Temp\ccy7HTne.s:4026   .progmem.data:000000ed gTextMsg_WHAT_PORT
C:\Users\fu\AppData\Local\Temp\ccy7HTne.s:4021   .progmem.data:000000da gTextMsg_PortNotSupported
C:\Users\fu\AppData\Local\Temp\ccy7HTne.s:4016   .progmem.data:000000c9 gTextMsg_MustBeLetter
C:\Users\fu\AppData\Local\Temp\ccy7HTne.s:4116   .progmem.data:000001f1 gTextMsg_HUH
C:\Users\fu\AppData\Local\Temp\ccy7HTne.s:4146   .data:00000000 CSWTCH.30
C:\Users\fu\AppData\Local\Temp\ccy7HTne.s:3926   .progmem.data:00000000 gTextMsg_END

UNDEFINED SYMBOLS
__do_copy_data
__do_clear_bss
__eerd_byte_m256rfr2
__divmodhi4
__udivmodsi4
__eewr_byte_m256rfr2
